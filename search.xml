<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue特殊特性</title>
    <url>/2020/02/27/vue%E7%89%B9%E6%AE%8A%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ul>
<li><p>预期: number | string<br><code>key</code> 的投入数属性主要用在 Vue 的虚拟 DOM 算法. 在新旧 nodes 对比时辨识 VNode. 如果不使用 key, Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法. 而使用 key 时, 他会基于 key 的变化重新排列元素顺序. 并且会移除 key 不存在的元素</p>
<p>有相同父元素的子元素必须有独特的 key, 重复的 key 会造成渲染错误</p>
<p>最常见的用例是结合 <code>v-for</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它也可以用于强制特换元素/组件而不是重复使用它, 当你遇到如下场景时他可能会很有用</p>
<ul>
<li>完整的触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<p>例如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 <code>text</code> 发生改变时, <code>&lt;span&gt;</code> 总是会被替换而不是被修改. 因为会触发过渡</p>
</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><p>预期: string<br><code>ref</code> 被用来给元素或子组件注册引用信息. 引用信息将会被注册在父组件的 <code>$refs</code> 对象上. 如果在普通的 DOM 元素上使用. 引用指向的就是 DOM 元素. 如果用在子组件上, 引用就指向组件实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>
<p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
</li>
</ul>
<h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><ul>
<li><p>预期: string | Object<br>用于动态组件且基于 DOM 内模板的限制来工作</p>
<p>示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue指令</title>
    <url>/2020/02/26/vue%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><ul>
<li>预期: string</li>
<li>详细:<br>更新元素的 <code>textContent</code>. 如果要更新部分的 <code>textContent</code>, 需要使用 <code></code> 插值</li>
<li>示例:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和下面一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><ul>
<li>预期: string</li>
<li>详细:<br>更新元素的 <code>innerHTML</code>. 注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</li>
<li>示例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><ul>
<li>预期: any</li>
<li>用法:<br>根据表达式之真假值, 切换元素的 <code>display</code> CSS 属性<br>当条件变化时该指令触发过渡效果</li>
</ul>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><ul>
<li>预期: any</li>
<li>用法:<br>根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</li>
</ul>
<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><ul>
<li><p>不需要表达式</p>
</li>
<li><p>限制: 前一个兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code></p>
</li>
<li><p>用法:<br>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 else 块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><ul>
<li>类型: any</li>
<li>限制: 前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code></li>
<li>用法:<br>表示 <code>v-if</code> 的 else 块. 可以链式调用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul>
<li><p>预期: Array | Object | number | string | Iterable</p>
</li>
<li><p>用法:<br>基于源数据多次渲染元素或模板块. 此指令之值. 必须使用特定语法 <code>alias in expression</code>, 为当前遍历的元素提供别名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, name, index) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊属性 key 来提供一个排序提示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><ul>
<li><p>缩写: @</p>
</li>
<li><p>预期: Function | Inline Statement | Object</p>
</li>
<li><p>参数: event</p>
</li>
<li><p>修饰符:</p>
<ul>
<li><code>.stop</code> 调用 <code>event.stopPropagation()</code></li>
<li><code>.prevent</code> 调用 <code>event.preventDefault()</code></li>
<li><code>.capture</code> 添加时间侦听器时使用 capture 模式</li>
<li><code>.self</code> 只当时间是从侦听器绑定的元素本身触发时才触发回调</li>
<li><code>.{keyCode | keyAlias}</code> 只当时间是从特定键触发时才触发回调</li>
<li><code>.native</code> 监听组件根元素的原声事件</li>
<li><code>.once</code> 只触发一次回调</li>
<li><code>.left</code> 只当点击鼠标左键时触发</li>
<li><code>.right</code> 只当点击鼠标右键时触发</li>
<li><code>.middle</code> 只当点击鼠标中键时触发</li>
<li><code>.passive</code> 以 { passive: true } 模式添加侦听器</li>
</ul>
</li>
<li><p>用法:<br>绑定事件监听器. 事件类型由参数指定. 表达式可以是一个方法的名字或一个内联语句. 如果没有修饰符也可以省略</p>
<p>用在普通元素上时, 只能监听原生 DOM 事件, 用在自定义元素上时, 也可以监听子组件触发的自定义事件</p>
<p>在监听原生 DOM 事件时, 方法以事件为唯一的参数. 如果使用内联语句, 语句可以访问一个 <code>$event</code> 属性. <code>v-on:clicl=&quot;handle(&#39;ok&#39;, $event)</code>“</p>
</li>
<li><p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件 (2.6.0+) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:</span>[<span class="attr">event</span>]=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThat('hello', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件缩写 (2.6.0+) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @[<span class="attr">event</span>]=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  串联修饰符 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"onEnter"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"onEnter"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击回调只会触发一次 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">"&#123; mousedown: doThis, mouseup: doThat &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件上监听自定义事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis(123, $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件中的原生事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">"onClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-bin"><a href="#v-bin" class="headerlink" title="v-bin"></a>v-bin</h2><ul>
<li><p>缩写: <code>:</code></p>
</li>
<li><p>预期: any (with argument) | Object (without argument)</p>
</li>
<li><p>参数:</p>
<ul>
<li><code>.prop</code> 作为一个 DOM property 绑定而不是作为 attribute 绑定</li>
<li><code>.camel</code> 将 kebab-case 特性名转换为 camelCase.</li>
<li><code>.sync</code> 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器</li>
</ul>
</li>
<li><p>用法:<br>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p>
<p>在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。</p>
<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>
<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象</p>
</li>
<li><p>示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imageSrc"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态特性名 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:</span>[<span class="attr">key</span>]=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"'/path/to/images/' + fileName"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">"someThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-bind</span>=<span class="string">"$props"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul>
<li>预期: 随表单控件类型不同而不同</li>
<li>限制:<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>components</li>
</ul>
</li>
<li>修饰符:<ul>
<li><code>.lazy</code> 取代 input 监听 change 事件</li>
<li><code>.number</code> 输入字符串转为有效数字</li>
<li><code>.trim</code> 输入首尾空格过滤</li>
</ul>
</li>
<li>用法:<br>在表单控件或者组件上创建双向绑定</li>
</ul>
<h2 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h2><ul>
<li><p>缩写: <code>#</code></p>
</li>
<li><p>预期:<br>可放置在函数参数位置的 JavaScript 表达式. 可选, 即只需要在为插槽传入 prop 的时候使用</p>
</li>
<li><p>参数:<br>插槽名(默认是<code>default</code>)</p>
</li>
<li><p>限用于:</p>
<ul>
<li><code>&lt;template&gt;</code></li>
<li>组件</li>
</ul>
</li>
<li><p>用法:<br>提供具名插槽或</p>
</li>
<li><p>示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 具名插槽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    Header content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  Default slot content</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    Footer content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 接收 prop 的具名插槽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">infinite-scroll</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:item</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      &#123;&#123; slotProps.item.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">infinite-scroll</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mouse-position</span> <span class="attr">v-slot</span>=<span class="string">"&#123; x, y &#125;"</span>&gt;</span></span><br><span class="line">  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">mouse-position</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><ul>
<li>不需要表达式</li>
<li>用法:<br>跳过这个元素和它的子元素编译过程; 可以用来显示原始 Mustache 标签. 跳过大量没有指令的节点会加快编译</li>
<li>示例:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><ul>
<li>不需要表达式</li>
<li>用法:<br>这个指令保持在元素上直到关联实例结束编译. 和 CSS 规则如 <code>[v-cloak] {display: none}</code> 一起用时, 这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</li>
<li>示例<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
不会显示，直到编译结束。</li>
</ul>
<h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><ul>
<li>不需要表达式</li>
<li>详细:<br>只渲染元素和组件一次. 随后的重新渲染. 元素/组件及其所有的子节点将被视为静态内容并跳过. 这可以用于优化更新性能<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单个元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `v-for` 指令--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例方法生命周期</title>
    <url>/2020/02/26/vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="vm-mount-elementOrSeletor"><a href="#vm-mount-elementOrSeletor" class="headerlink" title="vm.$mount([elementOrSeletor])"></a>vm.$mount([elementOrSeletor])</h2><ul>
<li><p>参数:</p>
<ul>
<li>{Element | string} [elementOrSelector]</li>
<li>{boolean} [hydrating]</li>
</ul>
</li>
<li><p>返回值: <code>vm</code> - 实例自身</p>
</li>
<li><p>用法:<br>如果 Vue 实例在实例化时没有收到 el 选项, 则它处于未挂载状态, 没有关联的 DOM 元素.可以使用 <code>vm.$mount()</code> 手动挂载一个未挂载的实例<br>如果没有提供 <code>elementOrSelector</code> 参数, 模板将被渲染为文档之外的元素, 并且你必须使用原生 DOM API 把它插入文档中<br>这个方法返回实例自身, 因而可以链式调用其他实例方法</p>
</li>
<li><p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Hi&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并挂载到 #app (会替换 #app)</span></span><br><span class="line"><span class="keyword">new</span> MyComponent().$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">new</span> MyComponent(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，在文档之外渲染并且随后挂载</span></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> MyComponent().$mount()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).appendChild(component.$el)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h2><ul>
<li>示例<br>迫使 Vue 实例重新渲染, 注意他仅仅影响实例本身和插入插槽的子组件</li>
</ul>
<h2 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick([callback])"></a>vm.$nextTick([callback])</h2><ul>
<li>参数:<ul>
<li>{Function} [callback]</li>
</ul>
</li>
<li>用法:<br>将回调延迟到下次 DOM 更新循环之后执行. 在修改数据之后立即使用它, 然后等待 DOM 更新. 它跟全局方法 <code>Vue.nextTick</code> 一样, 不同的是回调的 <code>this</code> 自动绑定到调用它的实例上</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    example: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 修改数据</span></span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'changed'</span></span><br><span class="line">      <span class="comment">// DOM 现在还没更新</span></span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// DOM 现在更新了</span></span><br><span class="line">        <span class="comment">// this 绑定到当前实例</span></span><br><span class="line">        <span class="keyword">this</span>.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h2><ul>
<li>用法:<br>完全销毁一个实例. 清理他与其他实例的链接. 解绑他的全部指令及事件监听器<br>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例方法事件</title>
    <url>/2020/02/26/vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on(event, callback)"></a>vm.$on(event, callback)</h2><ul>
<li>参数:<ul>
<li>{string | Array<string>} event</li>
<li>{Function} callback</li>
</ul>
</li>
<li>用法:<br>监听当前实例上的自定义事件, 事件可以由 <code>vm.$emit</code> 触发. 回调函数会接受所有传入事件触发函数的额外参数</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(<span class="string">'test'</span>, <span class="string">'Ginger'</span>)</span><br><span class="line"><span class="comment">// =&gt; Ginger</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-once-event-target"><a href="#vm-once-event-target" class="headerlink" title="vm.$once(event, target)"></a>vm.$once(event, target)</h2><ul>
<li>参数:<ul>
<li>{string} event</li>
<li>{Function} callback</li>
</ul>
</li>
<li>用法:<br>监听一个自定义事件, 但是只触发一次, 一旦触发之后, 监听器就会被移除</li>
</ul>
<h2 id="vm-off-event-callback"><a href="#vm-off-event-callback" class="headerlink" title="vm.$off(event, callback)"></a>vm.$off(event, callback)</h2><ul>
<li>参数:<ul>
<li>{string | Array<string>} event</li>
<li>{Function} [callback]</li>
</ul>
</li>
<li>用法<br>移除自定义事件监听器<ul>
<li>如果没有提供参数, 则移除所有事件监听器</li>
<li>如果只提供了事件, 则移除该事件的所有监听器</li>
<li>如果同时提供了事件与回调, 则只移除这个回调的监听器</li>
</ul>
</li>
</ul>
<h2 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit(eventName, […args])"></a>vm.$emit(eventName, […args])</h2><ul>
<li><p>参数:</p>
<ul>
<li>{string} eventName</li>
<li>[…args]<br>触发当前实例上的事件</li>
</ul>
</li>
<li><p>示例:<br>只配合一个事件名使用 <code>$emit</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'welcome-button'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;button v-on:click="$emit('welcome')"&gt;</span></span><br><span class="line"><span class="string">    Click me to be welcomed</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"emit-example-simple"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-button</span> <span class="attr">v-on:welcome</span>=<span class="string">"sayHi"</span>&gt;</span><span class="tag">&lt;/<span class="name">welcome-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#emit-example-simple'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">'Hi!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>配合额外的参数使用 <code>$emit</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'magic-eight-ball'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      possibleAdvice: [<span class="string">'Yes'</span>, <span class="string">'No'</span>, <span class="string">'Maybe'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    giveAdvice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> randomAdviceIndex = <span class="built_in">Math</span>.floor(</span><br><span class="line">        <span class="built_in">Math</span>.random() * <span class="keyword">this</span>.possibleAdvice.length</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'give-advice'</span>, <span class="keyword">this</span>.possibleAdvice[randomAdviceIndex])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;button v-on:click="giveAdvice"&gt;</span></span><br><span class="line"><span class="string">    Click me for advice</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"emit-example-argument"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">magic-eight-ball</span> <span class="attr">v-on:give-advice</span>=<span class="string">"showAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">magic-eight-ball</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#emit-example-argument'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showAdvice: <span class="function"><span class="keyword">function</span>(<span class="params">advice</span>) </span>&#123;</span><br><span class="line">      alert(advice)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例方法数据</title>
    <url>/2020/02/26/vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="vm.$watch(expOrFn, callback, [options])"></a>vm.$watch(expOrFn, callback, [options])</h2><ul>
<li><p>参数</p>
<ul>
<li>{string | Function} expOrFn</li>
<li>{Function | Object} callback</li>
<li>{Object} [options]<ul>
<li>{boolean} deep</li>
<li>{boolean} immediate</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值 {Function} newwatch</p>
</li>
<li><p>用法<br>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化. 回调永汉得到的参数为新值和旧值. 表达式只接受监督的键路径</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键路径</span></span><br><span class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">vm.$watch(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 表达式 `this.a + this.b` 每次得出一个不同的结果时</span></span><br><span class="line">    <span class="comment">// 处理函数都会被调用。</span></span><br><span class="line">    <span class="comment">// 这就像监听一个未被定义的计算属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>vm.$watch</code> 返回一个取消观察函数, 用来停止触发回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unwatch vm.$watch(<span class="string">'a'</span>, cb)</span><br><span class="line"><span class="comment">// 取消观察</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项: deep<br>为了发现对象内部值的变化, 可以在选项参数中指定 <code>deep: true</code> 将立即以表达式的当前值触发回调:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 'a' 的当前值触发回调</span></span><br></pre></td></tr></table></figure>

<p>注意在带有 <code>immediate</code>选项时, 不能再第一次回调时取消侦听给定的 property</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这会导致报错</span></span><br><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(</span><br><span class="line">  <span class="string">'value'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomething()</span><br><span class="line">    unwatch()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果想在会调内部调用一个取消侦听的函数, 应该先检查其函数的可用性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(</span><br><span class="line">  <span class="string">'value'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomething()</span><br><span class="line">    <span class="keyword">if</span> (unwatch) &#123;</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-set-target-propertyName-index-value"><a href="#vm-set-target-propertyName-index-value" class="headerlink" title="vm.$set(target, propertyName/index,value)"></a>vm.$set(target, propertyName/index,value)</h2><ul>
<li>参数:<ul>
<li>{Object | Array} target</li>
<li>{string | number} propertyName/index</li>
<li>{any} value</li>
</ul>
</li>
<li>返回值: 设置的值</li>
<li>用法: 这是全局 Vue.set 的别名</li>
</ul>
<h2 id="vm-delete-target-propertyName-index"><a href="#vm-delete-target-propertyName-index" class="headerlink" title="vm.$delete(target, propertyName/index)"></a>vm.$delete(target, propertyName/index)</h2><ul>
<li>参数:<ul>
<li>{Object | Array} target</li>
<li>{string | number} propertyname/index</li>
</ul>
</li>
<li>用法: 这是全局 Vue.delete 的别名</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例属性</title>
    <url>/2020/02/25/vue%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h2><ul>
<li>类型: Object</li>
<li>详细:<br>Vue 实例观察的数据对象. Vue 实例代理了对其 data 对象属性的访问</li>
</ul>
<h2 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h2><ul>
<li>类型: Object</li>
<li>详细:<br>当前组件接受到的 props 对象. Vue 实例代理了对其 props 对象属性的访问</li>
</ul>
<h2 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h2><ul>
<li>类型: Elemnt</li>
<li>只读</li>
<li>详细:<br>Vue 实例使用的根 DOM 元素</li>
</ul>
<h2 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h2><ul>
<li>类型: Object</li>
<li>只读</li>
<li>详细:<br>用于当前 Vue 实例的初始化选项. 需要在选项中包含自定义属性时会有用处<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  customOption: <span class="string">'foo'</span>,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption) <span class="comment">// =&gt; foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h2><ul>
<li>类型: Vue instance</li>
<li>只读</li>
<li>详细:<br>父实例</li>
</ul>
<h2 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h2><ul>
<li>类型: Vue instance</li>
<li>只读</li>
<li>详细:<br>当前组件树的根 Vue 实例. 如果当前实例没有父实例, 此实例将会是其自己.</li>
</ul>
<h2 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h2><ul>
<li>类型: Array<Vue instance></li>
<li>只读</li>
<li>详细:<br>当前实例的直接子组件. 不保证顺序, 也不是响应式的</li>
</ul>
<h2 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h2><ul>
<li><p>类型: { [name: string]: ?Array<VNode>}</p>
</li>
<li><p>只读</p>
</li>
<li><p>详细:<br>用来访问被插槽分发的内容. 每个具名插槽有其相应的属性.</p>
</li>
<li><p>示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>About Me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Here's some page content, which will be included in vm.$slots.default,</span><br><span class="line">    because it's not inside a named slot.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Copyright 2016 Evan You<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    If I have some content down here, it will also be included in</span><br><span class="line">    vm.$slots.default.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> header = <span class="keyword">this</span>.$slots.header</span><br><span class="line">    <span class="keyword">var</span>  body = <span class="keyword">this</span>.$slots.default</span><br><span class="line">    <span class="keyword">var</span> footer = <span class="keyword">this</span>.$slots.footer</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">      createElement(<span class="string">'header'</span>, hdaer)</span><br><span class="line">      createElement(<span class="string">'main'</span>, body)</span><br><span class="line">      createElement(<span class="string">'footer'</span>, footer)</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h2><ul>
<li><p>类型: { [name: string]: props =&gt; Array<VNode> | undefined }</p>
</li>
<li><p>只读</p>
</li>
<li><p>详细:<br>用来访问作用域插槽. 对于包括默认 slot 在内的每一个插槽. 该对象都包含一个返回相应 VNode 的函数</p>
</li>
<li><p>注意:<br>作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 undefined。</p>
<p>所有的 <code>$slots</code> 现在都会作为函数暴露在 <code>$scopedSlots</code> 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 <code>$scopedSlots</code> 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。</p>
</li>
</ul>
<h2 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h2><ul>
<li>类型: Object</li>
<li>只读</li>
<li>详细:<br>一个对象, 持有注册过 <code>ref</code> 特性的所有 DOM 元素和组件实例</li>
</ul>
<h2 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h2><ul>
<li>类型: boolean</li>
<li>只读</li>
<li>详细:<br>当前 Vue 实例是否运行于服务器</li>
</ul>
<h2 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a>vm.$attrs</h2><ul>
<li>类型: { [key: string]: string}</li>
<li>只读</li>
<li>详细:<br>包含了父作用域中不作为 prop 被识别的特性绑定(<code>class</code>和<code>style</code>除外). 当一个组件没有声明任何 prop 时, 这里会包含所有父作用域的绑定, 并且可以通过 <code>v-bind=&quot;$attrs</code> 传入内部组件</li>
</ul>
<h2 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h2><ul>
<li>类型: { [key: string]: Function | Array<Function> }</li>
<li>只读</li>
<li>详细:<br>包含了父作用域中<code>v-on</code>事件监听器, 他可以通过<code>v-on=$listeners</code>传入内部组件</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue选项其他</title>
    <url>/2020/02/24/vue%E9%80%89%E9%A1%B9%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><ul>
<li>类型: <code>string</code></li>
<li>限制: 只有作为组件选项时起作用</li>
<li>详细:<br>允许组件模板递归的调用自身, 组件在全局用 <code>Vue.component()</code> 注册时, 全局 ID 自动作为组件的 name<br>指定 <code>name</code> 选项的另一个好处是便于调试, 有名字的组件有更友好的警告信息</li>
</ul>
<h2 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h2><ul>
<li><p>类型: <code>Array&lt;string&gt;</code></p>
</li>
<li><p>默认值: <code>[&quot;,]</code></p>
</li>
<li><p>限制: 这个选项只在完整构建版本中的浏览器内编译时可用</p>
</li>
<li><p>详细:<br>改变纯文本插入分隔符</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  delimiters: <span class="string">`['<span class="subst">$&#123;<span class="string">''</span>&#125;</span>']`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分隔符变成了 ES6 模板字符串的风格</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h2><ul>
<li>类型: <code>boolean</code></li>
<li>详细:<br>使组件无状态(没有<code>data</code>)和无示例(没有<code>this</code>上下文). 他们用一个简单的 <code>render</code> 函数返回虚拟节点使他们渲染的代价更小</li>
</ul>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><ul>
<li>类型: <code>{ prop?: string, event?: string}</code></li>
<li>详细:<br>允许一个自定义组件在使用<code>v-model</code>时定制 prop 和 event. 默认情况下, 一个组件上的<code>v-model</code>会把<code>value</code>用作 prop 且把<code>input</code>用作 event, 但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来打到不同的目的</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// this allows using the `value` prop for a different purpose</span></span><br><span class="line">    value: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">// use `checked` as the prop which take the place of `value`</span></span><br><span class="line">    checked: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
上述代码相当于:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">:checked</span>=<span class="string">"foo"</span> @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span> <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h2><ul>
<li>类型: <code>boolean</code></li>
<li>默认值: <code>true</code></li>
<li>详细:<br>默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。</li>
</ul>
<h2 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h2><ul>
<li>类型: <code>boolran</code></li>
<li>默认值: <code>false</code></li>
<li>限制: 这个选项只有在完成构建版本中的浏览器内编译时可用</li>
<li>详细:<br>当设为 <code>true</code> 时, 将会保留且渲染模板中的 HTML 注释</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue选项组合</title>
    <url>/2020/02/23/vue%E9%80%89%E9%A1%B9%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h2><ul>
<li>类型: <code>Vue instance</code></li>
<li>详细:<br>指定已创建的实例之父实例, 在两者之间建立父子关系. 子实例可以用 <code>this.$parent</code> 访问父实例. 子实例被推入父实例的 <code>$children</code> 数组中</li>
</ul>
<h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><ul>
<li><p>类型: <code>Array&lt;Object&gt;</code></p>
</li>
<li><p>详细:<br><code>mixins</code> 选项接受一个混入对象的数组, 这些混入对象可以像正常的实例对象一样包含实例选项. 这些选项将会被合并到最终的选项中, 使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑. 也就是说, 如果你的混入包含一个 created 钩子, 而创建组件本身也有一个, name 两个函数都会被调用<br>Mixin 钩子按照传入的顺序依次调用, 并在调用组件自身的钩子之前被调用</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><ul>
<li><p>类型: <code>Object | Function</code></p>
</li>
<li><p>详细:<br>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数), 而无需使用 <code>Vue.extend</code><br>这主要是为了便于扩展单文件组件<br>这和 <code>mixin</code> 类型</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComA = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有调用 `Vue.extend` 时候继承 ComA</span></span><br><span class="line"><span class="keyword">var</span> ComB = &#123;</span><br><span class="line">  extends: ComA</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h2><ul>
<li><p>类型:</p>
<ul>
<li>provide: <code>Object | () =&gt; Object</code></li>
<li>inject: <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object}</code></li>
</ul>
</li>
<li><p>详细:<br>这对选项需要一起使用, 以允许一个祖先组件向其所有子孙后台注入一个依赖, 不论组件层次有多深, 并在起上下游关系成立的时间里始终生效.<br><code>provide</code> 选项应该是一个对象或返回一个对象的函数, 该对象包含可注入其子孙的属性. 在该对象中你可以使用 ES2015 Symbols, 但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。<br><code>inject</code> 选项应该是:</p>
<ul>
<li>一个字符串数组, 或</li>
<li>一个对象, 对象的 key 是本地的绑定名, value 是:<ul>
<li>在可用的注入内容中搜索用的 key,或</li>
<li>一个对象, 该对象的:<ul>
<li><code>from</code> 属性实在可用的注入内容中搜索用的 key</li>
<li><code>default</code> 属性是降级情况下使用的 value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件提供的 foo</span></span><br><span class="line"><span class="keyword">var</span> Provider = &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件注入 foo</span></span><br><span class="line"><span class="keyword">var</span> Chil = &#123;</span><br><span class="line">  inject: [<span class="string">'foo'</span>],</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) <span class="comment">// =&gt; bar</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 Symbols、函数、provide 和对象 inject</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Provider = &#123;</span><br><span class="line">  provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      [s]: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: &#123; s &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个注入的值作为一个属性的默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: [<span class="string">'foo'</span>],</span><br><span class="line">  props: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      <span class="keyword">default</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个注入的值作为数据入口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.2.1</span></span><br><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: [<span class="string">'foo'</span>],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      bar: <span class="keyword">this</span>.foo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.5</span></span><br><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123; <span class="attr">default</span>: <span class="string">'foo'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要从一个不同名字的属性注入, 则使用 <code>from</code> 来表示其源属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'bar'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 prop 的默认值类型, 你需要对非原始值使用一个工厂方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'bar'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue选项生命周期钩子</title>
    <url>/2020/02/22/vue%E9%80%89%E9%A1%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p>
</blockquote>
<h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><ul>
<li>类型 Function</li>
<li>详细<br>在实例初始化之后, 数据观测(data observer) 和 event/watcher 事件配置之前被调用</li>
</ul>
<h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><ul>
<li>类型 Function</li>
<li>详细<br>在实例创建完成后被立即调用吗, 在这一步, 实例已完成以下配置: 数据观测(data observer), 属性和方法的运算, watch/event 事件回调, 然而, 挂载阶段还没开始 <code>$el</code>属性尚不可用</li>
</ul>
<h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><ul>
<li>类型 Function</li>
<li>详细<br>在挂载开始之前被调用: 相关 <code>render</code> 函数首次被调用<br><strong>该钩子在服务器端渲染期间不被调用</strong></li>
</ul>
<h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><ul>
<li>类型 Function</li>
<li>详细:<br>实例被挂载后调用, 这时 <code>el</code> 被创建的 <code>vm.$el</code> 替换了, 如果根实例挂载到一个文档内的元素上, 当 <code>mounted</code> 被调用时, <code>vm.$el</code> 也在文档内的元素上, 当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内<br>mounted 不会保证所有的子组件也都一起被挂载, 如果你希望等到整个试图都苏安然完毕, 可以在 mounted 内部使用 <code>vm.$nextTick</code><br><strong>该钩子在服务器端渲染期间不被调用</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendred</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><ul>
<li>类型: Function</li>
<li>详细<br>数据更新时调用, 发生在虚拟 DOM 打补丁之前, 这里适合在更新之前访问现有的 DOM. 比如手动移除已添加的事件监听器</li>
</ul>
<h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><ul>
<li><p>类型 Function</p>
</li>
<li><p>详细<br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁, 在这之后会调用该钩子<br>当这个钩子被调用时. 组件 DOM 已经更新. 所以现在可以执行依赖 DOM 的操作. 然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br>updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Code that will run only after the</span></span><br><span class="line">  <span class="comment">// entire view has been re-rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><ul>
<li>类型 Function</li>
<li>详细<br>被 keep-alive 缓存的组件激活时调用<br>该钩子在服务器端渲染期间不被调用</li>
</ul>
<h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><ul>
<li>类型 Function</li>
<li>详细<br>被 keep-alive 缓存的组件停用时调用</li>
</ul>
<h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><ul>
<li>类型 Function</li>
<li>详细<br>实例销毁之前调用, 在这一步, 实例仍然完全可用</li>
</ul>
<h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><ul>
<li>类型 Function</li>
<li>详细<br>实例销毁后调用, 该钩子被调用后, 对应 Vue 实例的所有指令都被解绑, 所有事件监听器被移除, 所有子实例也都被销毁</li>
</ul>
<h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><ul>
<li><p>类型 (err: Erroe, vm: Component, info: string) =&gt; ?boolean</p>
</li>
<li><p>详细<br>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</li>
<li><p>错误传播规则</p>
<ul>
<li><p>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</p>
</li>
<li><p>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</p>
</li>
<li><p>如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。</p>
</li>
<li><p>一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue选项DOM</title>
    <url>/2020/02/21/vue%E9%80%89%E9%A1%B9DOM/</url>
    <content><![CDATA[<h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><ul>
<li>类型 string | Element</li>
<li>限制: 只在用 <code>new</code> 创建实例时生效</li>
<li>详细<br>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标, 可以是 CSS 选择器, 也可以是一个 HTMLElement 实例<br>在实例挂载之后, 元素可以用 <code>vm.$el</code> 访问<br>如果在实例化时存在这个选项, 实例将立刻进入编译过程, 否则, 需要显式调用 <code>vm.$mount()</code> 手动开启编译</li>
</ul>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><ul>
<li>类型 string</li>
<li>详细<br>一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。<br>如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <script type="x-template"> 包含模板。</li>
</ul>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><ul>
<li>类型 (createElement: () => VNode) => VNode</li>
<li>详细<br>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。<br>如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。</li>
</ul>
<h2 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h2><ul>
<li><p>类型 (createElement: () => VNode, error: Error) => VNode</p>
</li>
<li><p>详细:<br><strong>只在开发者环境下工作。</strong><br>当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError(h, err) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'pre'</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125; &#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue选项数据</title>
    <url>/2020/02/20/vue%E9%80%89%E9%A1%B9%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><ul>
<li><p>类型 Object | Function</p>
</li>
<li><p>限制 组件的定义只接受 Function</p>
</li>
<li><p>详细<br>Vue 实例的数据对象, Vue 将会递归将 data 的属性转换为 getter/setter, 从而让 data 的属性能够相应数据变化. 对象必须是纯粹的对象,浏览器 API 创建的原生对象, 原型上的属性会被忽略<br>一旦观察过, 就无法在跟数据对象上添加响应式属性, 因此推荐在创建实例之前, 就声明所有的根级响应式属性<br>实例创建之后可以通过 vm.$data 访问原始数据对象. Vue 实例也代理了 data 对象上的所有属性, 因此访问 vm.a 等价于访问 <code>vm.$data.a</code><br>以 <code>_</code> 或 <code>$</code> 开头的属性不会被 Vue 实例代理, 因为他们可能和 Vue 内置的属性、API 方法冲突; 可以用 <code>vm.\$data._property</code> 的方式访问这些属性<br>当一个组件被定义, data 必须声明为返回一个初始数据对象的函数, 因为组件可能被用来创建多个实例. 如果 data 仍然是一个纯粹的对象, 则所有的实例将 共享引用同一个数据对象. 通过提供 data 函数, 每次创建一个新实例后, 我们能调用 data 函数, 从而返回初始数据的一个全新副本数据对象<br>如果需要, 可以通过将 <code>vm.$data</code> 传入 <code>JSOM.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.a <span class="comment">// =&gt; 1</span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.extend() 中 data 必须是函数</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果为 data 使用了箭头函数, 则 <code>this</code> 不会指向这个组件的实例, 不过仍然可以将其实例作为函数的第一个参数来访问 data: vm =&gt; ({ a: vm.myProp })</p>
</blockquote>
</li>
</ul>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li><p>类型 Array<string> | Object</p>
</li>
<li><p>详细<br>props 可以是数组或对象, 用于接收来自父组件的数据, props 可以是简单的数组, 或者使用对象作为替代, 对象允许配置高级选项<br>基于对象语法可以使用以下选项:</p>
<ul>
<li><code>type</code>: 可以是下列原生构造函数中的一种: String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组</li>
<li><code>default</code>: any 为该 props 指定一个默认值 对象或数组的默认值必须从一个工厂函数返回</li>
<li><code>required</code>: Boolean 定义该 prop 是否是必填项, 在非生产环境中, 如果这个值为 truthy 且该 prop 没有被传入, 则会抛出一个控制台警告</li>
<li><code>validator</code>: Function 自定义验证函数会将该 prop 的值作为唯一的参数带入 非生产环境中 该函数返回一个 falsy 的值 会抛出一个控制塔警告</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单语法</span></span><br><span class="line">Vue.component(<span class="string">'props-demo-array'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'size'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象语法</span></span><br><span class="line">Vue.component(<span class="string">'props-demo-object'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 类型检测</span></span><br><span class="line">    height: <span class="built_in">Number</span></span><br><span class="line">    <span class="comment">// 类型检测 + 其他验证</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h2><ul>
<li><p>类型 { [key: string]: any}</p>
</li>
<li><p>限制 只用于 <code>new</code> 创建的实例中</p>
</li>
<li><p>详细: 创建实例时传递 porps</p>
</li>
<li><p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Comp = Vue.extend(&#123;</span><br><span class="line">  props: [<span class="string">'msg'</span>],</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Comp(&#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="compouted"><a href="#compouted" class="headerlink" title="compouted"></a>compouted</h2><ul>
<li><p>类型 { [key:string]: Function | {get: Function, set: Function}}</p>
</li>
<li><p>详细:<br>计算属性将被混入到 Vue 实例中, 所有 getter 和 setter 的 this 上下文自动的绑定为 Vue 实例<br>如果使用了箭头函数, 则 this 不会指向这个组件的实例, 不过仍然可以将其实例作为函数的第一个参数来访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  aDouble: <span class="function"><span class="params">vm</span> =&gt;</span> vm.a * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性的结果会被缓存, 除非依赖的响应式属性变化才会重新计算</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 仅读取</span></span><br><span class="line">    aDouble: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取和设置</span></span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function(v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.aPlus   <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aPlus = <span class="number">3</span></span><br><span class="line">vm.a       <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aDouble <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><ul>
<li><p>类型 { [key: string]: Function}</p>
</li>
<li><p>详细<br>methods 将被混入到 Vue 实例中, 可以直接通过 vm 实例访问这些方法, 或在指令表达式中使用, 方法中的 this 自动绑定为 Vue 实例</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    plus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.plus()</span><br><span class="line">vm.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ul>
<li>类型 { [key:string]: string | Function | Object | Array}</li>
<li>详细<br>一个对象, 键是需要观察的表达式, 值是对应的回调函数. 值也可以是方法名, 或者包含选项的对象, Vue 实例将会在实例化时调用 <code>$watch()</code>, 遍历 watch 对象的没一个属性</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    d: <span class="number">4</span>,</span><br><span class="line">    e: &#123;</span><br><span class="line">      f: &#123;</span><br><span class="line">        g: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    b: <span class="string">'someMethod'</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    c: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;&#125;,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    d: &#123;</span><br><span class="line">      handler: <span class="string">'someMethod'</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    e: [</span><br><span class="line">      <span class="string">'handle1'</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params">val, oldVal</span>) </span>&#123;&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span> <span class="title">handle3</span>(<span class="params">val, oldVal</span>) </span>&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// watch vm.e.f's value: &#123;g:5&#125;</span></span><br><span class="line">    <span class="string">'e.f'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="number">2</span> <span class="comment">// =&gt; new: 2, old: 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue全局API</title>
    <url>/2020/02/19/vue%E5%85%A8%E5%B1%80API/</url>
    <content><![CDATA[<h2 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend(options)"></a>Vue.extend(options)</h2><ul>
<li>参数<ul>
<li>{option} options</li>
</ul>
</li>
<li>用法<br>使用基础 Vue 构造器, 创建一个’子类’. 参数是一个包含组件选项的对象<br><code>data</code> 选项是特例, 需要注意, 在 Vue.extend() 中他必须是函数<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mount-point"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Profile = Vue.exten&#123;d(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125;  &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'walter'</span>,</span><br><span class="line">      lastName: <span class="string">'white'</span>,</span><br><span class="line">      alias: <span class="string">'Heisenberg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建 Proflie 实例, 并挂载到一个元素上</span></span><br><span class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick([callback, context])"></a>Vue.nextTick([callback, context])</h2><ul>
<li><p>参数:</p>
<ul>
<li>{Function} [callback]</li>
<li>{object} [context]</li>
</ul>
</li>
<li><p>用法:<br>在下次 DOM 更新循环结束之后执行延迟回调. 在修改数据之后立即使用这个方法, 获取更新后的 DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// DOM 还没更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用</span></span><br><span class="line">Vue.nextTick().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-set-target-propertyName-index-value"><a href="#Vue-set-target-propertyName-index-value" class="headerlink" title="Vue.set(target, propertyName/index, value)"></a>Vue.set(target, propertyName/index, value)</h2><ul>
<li>参数:<ul>
<li>{object | Array} target</li>
<li>{string | Number} propertyName/index</li>
<li>{any} value</li>
</ul>
</li>
<li>返回值: 设置的值</li>
<li>用法:<br>向响应式对象添加一个属性, 并确保这个新属性同样是响应式的, 且触发试图更新, 他必须用于向响应式对象上添加新属性, 因为 Vue 无法探测普通的新增属性<br><code>this.myObject.newProperty = &#39;Hi&#39;</code></li>
</ul>
<h2 id="Vue-delete-target-propertyName-index"><a href="#Vue-delete-target-propertyName-index" class="headerlink" title="Vue.delete(target, propertyName/index)"></a>Vue.delete(target, propertyName/index)</h2><ul>
<li>参数:<ul>
<li>{Object | Array} target</li>
<li>{string | Number} propertyName/index</li>
</ul>
</li>
<li>用法:<br>删除对象的属性, 如果对象是响应式的, 确保删除能触发更新试图, 这个方法主要用于避开 Vue 不能检测到属性被删除的限制, 但是你应该很少会使用它</li>
</ul>
<h2 id="Vue-directive-id-definition"><a href="#Vue-directive-id-definition" class="headerlink" title="Vue.directive(id, [definition])"></a>Vue.directive(id, [definition])</h2><ul>
<li><p>参数:</p>
<ul>
<li>{string} id</li>
<li>{Function | Object} [definition]</li>
</ul>
</li>
<li><p>用法:<br>注册或获取全局指令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  componentUpdated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  unbind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 (指令函数)</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里将会被 bind 和 update 调用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 返回已注册的指令</span></span><br><span class="line"><span class="keyword">var</span> myDirective = Vue.directive(<span class="string">'my-directive'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-filter-id-definition"><a href="#Vue-filter-id-definition" class="headerlink" title="Vue.filter(id, [definition])"></a>Vue.filter(id, [definition])</h2><ul>
<li><p>参数:</p>
<ul>
<li>{string} id</li>
<li>{Function} [definition]</li>
</ul>
</li>
<li><p>用法:<br>注册或获取全局过滤器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'my-filter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回处理后的值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 返回已注册过的过滤器</span></span><br><span class="line"><span class="keyword">var</span> myFilter = Vue.filter(<span class="string">'my-filter'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-component-id-definition"><a href="#Vue-component-id-definition" class="headerlink" title="Vue.component(id, [definition])"></a>Vue.component(id, [definition])</h2><ul>
<li><p>参数</p>
<ul>
<li>{string} id</li>
<li>{Function | Object} [definition]</li>
</ul>
</li>
<li><p>用法:<br>注册或获取全局组件, 注册还会自动使用给定的<code>id</code>设置组件的名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册组件 传入一个扩展过的构造器</span></span><br><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'my-component'</span>,</span><br><span class="line">  Vue.extend(&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件 传入一个选项对象 (自动调用Vue.extend)</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use(plugin)"></a>Vue.use(plugin)</h2><ul>
<li><p>参数:</p>
<ul>
<li>{Object | Function} plugin</li>
</ul>
</li>
<li><p>用法:<br>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p>
<p>该方法需要在调用 new Vue() 之前被调用。</p>
<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
</li>
</ul>
<h2 id="Vue-mixin-mixin"><a href="#Vue-mixin-mixin" class="headerlink" title="Vue.mixin(mixin)"></a>Vue.mixin(mixin)</h2><ul>
<li>参数:<ul>
<li>{Object} mixin</li>
</ul>
</li>
<li>用法<br>全局注册一个混入, 影响注册之后所有创建的每个 Vue 实例, 插件作者可以使用混入, 想组件注入自定义的行为. 不推荐在应用代码中使用</li>
</ul>
<h2 id="Vue-compile-template"><a href="#Vue-compile-template" class="headerlink" title="Vue.compile(template)"></a>Vue.compile(template)</h2><ul>
<li>参数<ul>
<li>{string} template</li>
</ul>
</li>
<li>用法<br>将一个模板字符串编译成 render 函数, 只在完整版时可用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span>)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render: res.render,</span><br><span class="line">  staticRenderFns: res.staticRenderFns</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-observable-object"><a href="#Vue-observable-object" class="headerlink" title="Vue.observable(object)"></a>Vue.observable(object)</h2><ul>
<li><p>参数:</p>
<ul>
<li>{Object} object</li>
</ul>
</li>
<li><p>用法:<br>让一个对象可响应, Vue 内部会用它来处理<code>data</code>函数返回的对象<br>返回的对象可以直接用于渲染函数和计算属性内, 并且会在发生改变时触发响应的更新, 也可以作为最小化的跨组价状态存储器, 用于简单的场景:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = Vue.observable(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = &#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(</span><br><span class="line">      <span class="string">'button'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            state.count++</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">`count is : <span class="subst">$&#123;state.count&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h2><ul>
<li><p>细节: 提供字符串形式的 Vue 安装版本号</p>
</li>
<li><p>用法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vresion = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v2.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v1.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Unsupported versions of Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue全局配置</title>
    <url>/2020/02/18/vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p><code>Vue.config</code> 是一个对象, 包含 Vue 的全局配置.</p>
<h3 id="slient"><a href="#slient" class="headerlink" title="slient"></a>slient</h3><ul>
<li>类型: boolean</li>
<li>默认: false</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消 Vue 所有的日志与警告</span></span><br><span class="line">Vue.config.slient = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><ul>
<li>类型: { [key: string]: Function }</li>
<li>默认: {}</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义合并策略的选项。</span></span><br><span class="line">Vue.config.optionMergeStrategies._my_option = <span class="function"><span class="keyword">function</span>(<span class="params">parent, child, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> child + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profile = Vue.extend(&#123;</span><br><span class="line">  _my_option: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Profile.options._my_option = 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p>
</blockquote>
<h3 id="errorHandle"><a href="#errorHandle" class="headerlink" title="errorHandle"></a>errorHandle</h3><ul>
<li>类型: Function</li>
<li>默认值: undefined</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandle = <span class="function"><span class="keyword">function</span>(<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// info 是 Vue 特定的错误信息, 比如错误所在的生命周期钩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>
</blockquote>
<h3 id="warnHandle"><a href="#warnHandle" class="headerlink" title="warnHandle"></a>warnHandle</h3><ul>
<li>类型: Function</li>
<li>默认值: undefined</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.warnHandle = <span class="function"><span class="keyword">function</span>(<span class="params">msg, vm, trace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// trace 是组件的继承关系追踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3><ul>
<li>类型 Array&lt;string | RegExp&gt;</li>
<li>默认值: {}</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.ignoredElements = [</span><br><span class="line">  <span class="string">'my-custom-web-component'</span>,</span><br><span class="line">  <span class="string">'another-web-component'</span>,</span><br><span class="line">  <span class="comment">// 用一个 `RegExp` 忽略所有“ion-”开头的元素</span></span><br><span class="line">  <span class="comment">// 仅在 2.5+ 支持</span></span><br><span class="line">  /^ion-<span class="regexp">/</span></span><br><span class="line"><span class="regexp">]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。</p>
</blockquote>
<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3><ul>
<li>类型: { [key: string]: number | Array<number> }</li>
<li>默认值: {}</li>
<li>用法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 v-on 自定义键位别名。</span></span><br><span class="line">Vue.config.keyCodes = &#123;</span><br><span class="line">  v: <span class="number">86</span>,</span><br><span class="line">  f1: <span class="number">112</span>,</span><br><span class="line">  <span class="comment">// camelCase 不可用</span></span><br><span class="line">  mediaPlayPause: <span class="number">179</span>,</span><br><span class="line">  <span class="comment">// 取而代之的事 kebab-case 且用双引号括起来</span></span><br><span class="line">  <span class="string">'media-play-pause'</span>: <span class="number">179</span>,</span><br><span class="line">  up: [<span class="number">38</span>, <span class="number">87</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">media-play-pause</span>=<span class="string">"method"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h3><ul>
<li>类型: boolean</li>
<li>默认值: true</li>
<li>用法:<br>设置为 false 以阻止 vue 在启动时生成生产提示</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue过滤器</title>
    <url>/2020/02/16/vue%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Vue.js 允许你自定义过滤器, 可被用于一些常见的文本格式化, 过滤器可以用在两个地方, <strong>双括号插值</strong>和<code>v-bind</code>表达式.</p>
<blockquote>
<p>过滤器应该被添加在 JavaScript 表达式的尾部, 由”管道”符号表示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitlize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 v-bind 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在一个组件的选项中定义本地过滤器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize(value) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).totoUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).totoUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。<br>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数</p>
</blockquote>
<p>过滤器可以串联：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插件</title>
    <url>/2020/02/15/vue%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件通常用来为 Vue 添加全局功能, 插件的功能范围没有严格的限制</p>
<ul>
<li>1.添加全局方法或者属性</li>
<li>2.添加全局资源: 指令/过滤器/过渡</li>
<li>3.通过全局混入来添加一些组件的选项: <code>vue-router</code></li>
<li>4.添加 Vue 实例方法, 通过他们添加到 <code>Vue.prototype</code> 上实现</li>
<li>5.一个库, 提供自己的 api, 同时提供上面提到的一个或多个功能</li>
</ul>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 <code>Vue.use()</code> 使用插件, 他需要在你调用 <code>new Vue()</code> 启动应用之前完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 'MyPlugin.install(Vue)</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以传入一个可选的选项对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(MyPlugin, &#123; <span class="attr">someOption</span>: trur &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p>
</blockquote>
<p>Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时</span></span><br><span class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忘了调用此方法</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><p>Vue.js 的插件应该暴露一个<code>install</code>方法, 这个方法的第一个参数是<code>Vue</code>构造器, 第二个参数是一个可选的选项对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加全局方法或属性</span></span><br><span class="line">  Vue.MyGlobalMethod = funtion() &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">    bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span>(<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue渲染函数-JSX</title>
    <url>/2020/02/14/vue%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0-JSX/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Vue 推荐在绝大多数情况下使用模板来创建 HTML, 然而在一些场景中，真的需要 JavaScript 的完全编程的能力。这时可以用渲染函数，它比模板更接近编译器。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><p>生成一些带锚点的标题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"hello-world"</span> <span class="attr">href</span>=<span class="string">"#hello-world"</span>&gt;</span></span><br><span class="line">    Hello world!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件接口</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">anchored-heading</span> <span class="attr">:level</span>=<span class="string">"1"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">anchored-heading</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>level</code> prop 动态生成标题的组件时</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"anchored-heading-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"level === 1"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">  &lt;h2 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 2"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">  &lt;h3 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 3"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">  &lt;h4 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 4"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">  &lt;h5 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 5"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">  &lt;h6 v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"level === 6"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#anchored-heading-template'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>render</code> 函数重写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</span><br><span class="line">  render(createElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">'h'</span> + <span class="keyword">this</span>.level, <span class="comment">// 标签名</span></span><br><span class="line">      <span class="keyword">this</span>.$slots.default <span class="comment">// 子节点数组</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="节点、树以及虚拟-DOM"><a href="#节点、树以及虚拟-DOM" class="headerlink" title="节点、树以及虚拟 DOM"></a>节点、树以及虚拟 DOM</h2><p>当浏览器读到这些代码时，它会建立一个“DOM 节点”树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  Some text content</span><br><span class="line">  <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Add tagline --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../image/dom-tree.png" alt="&#39;DOM&#39;"></p>
<p>每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。</p>
<h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="keyword">this</span>.blogTitle)</span><br></pre></td></tr></table></figure>

<p>createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>
<h3 id="createElement-参数"><a href="#createElement-参数" class="headerlink" title="createElement 参数"></a>createElement 参数</h3><p>如何在 createElement 函数中使用模板中的那些功能。这里是 createElement 接受的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createElement(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、组件选项对象，或者</span></span><br><span class="line">  <span class="comment">// resolve 了上述任何一种的一个 async 函数。必填项。</span></span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">  <span class="comment">// 一个与模板中属性对应的数据对象。可选。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// (详情见下一节)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">  <span class="comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，</span></span><br><span class="line">  <span class="comment">// 也可以使用字符串来生成“文本虚拟节点”。可选。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">'先写一些文字'</span>,</span><br><span class="line">    createElement(<span class="string">'h1'</span>, <span class="string">'一则头条'</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        someProp: <span class="string">'foobar'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="深入数据对象"><a href="#深入数据对象" class="headerlink" title="深入数据对象"></a>深入数据对象</h3><p>如 v-bind:class 和 v-bind:style 在模板语法中会被特别对待一样，它们在 VNode 数据对象中也有对应的顶层字段。该对象也允许你绑定普通的 HTML attribute，也允许绑定如 innerHTML 这样的 DOM 属性 (这会覆盖 v-html 指令)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 与 `v-bind:class` 的 API 相同，</span></span><br><span class="line">  <span class="comment">// 接受一个字符串、对象或字符串和对象组成的数组</span></span><br><span class="line">  <span class="string">'class'</span>: &#123;</span><br><span class="line">    foo: <span class="literal">true</span>,</span><br><span class="line">    bar: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 与 `v-bind:style` 的 API 相同，</span></span><br><span class="line">  <span class="comment">// 接受一个字符串、对象，或对象组成的数组</span></span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'14px'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 普通的 HTML attribute</span></span><br><span class="line">  attrs: &#123;</span><br><span class="line">    id: <span class="string">'foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 组件 prop</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// DOM 属性</span></span><br><span class="line">  domProps: &#123;</span><br><span class="line">    innerHTML: <span class="string">'baz'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 事件监听器在 `on` 属性内，</span></span><br><span class="line">  <span class="comment">// 但不再支持如 `v-on:keyup.enter` 这样的修饰器。</span></span><br><span class="line">  <span class="comment">// 需要在处理函数中手动检查 keyCode。</span></span><br><span class="line">  on: &#123;</span><br><span class="line">    click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用</span></span><br><span class="line">  <span class="comment">// `vm.$emit` 触发的事件。</span></span><br><span class="line">  nativeOn: &#123;</span><br><span class="line">    click: <span class="keyword">this</span>.nativeClickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义指令。注意，你无法对 `binding` 中的 `oldValue`</span></span><br><span class="line">  <span class="comment">// 赋值，因为 Vue 已经自动为你进行了同步。</span></span><br><span class="line">  directives: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'my-custom-directive'</span>,</span><br><span class="line">      value: <span class="string">'2'</span>,</span><br><span class="line">      expression: <span class="string">'1 + 1'</span>,</span><br><span class="line">      arg: <span class="string">'foo'</span>,</span><br><span class="line">      modifiers: &#123;</span><br><span class="line">        bar: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 作用域插槽的格式为</span></span><br><span class="line">  <span class="comment">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">'span'</span>, props.text)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 如果组件是其它组件的子组件，需为插槽指定名称</span></span><br><span class="line">  slot: <span class="string">'name-of-slot'</span>,</span><br><span class="line">  <span class="comment">// 其它特殊顶层属性</span></span><br><span class="line">  key: <span class="string">'myKey'</span>,</span><br><span class="line">  ref: <span class="string">'myRef'</span>,</span><br><span class="line">  <span class="comment">// 如果你在渲染函数中给多个元素都应用了相同的 ref 名，</span></span><br><span class="line">  <span class="comment">// 那么 `$refs.myRef` 会变成一个数组。</span></span><br><span class="line">  refInFor: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getChildrenTextContent = <span class="function"><span class="keyword">function</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node.children ? getChildrenTextContent(node.children) : node.text</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 kebab-case 风格的 ID</span></span><br><span class="line">    <span class="keyword">var</span> headingId = getChildrenTextContent(<span class="keyword">this</span>.$slots.default)</span><br><span class="line">      .toLowerCase()</span><br><span class="line">      .replace(<span class="regexp">/\W+/g</span>, <span class="string">'-'</span>)</span><br><span class="line">      .replace(<span class="regexp">/(^-|-$)/g</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'h'</span> + <span class="keyword">this</span>.level, [</span><br><span class="line">      createElement(</span><br><span class="line">        <span class="string">'a'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          attrs: &#123;</span><br><span class="line">            name: headingId,</span><br><span class="line">            href: <span class="string">'#'</span> + headingId</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.$slots.default</span><br><span class="line">      )</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>VNode 必须唯一 组件树中的所有 VNode 必须是唯一的。</p>
</blockquote>
<h2 id="使用-JavaScript-代替模板功能"><a href="#使用-JavaScript-代替模板功能" class="headerlink" title="使用 JavaScript 代替模板功能"></a>使用 JavaScript 代替模板功能</h2><h3 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a>v-if 和 v-for</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"items.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'items'</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.items.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'ul'</span>, <span class="keyword">this</span>.items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">'li'</span>, item.name)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'p'</span>, <span class="string">'No items found.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'value'</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'input'</span>, &#123;</span><br><span class="line">    domProps: &#123;</span><br><span class="line">      value: self.value</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        self.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件-amp-按键修饰符"><a href="#事件-amp-按键修饰符" class="headerlink" title="事件 &amp; 按键修饰符"></a>事件 &amp; 按键修饰符</h2><p>对于 <code>.passive</code>、<code>.capture</code> 和 <code>.once</code> 这些事件修饰符, Vue 提供了相应的前缀可以用于 on：</p>
<ul>
<li>修饰符<code>.passive</code> -&gt; 前缀 <code>&amp;</code></li>
<li>修饰符<code>.capture</code> -&gt; 前缀 <code>!</code></li>
<li>修饰符<code>.once</code> -&gt; 前缀 <code>~</code></li>
<li>修饰符<code>.capture.once</code> 或 <code>.once.capture</code> -&gt; 前缀 <code>&amp;</code></li>
</ul>
<p>对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：</p>
<ul>
<li>修饰符<code>.stop</code> —等价操作–&gt; <code>event.stopPropagation()</code></li>
<li>修饰符<code>.prevent</code> —等价操作–&gt; <code>event.preventDefault()</code></li>
<li>修饰符<code>.self</code> —等价操作–&gt; <code>if (event.target !== event.currentTarget) return</code></li>
<li>按键<code>.enter</code>, <code>.13</code> —等价操作–&gt; <code>if (event.keyCode !== 13) return</code> (对于别的按键修饰符来说，可将 13 改为另一个按键码)</li>
<li>修饰符<code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code> —等价操作–&gt; <code>if (!event.ctrlKey) return</code> (将 ctrlKey 分别修改为 altKey、shiftKey 或者 metaKey)`</li>
</ul>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  keyup: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发事件的元素不是事件绑定的元素</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 如果按下去的不是 enter 键或者</span></span><br><span class="line">    <span class="comment">// 没有同时按下 shift 键</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止 事件冒泡</span></span><br><span class="line">    event.stopPropagation()</span><br><span class="line">    <span class="comment">// 阻止该元素默认的 keyup 事件</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>可以通过 this.$slots 访问静态插槽的内容，每个插槽都是一个 VNode 数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, <span class="keyword">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过 this.$scopedSlots 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'message'</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot :text="message"&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">    <span class="keyword">this</span>.$scopedSlots.default(&#123;</span><br><span class="line">      text: <span class="keyword">this</span>.message</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据对象中的 scopedSlots 字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">    createElement(<span class="string">'child'</span>, &#123;</span><br><span class="line">      <span class="comment">// 在数据对象中传递 `scopedSlots`</span></span><br><span class="line">      <span class="comment">// 格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">      scopedSlots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> createElement(<span class="string">'span'</span>, props.text)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>有一个 Babel 插件，用于在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">'./AnchoredHeading.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;<span class="regexp">/span&gt; world!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的。从 Vue 的 Babel 插件的 3.4.0 版本开始，我们会在以 ES2015 语法声明的含有 JSX 的任何方法和 getter 中 (不是函数或箭头函数中) 自动注入 const h = this.$createElement，这样你就可以去掉 (h) 参数了。对于更早版本的插件，如果 h 在当前作用域中不可用，应用会抛错。</p>
</blockquote>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// Props 是可选的</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了弥补缺少的实例</span></span><br><span class="line">  <span class="comment">// 提供第二个参数作为上下文</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 2.5.0 及以上版本中，如果你使用了单文件组件，那么基于模板的函数式组件可以这样声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件需要的一切都是通过 context 参数传递，它是一个包括如下字段的对象：</p>
<ul>
<li>props：提供所有 prop 的对象</li>
<li>children: VNode 子节点的数组</li>
<li>slots: 一个函数，返回了包含所有插槽的对象</li>
<li>scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插- 槽。</li>
<li>data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</li>
<li>parent：对父组件的引用</li>
<li>listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。</li>
<li>injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。<blockquote>
<p>在添加 functional: true 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 context 参数，并将 this.$slots.default 更新为 context.children，然后将 this.level 更新为 context.props.level。</p>
</blockquote>
</li>
</ul>
<p>下面是一个 smart-list 组件的例子，它能根据传入 prop 的值来代为渲染更具体的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EmptyList = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> TableList = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> OrderedList = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> UnorderedList = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'smart-list'</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    items: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    isOrdered: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">appropriateListComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> items = context.props.items</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (items.length === <span class="number">0</span>) <span class="keyword">return</span> EmptyList</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> items[<span class="number">0</span>] === <span class="string">'object'</span>) <span class="keyword">return</span> TableList</span><br><span class="line">      <span class="keyword">if</span> (context.props.isOrdered) <span class="keyword">return</span> OrderedList</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> UnorderedList</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      appropriateListComponent(),</span><br><span class="line">      context.data,</span><br><span class="line">      context.children</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="向子元素或子组件传递-attribute-和事件"><a href="#向子元素或子组件传递-attribute-和事件" class="headerlink" title="向子元素或子组件传递 attribute 和事件"></a>向子元素或子组件传递 attribute 和事件</h3><p>在普通组件中，没有被定义为 prop 的 attribute 会自动添加到组件的根元素上，将已有的同名 attribute 进行替换或与其进行智能合并。</p>
<p>然而函数式组件要求你显式定义该行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-functional-button'</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 完全透传任何 attribute、事件监听器、子节点等。</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'button'</span>, context.data, context.children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过向 createElement 传入 context.data 作为第二个参数，我们就把 my-functional-button 上面所有的 attribute 和事件监听器都传递下去了。事实上这是非常透明的，以至于那些事件甚至并不要求 .native 修饰符。</p>
<p>如果你使用基于模板的函数式组件，那么你还需要手动添加 attribute 和监听器。因为我们可以访问到其独立的上下文内容，所以我们可以使用 data.attrs 传递任何 HTML attribute，也可以使用 listeners (即 data.on 的别名) 传递任何事件监听器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">v-bind</span>=<span class="string">"data.attrs"</span> <span class="attr">v-on</span>=<span class="string">"listeners"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="slots-和-children-对比"><a href="#slots-和-children-对比" class="headerlink" title="slots() 和 children 对比"></a>slots() 和 children 对比</h3><p>对于这个组件，children 会给你两个段落标签，而 slots().default 只会传递第二个匿名段落标签，slots().foo 会传递第一个具名段落标签。同时拥有 children 和 slots()，因此你可以选择让组件感知某个插槽机制，还是简单地通过传递 children，移交给其它组件去处理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-functional-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-slot:foo</span>&gt;</span></span><br><span class="line">    first</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>second<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-functional-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义指令</title>
    <url>/2020/02/12/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>Vue 除了默认的内置指令, 还允许注册自定义指令.</p>
<p>全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 v-focus 自定义指令</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  inserted(el) &#123;</span><br><span class="line">    <span class="comment">// 自动获取焦点</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    focus: &#123;</span><br><span class="line">      inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>v-focus</code> 自定义指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>一个指令定义对象可以提供几个钩子函数</p>
<ul>
<li><code>bind</code>: 只调用一次, 指令第一次绑定到元素时调用, 可以进行一次性的初始化设置</li>
<li><code>inserted</code>: 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>: 所在组件的 VNode 更新时调用, 但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li>
<li><code>componentUpdated</code>: 指令所在组件的 VNode 及其子 VNode 全部更新后调用</li>
<li><code>unbind</code>: 只调用一次, 指令与元素解绑时调用</li>
</ul>
<h2 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a>钩子函数的参数</h2><ul>
<li><code>el</code>: 指令所绑定的元素, 可以用来直接操作 DOM</li>
<li><code>binding</code>: 一个对象, 包含以下属性:<ul>
<li><code>name</code>: 指令名, 不包括<code>v-</code>前缀</li>
<li><code>value</code>: 指令的绑定值, 例: <code>v-my-directive=&quot;1+1&quot;</code>, value 为 2</li>
<li><code>oldvalue</code>: 指令绑定的前一个值, 仅在 <code>update</code> 和 <code>componentUpdate</code> 钩子中可用</li>
<li><code>expression</code>: 字符串形式的指令表达式, 例: <code>v-my-directive=&quot;1+1&quot;</code>, 表达式为 “1+1”</li>
<li><code>arg</code>: 传给指令的参数, 可选. 例: <code>v-my-directive:foo</code>, arg 为 foo</li>
<li><code>modifiers</code>: 一个包含修饰符的对象, 例: <code>v-my-directive:foo.bar</code>, 修饰符对象为 <code>{ foo: true, bar : true}</code></li>
</ul>
</li>
<li><code>vnode</code>: Vue 编译生成的虚拟节点</li>
<li><code>oldVnode</code>: 上一个虚拟节点, 仅在 <code>update</code> 和 <code>componentUpdate</code> 钩子可用</li>
</ul>
<blockquote>
<p>除了 <code>el</code>, 其他参数都应该是只读的, 切勿修改, 如果要在钩子之间共享数据, 建议通过元素的 <code>dataset</code> 来进行</p>
</blockquote>
<h2 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h2><p>指令的参数可以是动态的, 例 <code>v-my-directive:[argument]=&quot;value&quot;</code>, <code>argument</code> 参数可以根据组件数据进行更新</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"baseexample"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Scroll down the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin</span>=<span class="string">"200"</span>&gt;</span>Stick me 200px from the top of the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'pin'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    el.style.position = <span class="string">'fixed'</span></span><br><span class="line">    el.style.top = binding.value + <span class="string">'px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'baseexample'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dynamicexample"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">"200"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'pin'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    el.style.position = <span class="string">'fixed'</span></span><br><span class="line">    <span class="keyword">var</span> s = binding.arg == <span class="string">'left'</span> ? <span class="string">'left'</span> : <span class="string">'top'</span></span><br><span class="line">    el.style[s] = binding.value + <span class="string">'px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#dynamicexample'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      direction: <span class="string">'left'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'demo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.text) <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue混入</title>
    <url>/2020/02/11/vue%E6%B7%B7%E5%85%A5/</url>
    <content><![CDATA[<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>混入(mixin)提供了医生非常灵活的方式,来分发 Vue 组件中的可复用功能, 一个混入对象可以包含任意组件选项. 所有混入对象的选项将被”混合”进入该组件本身的选项.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Mixin - &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    hello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Hi,mixin'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></span><br></pre></td></tr></table></figure>

<h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><p>当组件和混入对象含有同名选项时, 这些选项将以恰当的方式进行”合并”</p>
<p>数据对象在内部会进行递归合并, 并在发生冲突时以组件数据优先</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span>,</span><br><span class="line">      foo: <span class="string">'abc'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixin: [mixin],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'bey'</span>,</span><br><span class="line">      bar: <span class="string">'def'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data) <span class="comment">// =&gt; &#123; message: "goodbye", foo: "abc", bar: "def" &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同名钩子函数将合并为一个数组, 因此都将被调用, 混入对象的钩子将在组件自身钩子之前调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'混入对象的钩子被调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'组件钩子被调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; "混入对象的钩子被调用"</span></span><br><span class="line"><span class="comment">// =&gt; "组件钩子被调用"</span></span><br></pre></td></tr></table></figure>

<p>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from mixin'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from self'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.foo() <span class="comment">// =&gt; "foo"</span></span><br><span class="line">vm.bar() <span class="comment">// =&gt; "bar"</span></span><br><span class="line">vm.conflicting() <span class="comment">// =&gt; "from self"</span></span><br></pre></td></tr></table></figure>

<h2 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h2><p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  myOption: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h2><p>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies.myOption = <span class="function"><span class="keyword">function</span>(<span class="params">toVal, fromVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回合并后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于多数值为对象的选项，可以使用与 methods 相同的合并策略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = Vue.config.optionMergeStrategies</span><br><span class="line">strategies.myOption = strategies.methods</span><br></pre></td></tr></table></figure>

<p>可以在 Vuex 1.x 的混入策略里找到一个更高级的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = Vue.config.optionMergeStrategies.computed</span><br><span class="line">Vue.config.optionMergeStrategies.vuex = <span class="function"><span class="keyword">function</span>(<span class="params">toVal, fromVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!toVal) <span class="keyword">return</span> fromVal</span><br><span class="line">  <span class="keyword">if</span> (!fromVal) <span class="keyword">return</span> toVal</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getters: merge(toVal.getters, fromVal.getters),</span><br><span class="line">    state: merge(toVal.state, fromVal.state),</span><br><span class="line">    actions: merge(toVal.actions, fromVal.actions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue状态过渡</title>
    <url>/2020/02/10/vue%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h2 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h2><p>Vue 除了可以对元素或组件提供进入、离开和列表的动效. 还可以将数值结合 Vue 的响应式和组件系统, 使用第三方库来实现切换元素的过渡状态</p>
<h2 id="动态动画与侦听器"><a href="#动态动画与侦听器" class="headerlink" title="动态动画与侦听器"></a>动态动画与侦听器</h2><p>我们可以通过侦听器监听到数值属性的数值更新, 当数值更新时, 就会触发动画</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"animated-number-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"number"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; animatedNumber &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#animated-number-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    tweenedNumber: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    animatedNumber: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.tweenedNumber.toFixed(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    number: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      TweenLite.to(<span class="keyword">this</span>.$data, <span class="number">0.5</span>, &#123; <span class="attr">tweenedNumber</span>: newValue &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对于不能直接像数字一样存储的值，比如-CSS-中的-color-的值，通过下面的例子我们来通过-Tween-js-和-Color-js-实现一个例子："><a href="#对于不能直接像数字一样存储的值，比如-CSS-中的-color-的值，通过下面的例子我们来通过-Tween-js-和-Color-js-实现一个例子：" class="headerlink" title="对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Tween.js 和 Color.js 实现一个例子："></a>对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Tween.js 和 Color.js 实现一个例子：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/color-js@1.0.3"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-7"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"colorQuery"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:keyup.enter</span>=<span class="string">"updateColor"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"Enter a color"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"updateColor"</span>&gt;</span>Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Preview:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:style</span>=<span class="string">"&#123; backgroundColor: tweenedCSSColor &#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"example-7-color-preview"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tweenedCSSColor &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Color = net.brehaut.Color</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-7'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    colorQuery: <span class="string">''</span>,</span><br><span class="line">    color: &#123;</span><br><span class="line">      red: <span class="number">0</span>,</span><br><span class="line">      green: <span class="number">0</span>,</span><br><span class="line">      blue: <span class="number">0</span>,</span><br><span class="line">      alpha: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tweenedColor: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tweenedColor = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.color)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    color: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TWEEN.update()) &#123;</span><br><span class="line">          requestAnimationFrame(animate)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> TWEEN.Tween(<span class="keyword">this</span>.tweenedColor).to(<span class="keyword">this</span>.color, <span class="number">750</span>).start()</span><br><span class="line"></span><br><span class="line">      animate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    tweenedCSSColor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Color(&#123;</span><br><span class="line">        red: <span class="keyword">this</span>.tweenedColor.red,</span><br><span class="line">        green: <span class="keyword">this</span>.tweenedColor.green,</span><br><span class="line">        blue: <span class="keyword">this</span>.tweenedColor.blue,</span><br><span class="line">        alpha: <span class="keyword">this</span>.tweenedColor.alpha</span><br><span class="line">      &#125;).toCSS()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateColor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.color = <span class="keyword">new</span> Color(<span class="keyword">this</span>.colorQuery).toRGB()</span><br><span class="line">      <span class="keyword">this</span>.colorQuery = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example-7-color-preview</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态状态过渡"><a href="#动态状态过渡" class="headerlink" title="动态状态过渡"></a>动态状态过渡</h2><p>管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。<br>我们来将之前的示例改写一下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"firstNumber"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span> /&gt;</span> +</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"secondNumber"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span> /&gt;</span> = &#123;&#123; result &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"firstNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span> +</span><br><span class="line">    <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"secondNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span> =</span><br><span class="line">    <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种复杂的补间动画逻辑可以被复用</span></span><br><span class="line"><span class="comment">// 任何整数都可以执行动画</span></span><br><span class="line"><span class="comment">// 组件化使我们的界面十分清晰</span></span><br><span class="line"><span class="comment">// 可以支持更多更复杂的动态过渡</span></span><br><span class="line"><span class="comment">// 策略。</span></span><br><span class="line">Vue.component(<span class="string">'animated-integer'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tweeningValue: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.tween(oldValue, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tween(<span class="number">0</span>, <span class="keyword">this</span>.value)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    tween: <span class="function"><span class="keyword">function</span>(<span class="params">startValue, endValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TWEEN.update()) &#123;</span><br><span class="line">          requestAnimationFrame(animate)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> TWEEN.Tween(&#123; <span class="attr">tweeningValue</span>: startValue &#125;)</span><br><span class="line">        .to(&#123; <span class="attr">tweeningValue</span>: endValue &#125;, <span class="number">500</span>)</span><br><span class="line">        .onUpdate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          vm.tweeningValue = <span class="keyword">this</span>.tweeningValue.toFixed(<span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .start()</span><br><span class="line"></span><br><span class="line">      animate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的复杂度都已经从 Vue 的主实例中移除！</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-8'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstNumber: <span class="number">20</span>,</span><br><span class="line">    secondNumber: <span class="number">40</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    result: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber + <span class="keyword">this</span>.secondNumber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue进入/离开</title>
    <url>/2020/02/09/vue%E8%BF%9B%E5%85%A5-%E7%A6%BB%E5%BC%80&amp;%E5%88%97%E8%A1%A8%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移出 DOM 时, 提供多种不同方式的应用过渡效果</p>
<ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库, 如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库, 如 Velocity.js</li>
</ul>
<h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了<code>transition</code>的封装组件, 可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染(使用<code>v-if</code>)</li>
<li>条件展示(使用<code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>transition<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      show: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>,</span><br><span class="line"><span class="selector-class">.fade-levce-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>,</span><br><span class="line"><span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当插入或删除包含在 <code>transition</code>组件中的元素时, Vue 将会做以下处理<br>1.自动嗅探目标元素是否应用了 CSS 过渡效果或动画, 如果是, 在恰当的时机添加/删除 CSS 类名<br>2.如果过渡组件提供了 JavaScript 钩子函数, 这些钩子函数将在恰当的时机被调用<br>3.如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画, DOM 操作(插入/删除)在下一帧中立即执行</p>
<h2 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h2><p>在进入/离开的过渡中, 会有 6 个 class 切换</p>
<ol>
<li><code>v-enter</code>: 定义进入过渡的开始状态, 在元素被插入之前生效, 在元素被插入之后的下一帧移除</li>
<li><code>v-enter-active</code>: 定义进入过渡生效时的状态, 在整个进入过渡的阶段中应用, 在元素被插入之前生效, 在过渡/动画完成之后移除. 这个类可以用来定义进入过渡的过渡时间, 延迟和曲线函数</li>
<li><code>v-enter-to</code>: 定义进入过渡的结束状态, 在元素被插入之后下一帧生效(与此同时<code>v-enter</code>被移除), 在过渡/动画完成之后移除</li>
<li><code>v-leave</code>: 定义离开过渡的开始状态, 在离开过渡被触发时立刻生效, 下一帧被移除</li>
<li><code>v-leave-active</code>: 定义离开过渡生效时的状态. 在整个离开过渡的阶段中应用, 在离开过渡被触发时立刻生效, 在过渡/动画完成之后移除, 这个类可以备用来定义离开过渡的过程时间, 延迟和曲线函数</li>
<li><code>v-leave-to</code>: 定义离开过渡的结束状态, 在离开过渡被触发之后下一帧生效(与此同时<code>v-leave</code>被删除), 在过渡/动画完成之后移除</li>
</ol>
<p><img data-src="../image/transition.png" alt="transition"></p>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <transition>，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter。</p>
<p>v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。</p>
<h2 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h2><p>常用的都是使用 CSS 过渡</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"slide-fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span><br><span class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span><br><span class="line"><span class="comment">/* .slide-fade-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><p>CSS 动画用法与 CSS 过渡, 区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除, 而是在 <code>animationend</code>事件触发时删除</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>Toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis</span><br><span class="line">      enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi</span><br><span class="line">      tristique senectus et netus.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h2><p>我们可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"custom-classes-transition"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">enter-active-class</span>=<span class="string">"animated tada"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOutRight"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h2><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code>，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>
<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用 type attribute 并设置 animation 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p>
<h2 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h2><p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p>
<p>在这种情况下你可以用 <code>&lt;transition&gt;</code> 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"1000"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以定制进入和移出的持续时间：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h2><p>可以在属性中声明 JavaScript 钩子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line">  <span class="comment">// 进入中</span></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line"></span><br><span class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当与 CSS 结合使用时</span></span><br><span class="line">  <span class="comment">// 回调函数 done 是可选的</span></span><br><span class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line">  <span class="comment">// 离开时</span></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line"></span><br><span class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当与 CSS 结合使用时</span></span><br><span class="line">  <span class="comment">// 回调函数 done 是可选的</span></span><br><span class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></span><br><span class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些钩子函数可以结合 CSS <code>transitions/animations</code> 使用，也可以单独使用。</p>
<blockquote>
<p>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。<br>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>
</blockquote>
<h2 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h2><p>可以通过<code>appear</code>attribute 设置节点在初始渲染的过渡</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里默认和进入/离开过渡一样, 同样也可以自定义 CSS 类名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear-class</span>=<span class="string">"custom-appear-class"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear-to-class</span>=<span class="string">"custom-appear-to-class"</span></span></span><br><span class="line"><span class="tag">  (<span class="attr">2.1.8</span>+)</span></span><br><span class="line"><span class="tag">  <span class="attr">appear-active-class</span>=<span class="string">"custom-appear-active-class"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义 JavaScript 钩子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-appear</span>=<span class="string">"customBeforeAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:appear</span>=<span class="string">"customAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-appear</span>=<span class="string">"customAfterAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:appear-cancelled</span>=<span class="string">"customAppearCancelledHook"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><p>我们之后讨论多个组件的过渡，对于原生标签可以使用 v-if/v-else。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">v-if</span>=<span class="string">"items.length &gt; 0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>Sorry, no items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当有相同标签名的元素切换时，需要通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 是一个更好的实践。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isEditing"</span> <span class="attr">key</span>=<span class="string">"save"</span>&gt;</span></span><br><span class="line">    Save</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"edit"</span>&gt;</span></span><br><span class="line">    Edit</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h2><ul>
<li><code>in-out</code>: 新元素先进行过渡, 完成之后当前元素过渡离开</li>
<li><code>out-in</code>: 当前元素先进行过渡, 完成之后新元素过渡进入</li>
</ul>
<h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡只需要使用动态组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"component-fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#transition-components-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    view: <span class="string">'v-a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'v-a'</span>: &#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;Component A&lt;/div&gt;'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'v-b'</span>: &#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;Component B&lt;/div&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.component-fade-enter-active</span>,</span><br><span class="line"><span class="selector-class">.component-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.component-fade-enter</span>, <span class="selector-class">.component-fade-leave-to</span></span><br><span class="line"><span class="comment">/* .component-fade-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>使用 <code>&lt;transition-group&gt;</code> 组件可以同时渲染整个列表</p>
<ul>
<li>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag attribute 更换为其他元素。</li>
<li>过渡模式不可用，因为我们不再相互切换特有的元素。</li>
<li>内部元素 总是需要 提供唯一的 key 属性值。</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。</li>
</ul>
<h2 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h2><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move attribute，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"flip-list-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"shuffle"</span>&gt;</span>Shuffle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#flip-list-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    shuffle: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.items = _.shuffle(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flip-list-move</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue处理边界情况</title>
    <url>/2020/02/08/vue%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h1><p>在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。</p>
<h2 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h2><p>这每个 <code>new Vue</code> 实例的子组件中, 其根实例可以通过<code>$root</code>属性进行访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所有的子组件都可以将这个实例作为一个 store 来访问或使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure>

<h2 id="访问父级组件实例"><a href="#访问父级组件实例" class="headerlink" title="访问父级组件实例"></a>访问父级组件实例</h2><p>和 <code>$root</code> 类似, <code>$parent</code> 属性可以用来从一个子组件访问父组件的实例.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      &#123;&#123; msg &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-com</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      Vue.component(<span class="string">'my-com'</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>M<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>',</span></span></span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 访问父级</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.msg) <span class="comment">// G</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$parent.foo() <span class="comment">// foo</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            msg: <span class="string">'G'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          foo() &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h2><p>有时候, 需要直接访问子组件, 可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">ref</span>=<span class="string">"my-com"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在定义了这个 <code>ref</code> 的组件里使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs[<span class="string">'my-com'</span>].msg</span><br></pre></td></tr></table></figure>

<p>获取指定 DOM 元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"click"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      click() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs[<span class="string">'input'</span>].focus()</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p>
</blockquote>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>我们可以虽然可以通过 <code>$parent</code>、<code>$refs</code>、属性、事件等方式获取获取父组件或子组件的实例或属性, 但是无法扩展到更深层次级的嵌套组件上.<br>Vue 给我们提供了两个新的实例选项 <code>provide</code> 和 <code>inject</code>, 选项允许我们指定我们想要提供给后代组件的数据/方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根组件</span></span><br><span class="line">provide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 第一层嵌套组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二层嵌套组件</span></span><br><span class="line">inject: [<span class="string">"getMap"</span>]</span><br></pre></td></tr></table></figure>

<h2 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h2><p>除了 <code>$emit</code>可以被<code>v-on</code>侦听, Vue 同时还在事件接口中提供了其他方法:</p>
<ul>
<li>通过<code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过<code>$once(eventName, eventHandle)</code> 一次性侦听一个事件</li>
<li>通过<code>$off(eventName, ebentHandle)</code> 停止侦听一个事件</li>
</ul>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件是可以在他们自己的模板中调用自身的, 不过它们只能通过 <code>name</code> 选项来做这件事</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>

<p>当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>稍有不慎, 递归组件就可能导致无限循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>

<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。</p>
<h3 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h3><p>假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一个<code>&lt;tree-folder-contents&gt;</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代和祖先——一个悖论！当通过 <code>Vue.component</code> 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。<br>然而，如果你使用一个模块系统依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure>

<p>为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。”<br>在我们的例子中，把 <code>&lt;tree-folder&gt;</code> 组件设为了那个点。我们知道那个产生悖论的子组件是 <code>&lt;tree-folder-contents&gt;</code> 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，在本地注册组件的时候，你可以使用 webpack 的异步 import：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h2><h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h3><p>当 <code>inline-template</code> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component's own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent's transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内联模板需要定义在 Vue 所属的 DOM 元素内。<br>不过，inline-template 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p>
</blockquote>
<h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h3><p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中, 并为其带上 <code>ext/x-template</code> 的类型, 然后通过一个 id 将模板引用过去</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x-template 需要定义在 Vue 所属的 DOM 元素外。<br>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。</p>
</blockquote>
<h2 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h2><p>感谢 Vue 的响应式系统，它始终知道何时进行更新 (如果你用对了的话)。不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。</p>
<h3 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h3><p>你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 <code>$forceUpdate</code> 来做这件事。</p>
<h3 id="通过-v-once-创建低开销的静态组件"><a href="#通过-v-once-创建低开销的静态组件" class="headerlink" title="通过 v-once 创建低开销的静态组件"></a>通过 <code>v-once</code> 创建低开销的静态组件</h3><p>渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件深入-动态</title>
    <url>/2020/02/07/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5-%E5%8A%A8%E6%80%81/</url>
    <content><![CDATA[<h2 id="在动态组件上使用-keep-alive"><a href="#在动态组件上使用-keep-alive" class="headerlink" title="在动态组件上使用 keep-alive"></a>在动态组件上使用 <code>keep-alive</code></h2><p>我们可以使用 <code>is</code> attribute 来切换不同的组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-componet</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在切换组件的时候, 我们有时候需要保持这些组件的状态, 避免反复冲渲染导致性能的问题.<br>为了解决这个问题, Vue 为我们提供了 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-binf:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;keep-alive&gt;</code> 元素要求被切换的组件都有自己的名字.</p>
</blockquote>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>我们可以将应用分隔成一些小代码块, 在组件需要被用到的时候才从服务器加载一个模块.<br>Vue 允许以一个工厂函数的方式定义一个组件, 这个工厂函数会异步解析组件定义<br>Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数, 并把结果缓存起来供未来重渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步组件-在1秒后渲染</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimieout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(&#123; <span class="attr">template</span>: <span class="string">'&lt;h1&gt;标题&lt;/h1&gt;'</span> &#125;)</span><br><span class="line">    <span class="comment">// reject() 组件加载失败</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将异步组件和<code>webpack</code>的<code>code-splitting</code>功能一起配合使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以在工厂函数中返回一个 <code>Promise</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>局部注册时, 也可以直接提供一个返回<code>Promise</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-components'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="处理加载状态"><a href="#处理加载状态" class="headerlink" title="处理加载状态"></a>处理加载状态</h2><p>异步组件工厂函数也可以返回一个如下格式的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个`Promise`对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延迟时间, 默认200毫秒</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件 默认 `Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件深入-插槽</title>
    <url>/2020/02/06/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5-%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>在 2.6.0 中，具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。</p>
</blockquote>
<h2 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h2><p>Vue 实现了一套内容分发的 API, 它将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口<br><code>&lt;slot&gt;&lt;/slot&gt;</code> 插槽内可以包含任何模板内容, 可以是文本、html、其他组件</p>
<blockquote>
<p>如果没有使用<code>&lt;slot&gt;</code>元素, 该组件起始标签和结束标签之间的任何内容都不会渲染</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">    这里的内容会替换到子组件中slot元素的位置</span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>如果想在一个插槽中使用数据, 该插槽跟模板其他地方一样可以访问相同的实例属性(相同的作用域)</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的, 子模板里的所有内容都是在子作用域中编译的</p>
</blockquote>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>我们在使用<code>&lt;slot&gt;</code>元素时, 可以放置一个默认内容, 当父组件中没有传入此项时, 该内容会被渲染, 当父组件有内容传入时, 传入内容替换掉默认内容, 被渲染出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-child</span>&gt;</span></span><br><span class="line">    传入内容会替换掉默认内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><blockquote>
<p>v-slot 只能添加在<code>&lt;template&gt;</code>上</p>
</blockquote>
<p>有时候, 我们需要用到多个插槽, Vue 为<code>&lt;slot&gt;</code>元素提供了一个特殊的 name 属性, 可以用这个属性为额外的插槽进行定义<br>一个不带 name 的<code>&lt;slot&gt;</code>出口会带有隐含的名字”default”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>默认 name 插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>H3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span>content<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> button <span class="keyword">from</span> <span class="string">'./button'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line"><span class="actionscript">    components: &#123; <span class="string">'my-button'</span>: button &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认名为 default 的插槽<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>有时候, 我们需要让插槽内容可以访问子组件中才有的数据<br>为了能在父级的插槽内访问到子组件的数据, 我们可以将数据作为<code>&lt;slot&gt;</code>元素的一个属性绑定上去</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>绑定在<code>&lt;slot&gt;</code>元素上的 attribute 被称为<strong>插槽 prop</strong>, 我们可以在父级作用域中, 使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 名字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="独战默认插槽的缩写语法"><a href="#独战默认插槽的缩写语法" class="headerlink" title="独战默认插槽的缩写语法"></a>独战默认插槽的缩写语法</h2><blockquote>
<p>当出现多个插槽时, 需要始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>语法</p>
</blockquote>
<p>当被提供的内容只有默认插槽时, 我们可以不使用<code>&lt;template&gt;</code>元素, 而是将<code>v-slot</code>直接用在组件上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.lastName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="解构插槽"><a href="#解构插槽" class="headerlink" title="解构插槽"></a>解构插槽</h2><p>作用域插槽的工作原理是将插槽内容包括在一个传入单个参数的函数里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着<code>v-slot</code>的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式. 所以我们可以通过解构的方式来传入具体的插槽 prop</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">"&#123;user&#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将插槽 prop 重命名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">"&#123;user: person&#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.lastName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h2><p><strong>动态指令参数</strong>也可以用在<code>v-slot</code>上, 来定义动态的插槽名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><blockquote>
<p>如果要使用缩写, 必须始终以明确插槽名取代</p>
</blockquote>
<p>跟<code>v-on</code>和<code>v-bind</code>一样, <code>v-slot</code>也有缩写, 即把参数之前的所有内容(<code>v-slot:</code>)替换为字符<code>#</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>缩写的具名插槽<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>缩写的默认插槽<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><p>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容<br>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 todo 作为一个插槽 prop 进行绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in filteredTodos"</span> <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    我们为每个 todo 准备了一个插槽，</span></span><br><span class="line"><span class="comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo"</span> <span class="attr">v-bind:todo</span>=<span class="string">"todo"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">"todos"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">"&#123; todo &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"todo.isComplete"</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件深入-自定义事件</title>
    <url>/2020/02/05/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h2><p>事件名需要完全匹配监听这个事件所用的名称</p>
<blockquote>
<p>推荐使用短横线分隔法命名</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'myEvent'</span>)</span><br></pre></td></tr></table></figure>

<p>监听这个事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无效的做法</span></span><br><span class="line">&lt;my-component v-on:my-event=<span class="string">"handleEmit"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="自定义组件的-v-modle"><a href="#自定义组件的-v-modle" class="headerlink" title="自定义组件的 v-modle"></a>自定义组件的 <code>v-modle</code></h2><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code>的事件.<br>单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于不同的目的<br><code>model</code> 选项可以用来避免这样的冲突</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h2><p>如果想要在一个组件的根元素上直接监听一个原生事件, 可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-inpur</span> <span class="attr">v-on.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-inpur</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很多时候, 自定义组件中根元素并不是我们真正想要监听的元素, 如下:<br>这时候, 父级的 <code>.native</code> 监听器将静默失败, 他不会产生任何报错, 但是 <code>onFocus</code> 处理函数不会如预期被调用.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">"value"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">"$emit('input', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题, Vue 提供了一个 <code>$listeners</code> 属性, 他是一个对象, 里面包含了作用在这个组件上的所有监听器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;,</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个 $listeners 属性，你就可以配合 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在 <code>&lt;base-input&gt;</code> 组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器的都可以工作。</p>
<h2 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h2><p>有些特殊情况下, 我们可能需要对一个 <code>prop</code> 进行”双向绑定”, 这样很容易带来维护上的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTile)</span><br></pre></td></tr></table></figure>

<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue 为这种模式提供了一个缩写, 即 <code>.sync</code> 修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</p>
</blockquote>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：</p>
<blockquote>
<p><code>&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</code></p>
</blockquote>
<p>这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。</p>
<blockquote>
<p>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件深入-Prop</title>
    <url>/2020/02/05/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5-Prop/</url>
    <content><![CDATA[<h2 id="Prop-的大小写"><a href="#Prop-的大小写" class="headerlink" title="Prop 的大小写"></a>Prop 的大小写</h2><p>在 HTML 元素的属性中对于大小写是不敏感的, 所以浏览器会将所有大写解释为小写字符, 意味着使用 DOM 模板时, 驼峰命名的 prop 名需要使用等价的短横线分隔命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'componentsName'</span>, &#123;</span><br><span class="line">  <span class="comment">// 驼峰命名</span></span><br><span class="line">  props: [<span class="string">'docTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;&#123;&#123; docTitle &#125;&#125;&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 html 中是短横线分隔的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component-name</span> <span class="attr">doc-title</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">component-name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a>Prop 类型</h2><p>props 可以是个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'title'</span>, <span class="string">'name'</span>, <span class="string">'content'</span>, <span class="string">'gender'</span>]</span><br></pre></td></tr></table></figure>

<p>很多时候我们都希望每个 prop 都有指定的值类型, 我们可以用对象的形式列出 prop, 如果传入的 prop 类型与定义不符, Vue 会在控制台进行提示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  content: <span class="built_in">String</span>,</span><br><span class="line">  gender: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h2><blockquote>
<p>我们可以将任意数据类型的值传递给 prop</p>
</blockquote>
<p>我们可以给 prop 传入一个静态值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">title</span>=<span class="string">"Ginger"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过<code>v-bind</code>对 prop 进行动态赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  title: <span class="string">'Ginger'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;my-component v-bind:title=<span class="string">"info.title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的 prop 都使得父子组件的 prop 之间形成了一个<strong>单向下行绑定</strong><br>父级的 prop 的更新会向下流动到子组件中, 无法反过来<br>因为每次父组件发生更新时, 子组件中所有 prop 都将会刷新为最新的值, 所以不应该在一个子组件内改变 prop</p>
<ul>
<li>需要将 prop 作为子组件内部数据来使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要将传入的 prop 值进行转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props:[<span class="string">'size'</span>],</span><br><span class="line"><span class="comment">// 使用一个计算属性来处理</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prop-验证"><a href="#prop-验证" class="headerlink" title="prop 验证"></a>prop 验证</h2><p>我们可以为组件的 prop 指定验证要求, 如果不满足要求, Vue 会在控制台发出警告<br>为了定制 prop 的验证方式, 可以为 props 中的值提供一个验证需求的对象, 而不是一个字符串数组</p>
<blockquote>
<p>验证失败 Vue 会在控制台显示警告</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propA: <span class="built_in">Number</span>, <span class="comment">// 基础类型验证</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>], <span class="comment">// 可以是多个类型</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      <span class="comment">// 必须传入的字符串</span></span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    propD: &#123;</span><br><span class="line">      <span class="comment">// 默认100的数字</span></span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    propE: &#123;</span><br><span class="line">      <span class="comment">// 带有默认的对象</span></span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'Ginger'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    propF: &#123;</span><br><span class="line">      <span class="comment">// 自定义验证函数</span></span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'waring'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><code>type</code> 可以是下列原生构造函数中的一个:</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>另外, <code>type</code> 也可以是一个自定义的构造函数, 并且通过 <code>instanceof</code> 来进行检查确认</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h3><p>有些 attribute 通过自定义属性传向子组件, 但是在子组件内部并没有通过 props 接受, 这些 attribute 会被添加到这个组件的根元素上</p>
<h3 id="替换-合并已有的-attribute"><a href="#替换-合并已有的-attribute" class="headerlink" title="替换/合并已有的 attribute"></a>替换/合并已有的 attribute</h3><p>对于绝大多数 <code>attribute</code> 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text</code> 就会替换掉 <code>type=&quot;date</code> <code>并把它破坏！庆幸的是，class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control</code> <code>date-picker-theme-dark</code>。</p>
<h3 id="禁用-attribute-继承"><a href="#禁用-attribute-继承" class="headerlink" title="禁用 attribute 继承"></a>禁用 attribute 继承</h3><p>如果不希望组件的根元素继承 attribute, 可以在组件的选项中设置 <code>inheritAttrs: false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="attrs-属性包含了传递给一个组件的-attribute-名和值"><a href="#attrs-属性包含了传递给一个组件的-attribute-名和值" class="headerlink" title="$attrs 属性包含了传递给一个组件的 attribute 名和值"></a>$attrs 属性包含了传递给一个组件的 attribute 名和值</h4><p>利用 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，就可以手动决定这些 attribute 会被赋予哪个元素</p>
<blockquote>
<p>inheritAttrs: false 选项不会影响 style 和 class 的绑定。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件深入</title>
    <url>/2020/02/05/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h2 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h2><p>在注册一个组件的时候, 我们始终需要给它一个名字. 我们在使用<code>Vue.component</code>注册组件时, 第一个参数就是组件名</p>
<blockquote>
<p>Vue 推荐使用全小写字母且必须包含一个连字符</p>
</blockquote>
<h2 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h2><p>定义组件名的方式有两种:<br><strong>使用 kebab-case</strong><br>使用组件: <code>&lt;my-component-name&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>使用 OascalCase</strong><br>使用组件</p>
<ul>
<li><code>&lt;my-component-name&gt;</code></li>
<li><code>&lt;MyComponentName&gt;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'MyComponentName'</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>当我们使用 <code>Vue.component()</code>来创建组件时, 这个组件时全局的, 我们可以在任何创建的 Vue 实例的模板中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      Vue.component(<span class="string">'my-component'</span>, &#123;</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            text: <span class="string">'Ginger'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; text &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123; el: <span class="string">'#app'</span> &#125;)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>全局注册的组件即使在我们不使用的时候仍然会被包含在最终的构建结果中, 会造成用户下载的增加<br>我们可以通过一个普通 JavaScript 对象来定义组件, 然后在需要使用的 vue 实例中进行注册<br>对于 components 对象中的每个属性来说, 其属性名就是自定义元素的名字, 其属性值就是这个组件的选项对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">app-hellp</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> hello = &#123;</span></span><br><span class="line"><span class="actionscript">        data: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            msg: <span class="string">'Hi'</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">          <span class="string">'app-hellp'</span>: hello</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在模块系统中局部注册"><a href="#在模块系统中局部注册" class="headerlink" title="在模块系统中局部注册"></a>在模块系统中局部注册</h2><p>我们也可以通过 <code>require</code> / <code>import</code> 使用一个模块系统.</p>
<h3 id="在模块系统中局部注册-1"><a href="#在模块系统中局部注册-1" class="headerlink" title="在模块系统中局部注册"></a>在模块系统中局部注册</h3><blockquote>
<p>推荐创建一个 <code>components</code> 目录, 将每个组件防止在其各自的文件中</p>
</blockquote>
<p>在模块系统中使用组件需要在局部注册之前, 我们需要导入每个想使用的组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在使用前 先引入要使用的组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home'</span></span><br><span class="line"><span class="keyword">import</span> Mine <span class="keyword">from</span> <span class="string">'./components/Mine'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Home,</span><br><span class="line">    Mine</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基础组件的自动化全局注册"><a href="#基础组件的自动化全局注册" class="headerlink" title="基础组件的自动化全局注册"></a>基础组件的自动化全局注册</h3><p>当我们使用了 webpack 构建应用时, 可以使用 <code>require.context</code> 只全局注册通用的基础组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">'/'</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局注册必须在根 Vue 实例创建之前注册</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件基础</title>
    <url>/2020/02/04/vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>组件是可复用的 Vue 实例, 且带有一个名字, 我们可以通过 new Vue 创建的 Vue 跟实例中, 把这个组件当做自定义元素来使用<br>组件与 new Vue 接受相同的选项</p>
<blockquote>
<p>组件的 <code>data</code> 必须是一个函数, 它返回一个对象的独立的拷贝<br>组件注册可分为 <strong>全局注册</strong>和<strong>局部注册</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'Hi! Vue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>组件可以进行任意次数的复用, 每个组件都会各自维护它的实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hellp-world</span>&gt;</span><span class="tag">&lt;/<span class="name">hellp-world</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hellp-world</span>&gt;</span><span class="tag">&lt;/<span class="name">hellp-world</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hellp-world</span>&gt;</span><span class="tag">&lt;/<span class="name">hellp-world</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h2><p>一个应用会以一颗嵌套的组件树的形式来组织:<br><img data-src="../image/components.png" alt="component"></p>
<h2 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a>通过 <code>Prop</code> 向子组件传递数据</h2><p>Prop 是可以在组件上注册的一些自定义 attribute, 当一个值传递给一个 prop attribute 的时候, 他就变成了那个组件实例的一个属性.<br>我们可以用一个 <code>props</code> 选项将其包含在该组件可接受的 prop 列表中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'title'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt; &#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h2><blockquote>
<p>每个组件必须只有一个根元素</p>
</blockquote>
<p>当构建一个子组件的时候, 模板内最终包含的内容远不止一个标题, Vue 要求每个组件必须只有一个根元素, 可以将模板的内容包裹在一个父元素内.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent 父组件</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">  &lt;child /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ child 子组件</span></span><br><span class="line"><span class="regexp">&lt;div class="child"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h3&gt;标题&lt;/</span>h3&gt;</span><br><span class="line">  &lt;p&gt;内容&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h2><p>有时候, 我们需要在子组件内部传递一些内容到父元素<br>Vue 实例提供了一个自定义事件的系统来解决这个问题, 父组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 接受一个由子元素提交的自定义方法</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">  &lt;child v-on:myEmit=<span class="string">"handleEmit"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件 传递一个自定义事件</span></span><br><span class="line"><span class="regexp">&lt;child v-on:click="$emit('myEmit')"&gt;</span></span><br><span class="line"><span class="regexp">  子组件</span></span><br><span class="line"><span class="regexp">&lt;/</span>child&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 接受一个由子元素提交的自定义方法</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">  &lt;child v-on:myEmit=<span class="string">"handleEmit"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件 自定义方法可以通过第二个参数进行传递</span></span><br><span class="line"><span class="regexp">&lt;child v-on:click="$emit('myEmit', true)"&gt;</span></span><br><span class="line"><span class="regexp">  子组件</span></span><br><span class="line"><span class="regexp">&lt;/</span>child&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span> <span class="attr">v-on:input</span>=<span class="string">"searchText = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了让它正常工作, 这个组件内的 <code>&lt;input&gt;</code> 必须:</p>
<ul>
<li>将其 value attribute 绑定到一个名叫 value 的 prop 上</li>
<li>在其 input 事件被触发时, 将新的值通过自定义的 input 事件抛出</li>
</ul>
<h2 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h2><p>和 HTML 元素一样, 我们经常需要向一个组件传递内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件使用子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>插槽插入内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插槽插入内容会替换下面的slot标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>有的时候, 在不同的组件之间进行动态切换时非常有用的<br>我们可以通过 Vue 的<code>&lt;component&gt;</code>元素加一个特殊的<code>is</code>attribute 来实现<br><code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字</li>
<li>一个组件的选项对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件会在 currentTabComponent 改变时改变</span></span><br><span class="line">&lt;component v-bind:is=<span class="string">"currentTabComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue表单输入绑定</title>
    <url>/2020/02/04/vue%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素上创建双向数据绑定. 它会根据控件类型自动选取正确的方法来更新元素. 但<code>v-model</code>的本质只是语法糖</p>
<blockquote>
<p><code>v-model</code> 会忽略所有表单元素的 <code>vaule</code>、<code>checked</code>、<code>select</code>的初始值, 而使用 Vue 实例中数据作为数据来源, 所以我们需要在 data 中声明初始值</p>
</blockquote>
<p><code>v-model</code> 在内部为不同的表单元素使用不同的属性并抛出不同的事件:</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件</li>
<li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件</li>
</ul>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        msg: <span class="string">'Hi'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单个复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多个复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"Jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkes"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"Ginger"</span> <span class="attr">v-model</span>=<span class="string">"checkes"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"Som"</span> <span class="attr">v-model</span>=<span class="string">"checkes"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; checkes &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        checked: <span class="literal">false</span>,</span></span><br><span class="line">        checkes: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"y"</span>&gt;</span></span><br><span class="line">      Yes</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"y"</span> <span class="attr">value</span>=<span class="string">"y"</span> <span class="attr">v-model</span>=<span class="string">"res"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"n"</span>&gt;</span></span><br><span class="line">      No</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"n"</span> <span class="attr">value</span>=<span class="string">"n"</span> <span class="attr">v-model</span>=<span class="string">"res"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; res &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        res: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selectd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>&gt;</span>点击选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; selectd &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        selectd: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy-修饰符"><a href="#lazy-修饰符" class="headerlink" title=".lazy 修饰符"></a><code>.lazy</code> 修饰符</h3><p><code>v-model</code> 会在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步, 可以通过添加 <code>.lazy</code> 修饰符, 从而转变为使用 <code>change</code> 事件进行同步</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>change update: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        msg: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="number-修饰符"><a href="#number-修饰符" class="headerlink" title=".number 修饰符"></a><code>.number</code> 修饰符</h3><p>如果想将用户输入值转为数值类型, 可以给 <code>v-model</code> 添加 <code>number</code> 修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- string =&gt; number --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h3><p>如果要自动过滤用户输入的收尾空白字符, 可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h2><p>在原生 HTML 的输入元素不能满足需求时, Vue 允许创建自定义行为的输入组件, 并且可以绑定 <code>v-model</code> 一起使用</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue事件处理</title>
    <url>/2020/02/04/vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件, 并在触发时运行一些 JavaScript 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"count += 1"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>大多时候, 我们的事件处理逻辑都是复杂的, 这时候直接写在 <code>v-on</code> 指令中是不可行的, 因此 <code>v-on</code> 还可以接受一个需要调用的方法名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add() &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// this 指向当前 vue 实例</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.count += <span class="number">1</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  vm.add() <span class="comment">// 也可以直接用实例调用此方法</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><p>除了在 <code>v-on</code> 指令后面绑定一个方法, 我们也可以在内联的 JavaScript 语句中调用方法<br>有时候我们需要在方法中访问原生的 DOM 事件, 可以用特殊的变量 <code>$event</code> 把它传入方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"log('Hi')"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'app'</span>,</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      log(msg) &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// this 指向当前 vue 实例</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(msg)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在日常开发场景中, <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求<br>为了解决此类场景, Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong></p>
<blockquote>
<p>修饰符是由<strong>点</strong>开头的指令后缀表示</p>
</blockquote>
<ul>
<li><code>.stop</code> 阻止事件继续传播</li>
<li><code>.prevent</code> 提交事件不再重载页面</li>
<li><code>.captrue</code> 使用事件捕获模式</li>
<li><code>.self</code> 只在 event.target 是当前元素资深时触发处理函数</li>
<li><code>.once</code> 点击事件将只会触发一次</li>
<li><code>.passive</code> 滚动事件的默认行为将会立即触发, 不会等待 <code>onScroll</code> 完成</li>
</ul>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时, 我们经常要检查详细的按键, Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p>
<ul>
<li><code>.enter</code> 回车键</li>
<li><code>.tab</code> tab 键</li>
<li><code>.delete</code> 删除和退格键</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vue 允许我们将 <code>keyboardEvent.key</code> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符<br>还可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112</p>
</blockquote>
<h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><p>可以用以下修饰符来实现仅在按下相应按键时才出发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- alt + c --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h2><p><code>.exact</code>修饰符允许控制由精确的系统修饰符组合触发的事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 alt 或 shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 ctrl 被按下时才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onClick"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h2><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue列表渲染</title>
    <url>/2020/02/04/vue%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>我们可以用<code>v-for</code>指令基于一个数组来渲染一个列表. <code>v-for</code>指令需要使用 <code>item in items</code>形式的特殊语法, 其中<code>items</code>是源数据数组, 而<code>item</code>则是被迭代的数组元素的<strong>别名</strong></p>
<blockquote>
<p>也可以用<code>of</code>替代<code>in</code>作为分隔符<br>v-for 可以接受整数, 它会将模板重复对应次数<br>v-for 的对象也可以是一个计算属性或一个方法<br>可以在<code>&lt;template&gt;</code>元素上使用 v-for<br>不推荐在同一个元素上直接使用 v-for 与 v-if, v-for 的优先级高于 v-if</p>
</blockquote>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><ul>
<li>items 遍历源数据</li>
<li>item 遍历项</li>
<li>index 索引值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>滴滴搭<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        items: [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'js'</span>, <span class="string">'vue'</span>, <span class="string">'react'</span>]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><blockquote>
<p>遍历对象会按照 Object.keys() 的结果遍历</p>
</blockquote>
<ul>
<li>objs 源数据对象</li>
<li>key 键</li>
<li>val 值</li>
<li>index 索引</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>滴滴<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(val, key, index) of objs"</span> <span class="attr">:key</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">        &#123;&#123; index &#125;&#125;-&#123;&#123; key &#125;&#125;-&#123;&#123;val&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        objs: &#123;</span><br><span class="line"><span class="actionscript">          name: <span class="string">'Ginger'</span>,</span></span><br><span class="line">          age: 24</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h2><p>Vue 在使用 <code>v-for</code> 渲染元素列表时, 如果数据项顺序发生改变, Vue 将不会移动 DOM 元素来匹配数据项的顺序, 而是就地更新每个元素, 并且确保他们每个索引位置正确渲染.<br>为了使 Vue 能跟踪每个节点的身份, 从而重用和重新排序现有元素, 我们需要为每项提供一个唯一的 key 属性</p>
<blockquote>
<p>不推荐使用对象或数之类的非基本类型值作为 v-for 的 key, 推荐使用字符串或数值类型</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>Vue 将被侦听的数组的编译方法进行了包裹, 所以他们也将会触发试图更新</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>Vue 除了提供变异方法外, 还提供了非变异方法, 他们不会改变原始数组, 而总是返回一个数组</p>
<ul>
<li>filter()</li>
<li>concat()</li>
<li>slice()</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 限制, Vue 不能检测以下数组变动</p>
<ul>
<li>利用索引直接修改数组某一项时</li>
<li>修改数组长度时</li>
</ul>
<h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><p>为了解决无法检测到数组变动的问题, Vue 提供了以下两个方法, 或者使用其他变异方式等进行处理</p>
<ul>
<li>Vue.set()</li>
<li>vm.$set()</li>
</ul>
<h2 id="对象变更检测"><a href="#对象变更检测" class="headerlink" title="对象变更检测"></a>对象变更检测</h2><p>由于 JavaScript 限制, Vue 不能检测对象属性的添加或删除<br>对于已创建的 Vue 实例, Vue 不允许动态添加根级别的响应式属性, 但是可以用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      name: <span class="string">'ginger'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加单个属性</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.obj, 'age', 18)</span><br><span class="line">// 添加多个属性</span><br><span class="line">vm.obj = Object.assign(&#123;&#125;, vm.obj, &#123;</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">  address: <span class="string">'China'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h2><p>我们可以在任何自定义组件上使用 v-for 但是我们必须定义 key<br>如果要将遍历内容数据传递到组件内, 需要使用 props</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue条件渲染</title>
    <url>/2020/02/03/vue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p><code>v-if</code> 指令用于条件性的渲染一块内容. 该内容只有在表达式结果返回 <code>true</code> 值的时候被渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"true"</span>&gt;</span>v-if表达式结果为真时显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="lt-template-gt-元素"><a href="#lt-template-gt-元素" class="headerlink" title="&lt;template&gt; 元素"></a><code>&lt;template&gt;</code> 元素</h3><p><code>&lt;template&gt;</code> 元素是 Vue 给我们提供的内置元素, 它不会显示在页面中<br>如果我们要对多个元素使用<code>v-if</code>指令, 可以使用 <code>&lt;template&gt;</code> 元素包裹所有需要作用的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>可以使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的’else’块<br><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素后面, 否则它将不会被识别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p><code>v-else-if</code>, 可以充当<code>v-if</code>的’else-if’块, 可以连续使用, 也必须紧跟在带<code>v-if</code>或者<code>v-else-if</code>元素之后</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type==='A'"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type==='B'"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type==='C'"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>=<span class="string">"type==='D'"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>Vue 会尽可能高效的渲染元素, 通常会复用已有元素而不是从头开始渲染, 这么做会使 Vue 变得非常快<br>但有时候, 我们并不希望使用此特性, Vue 为我们一种方式来表达不复用, 只需要添加一个具有唯一值的<code>key</code>属性即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;template v-if&#x3D;&quot;loginType&quot;&gt;</span><br><span class="line">      &lt;label&gt;Username&lt;&#x2F;label&gt;</span><br><span class="line">      &lt;input placeholder&#x3D;&quot;Enter your username&quot; key&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">      &lt;label&gt;Email&lt;&#x2F;label&gt;</span><br><span class="line">      &lt;input placeholder&#x3D;&quot;Enter your email address&quot; key&#x3D;&quot;pwd&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;handle&quot;&gt;toog&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handle() &#123;</span><br><span class="line">      this.loginType &#x3D; !this.loginType</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loginType: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个根据条件展示元素的选项是<code>v-show</code>指令, 用法与<code>v-if</code>大致一样:</p>
<blockquote>
<p>v-show 不支持 <code>&lt;template&gt;</code> 元素, 也不支持 v-else</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"true"</span>&gt;</span>Ginger<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><ul>
<li>v-if 是真正的条件渲染, 他会在切换过程中适当的将事件监听器和子组件适当地被销毁和重建</li>
<li>v-if 是惰性的, 如果在初始渲染时条件为假, 元素便不会渲染, 只到条件第一次为真时, 才会开始渲染</li>
<li>v-show 不管初始条件是什么, 元素总是会被渲染, 并且只是基于 CSS 进行切换</li>
</ul>
<h2 id="v-if-与-v-show-一起使用"><a href="#v-if-与-v-show-一起使用" class="headerlink" title="v-if 与 v-show 一起使用"></a>v-if 与 v-show 一起使用</h2><p>当<code>v-if</code>与<code>v-for</code>一起使用时, <code>v-for</code>具有比<code>v-if</code>更高的优先级</p>
<blockquote>
<p>不推荐同时使用 <code>v-if</code> 和 <code>v-else</code></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中class与style绑定</title>
    <url>/2020/02/03/vue%E4%B8%ADclass%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><p>Vue 对于 class 和 style 上使用<code>v-bind</code>做了专门的增强, 表达式结果的类型除了字符串之外, 还可以是对象或数组</p>
<h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>我们可以传给<code>v-bind:class</code>一个对象, 以动态的切换 class.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 传递一个对象 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;&#123; box: showBox, box1: showBox &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- class 与 绑定对象共存 --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; :class&#x3D;&quot;&#123; box1: showBox &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 接受一个对象 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;classObj&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 接受一个计算属性 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;isShowBox&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showBox: true,</span><br><span class="line">      classObj: &#123;</span><br><span class="line">        box: true,</span><br><span class="line">        box1: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isShowBox() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        box: true,</span><br><span class="line">        box1: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.box1 &#123;</span><br><span class="line">  width: 60px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>我们还可以把一个数组传给 <code>v-bind:class</code>, 应用一个 class 列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 接受一个数组 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;clsasArr&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用表达式 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;[...clsasArr]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 使用三元表达式 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;[showBox ? &#39;box&#39; : &#39;&#39;]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 对象与数组同时使用 --&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;[&#123; box: showBox &#125;, &#39;box1&#39;]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showBox: true,</span><br><span class="line">      clsasArr: [&#39;box&#39;, &#39;box1&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.box1 &#123;</span><br><span class="line">  width: 60px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用于组件上"><a href="#用于组件上" class="headerlink" title="用于组件上"></a>用于组件上</h3><p>当我们在一个自定义组件上使用 <code>class</code> 属性时, 这些 class 将被添加到该组件的根元素上, 这个元素上已存在的 class 不会被覆盖</p>
<h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 内联样式 --&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">      class&#x3D;&quot;box&quot;</span><br><span class="line">      :style&#x3D;&quot;&#123; width: width + &#39;px&#39;, height: height + &#39;px&#39; &#125;&quot;</span><br><span class="line">    &gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 直接传入对象 --&gt;</span><br><span class="line">    &lt;div :style&#x3D;&quot;style&quot;&gt;box&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      width: 100,</span><br><span class="line">      height: 100,</span><br><span class="line">      style: &#123;</span><br><span class="line">        backgroundColor: &#39;pink&#39;,</span><br><span class="line">        color: &#39;#000&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">div.box &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div :style&#x3D;&quot;arr&quot;&gt;box&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HelloWorld&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr: [&#123; color: &quot;red&quot; &#125;, &#123; border: &quot;1px solid red&quot; &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。</p>
<h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue计算属性与侦听器</title>
    <url>/2020/02/03/vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>虽然我们可以在模板内使用表达式, 但是设计初衷是用于简单的运算, 如果在模板中放入太多的逻辑会让模板过重难以维护</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message.split('').reverse().join() &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算属性message: &#123;&#123; newMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        message: <span class="string">'Hello World'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      newMessage() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.message</span></span><br><span class="line"><span class="actionscript">          .split(<span class="string">''</span>)</span></span><br><span class="line">          .reverse()</span><br><span class="line"><span class="actionscript">          .join(<span class="string">''</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>如果我们在<code>methods</code>中定义方法, 在模板中调用, 一样可以实现这个功能<br>不同的是, 计算属性是基于他们的响应式依赖进行缓存的, 只有在相关响应式依赖发生改变时他们才会重新计算求值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算属性message: &#123;&#123; reverseStr() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        message: <span class="string">'Hello World'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      reverseStr() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.message</span></span><br><span class="line"><span class="actionscript">          .split(<span class="string">''</span>)</span></span><br><span class="line">          .reverse()</span><br><span class="line"><span class="actionscript">          .join(<span class="string">''</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="计算属性的-getter"><a href="#计算属性的-getter" class="headerlink" title="计算属性的 getter"></a>计算属性的 getter</h3><p>计算属性默认只有 getter, 不过我们在需要时也可以提供一个 setter:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; firstName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; lastName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"fullNmae"</span>&gt;</span>&#123;&#123; fullNmae &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"()=&gt;&#123;fullNmae = 'Hi,Ginger'&#125;"</span>&gt;</span>update fullName<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        firstName: <span class="string">'Hello'</span>,</span></span><br><span class="line"><span class="actionscript">        lastName: <span class="string">'World'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullNmae: &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">get</span>() &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">set</span>(newVal) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> arr = newVal.split(<span class="string">','</span>)</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.firstName = arr[<span class="number">0</span>]</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.lastName = arr[<span class="number">1</span>]</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>Vue 通过<code>watch</code>选项提供了一个可自定义的侦听器来响应数据的变化, 当需要在数据变化时执行异步或开销较大的操作时, 适合使用过</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span>page++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        content: <span class="string">''</span>, <span class="comment">// 页面内容</span></span></span><br><span class="line"><span class="actionscript">        page: <span class="number">1</span> <span class="comment">// 页码</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onClick() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.page++</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      page(newVal) &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 根据页码发起数据请求 获取最新页数数据</span></span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动: <code>侦听属性</code>.<br>不过官方更推荐使用计算属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        firstName: <span class="string">'Hello'</span>,</span></span><br><span class="line"><span class="actionscript">        lastName: <span class="string">'World'</span>,</span></span><br><span class="line"><span class="actionscript">        fullName: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.firstName = <span class="string">'Hello'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 侦听器实现 重复代码</span></span></span><br><span class="line">    watch: &#123;</span><br><span class="line">      firstName(val) &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> (<span class="keyword">this</span>.fullName = val + <span class="keyword">this</span>.lastName)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      lastName(val) &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> (<span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + val)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 计算属性实现 更简洁</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullName() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue模板语法</title>
    <url>/2020/02/02/vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p><code>Vue.js</code> 使用基于<code>html</code>的模板语法, 在底层上, <code>Vue</code>将模板编译成虚拟 DOM 渲染函数, 结合响应系统, 减少 DOM 操作次数</p>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>数据绑定最常用形式, 使用 Mustache 语法(双大括号)的文本插值<br>Mustache 标签会替换为对应数据对象上 msg 属性的值, 只要数据对象上 msg 属性发生了改变, 页面插值处内容也会更新</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>通过使用 v-once 指令, 可以实现一次性的插值, 当数据改变时, 插值处内容不会更新</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>这个值不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h3><p>双大括号会将数据编译为普通文本, 如果想要输出 HTML, 需要使用 <code>v-html</code> 指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>数据编译为普通文本 &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>数据编译为HTML内容 <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h3><p>Mustache 语法不能作用在 HTML attribute 上, 但是 Vue 给我们提供了<code>v-bind</code>指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"ID"</span>&gt;</span>绑定 id<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-表达式"><a href="#JavaScript-表达式" class="headerlink" title="JavaScript 表达式"></a>JavaScript 表达式</h3><blockquote>
<p>每个绑定只能包含单个表达式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'this-' + ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有 <code>v-</code> 前缀的的特殊 attribute. 指令的作用是, 当表达式中的值发生变化时, 将其产生的连带影响, 响应式的作用于 DOM</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span>v-if绑定的值控制着此 div 元素的插入与移除<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>部分指令可以接受一些’参数’, 在指令名称之后以冒号表示. 例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- href是参数 表示将href的值与url进行绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- click是参数 表示监听的事件名与事件处理函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"onClick"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此处的 attributeName 会被作为一个 JavaScript 表达式进行动态求值 求值结果将会作为最终的参数来使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符是以<code>.</code>为后缀指明的, 用于指出一个指令应该以特殊方式绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此处的 prevent 相当于在处理事件中添加 event.preventDetafult --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>对于一些频繁使用的指令, <code>Vue</code>为<code>v-bind</code>和<code>v-on</code>这两个最常用的指令, 提供了特定简写:</p>
<ul>
<li>v-bind</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完成写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-on</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实例</title>
    <url>/2020/02/02/vue%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h2><p>Vue 实例通过 <code>new</code> 一个 <code>Vue</code> 函数得到<br>在创建一个 <code>Vue</code> 实例的时候, 我们可以通过传入一个<strong>选项对象</strong>来构建我们需要的行为.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 <code>Vue</code> 实例被创建时, 它会将 <code>data</code> 对象中所有的属性加入到 <code>Vue</code> 的响应式系统中, 当他们发生改变时, 视图将会产生响应, 进行更新</p>
<blockquote>
<p>data 中数据只有在实例创建时就已存在的属性才是响应式的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据对象加入到 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'app'</span></span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例上的属性 返回源数据中对应的字段</span></span><br><span class="line">vm.name == data.a <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.name = <span class="string">'Ginger'</span></span><br><span class="line">data.a <span class="comment">// Ginger</span></span><br></pre></td></tr></table></figure>

<p><code>Vue</code> 实例暴露了一系列内置实例属性与方法, 他们都有*<strong>*$**</strong> 前缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$data === data <span class="comment">// true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p><code>Vue</code> 实例在创建时, 需要经过一系列的初始化过程, 在这个过程中, 会运行一些叫做<strong>生命周期钩子</strong>的函数, 这些钩子函数为用户提供了在实例创建过程中添加自己代码的机会</p>
<blockquote>
<p>生命周期钩子中的<code>this</code>上下文指向调用他的<code>vue</code>实例<br>不要使用箭头函数</p>
</blockquote>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><ul>
<li>beforeCreate 实例创建前</li>
<li>created 实例创建后</li>
<li>beforeMount 挂载前</li>
<li>Mounted 挂载完毕</li>
<li>beforeupdate 实例数据更新前</li>
<li>updated 数据更新完毕</li>
<li>beforeDestroy 实例销毁前</li>
<li>destroyed 实例销毁完毕</li>
</ul>
<h3 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h3><p><img data-src="../image/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue安装使用</title>
    <url>/2020/02/02/vue%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools"></a>Vue Devtools</h2><p><a href="https://github.com/vuejs/vue-devtools#vue-devtools" target="_blank" rel="noopener">Devtools</a> 是一个 Vue 官方提供的浏览器插件, 他可以让我们在开发过程中国更直观更友好的的在浏览器中对 Vue 项目进行审查和调试</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Vue 分为开发版本和生产版本</p>
<ul>
<li>开发版本 - 包含完整的警告和调试模式</li>
<li>生产版本 - 删除了警告</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="直接引入-本地文件或-CDN"><a href="#直接引入-本地文件或-CDN" class="headerlink" title="直接引入(本地文件或 CDN)"></a>直接引入(本地文件或 CDN)</h3><p>在 html 文件中, 我们如果需要使用 Vue 可以直接使用 script 标签进行引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最新版本 适合开发环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定版本 适合生产环境追溯问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.11"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>在使用 Vue 开发大型应用时, 推荐使用 NPM 安装, NPM 能够很好的与 webpack 配合使用.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install vue</span></span><br></pre></td></tr></table></figure>

<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create hello-word</span><br></pre></td></tr></table></figure>

<p>Vue 提供了一个官方的 Cli, 为单页面应用(SPA)快速搭建繁杂的脚手架.</p>
<ul>
<li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">Cli GitHub</a></li>
<li><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Cli 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2020/01/26/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote>
<p>装饰器模式是指在不改变原有对象的基础上, 对其进行包装扩展, 使其满足用户更复杂的需求.</p>
</blockquote>
<h2 id="复习下单例模式"><a href="#复习下单例模式" class="headerlink" title="复习下单例模式"></a>复习下单例模式</h2><p>使用单例模式维护一个全局的 Modal</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      div &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 1px solid pink;</span><br><span class="line">        color: pink;</span><br><span class="line">        position: fixed;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"open"</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"hidden"</span>&gt;</span>hidden<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> Modal = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> modal = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">          if (!modal) &#123;</span><br><span class="line"><span class="javascript">            modal = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="actionscript">            modal.style.display = <span class="string">'none'</span></span></span><br><span class="line"><span class="actionscript">            modal.innerText = <span class="string">'Modal'</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(modal)</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> modal</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">        <span class="string">'click'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(modal)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          modal.style.display = <span class="string">'block'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="literal">false</span></span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'hidden'</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">        <span class="string">'click'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="actionscript">          modal.style.display = <span class="string">'none'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="literal">false</span></span></span><br><span class="line">      )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>这时候产品经理说, 需要修改下这个按钮文字内容, 还要给点击按钮置灰, 不可点击, 如果我们在项目多处用到的话, 就需要一处处进行修改<br>如果封装成公共组件, 也会因为组件应用时的需求复杂度而产生同样的问题</p>
<h2 id="装饰器模式改造案例"><a href="#装饰器模式改造案例" class="headerlink" title="装饰器模式改造案例"></a>装饰器模式改造案例</h2><p>第一步 抽离原有旧逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原有对象保持不变</span></span><br><span class="line"><span class="keyword">const</span> Modal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modal = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!modal) &#123;</span><br><span class="line">      modal = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      modal.style.display = <span class="string">'none'</span></span><br><span class="line">      modal.innerText = <span class="string">'Modal'</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(modal)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openModal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 封装显示模态框逻辑</span></span><br><span class="line">  <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span><br><span class="line">  <span class="keyword">if</span> (modal) &#123;</span><br><span class="line">    modal.style.display = <span class="string">'block'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步 封装新需求逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeBtnText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 封装按钮文字修改逻辑</span></span><br><span class="line">  <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>)</span><br><span class="line">  btn.innerText = <span class="string">'快点我'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disabledBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 封装按钮可否点击逻辑</span></span><br><span class="line">  <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>)</span><br><span class="line">  btn.setAttribute(<span class="string">'disabled'</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeBtnStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 整和所有封装</span></span><br><span class="line">  changeBtnText()</span><br><span class="line">  disabledBtn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步 添加需求到点击按钮上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    openModal()</span><br><span class="line">    changeBtnStatus()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="ES6-class-类实现装饰器"><a href="#ES6-class-类实现装饰器" class="headerlink" title="ES6 class 类实现装饰器"></a>ES6 class 类实现装饰器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class 单例模式 modal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.modal = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getModal() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.modal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.modal = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      <span class="keyword">this</span>.modal.innerText = <span class="string">'我是一个class单例模式下的div'</span></span><br><span class="line">      <span class="keyword">this</span>.modal.style.display = <span class="string">'none'</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.modal)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.modal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">openModal</span> </span>&#123;</span><br><span class="line">  click() &#123;</span><br><span class="line">    <span class="keyword">const</span> modal = Modal.getModal()</span><br><span class="line">    modal.style.display = <span class="string">'block'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(open_button) &#123;</span><br><span class="line">    <span class="keyword">this</span>.open_btn = open_button</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onclick() &#123;</span><br><span class="line">    <span class="comment">// 职责单一</span></span><br><span class="line">    <span class="keyword">this</span>.open_btn.click()</span><br><span class="line">    <span class="keyword">this</span>.changeBtnStatus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeBtnStatus() &#123;</span><br><span class="line">    <span class="keyword">this</span>.changeBtnText()</span><br><span class="line">    <span class="keyword">this</span>.disabledBtn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeBtnText() &#123;</span><br><span class="line">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>)</span><br><span class="line">    btn.innerText = <span class="string">'来点击我啊'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disabledBtn() &#123;</span><br><span class="line">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'open'</span>)</span><br><span class="line">    btn.setAttor = <span class="string">'来点击我啊'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> openBtn = <span class="keyword">new</span> openModal()</span><br><span class="line">    <span class="keyword">const</span> btn = <span class="keyword">new</span> Decorator(openBtn)</span><br><span class="line">    btn.onclick()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/01/25/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>在 JavaScript 中, Object.create() 是对原型模式的最好实现.</p>
</blockquote>
<h2 id="prototype-原型模式的应用"><a href="#prototype-原型模式的应用" class="headerlink" title="prototype 原型模式的应用"></a>prototype 原型模式的应用</h2><blockquote>
<p>JavaScript 中不存在 class , ES6 中 class 也只是原型继承的语法糖, 在 js 中我们常用的是通过 prototype 模拟类来得到类的实例, 实现实例间数据、方法的共享.</p>
</blockquote>
<h2 id="JavaScript-的原型与原型链"><a href="#JavaScript-的原型与原型链" class="headerlink" title="JavaScript 的原型与原型链"></a>JavaScript 的原型与原型链</h2><p>在 JavaScript 中, 创建一个对象有多种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Object 构造函数创建对象</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">// 通过 create 创建对象</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.create(&#123;&#125;)</span><br><span class="line"><span class="comment">// 字面量方式创建对象</span></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;<span class="attr">name</span>: <span class="string">'Ginger'</span>&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 JavaScript 中每一个构造函数都有一个 prototype 属性, 该原型对象指向构造函数的原型对象, 原型对象中 construtor 指回该构造函数</li>
<li>每个实例对象, 都有一个 <code>__proto__</code> 属性, 该属性指向创建该实例对象的构造函数的原型对象</li>
</ul>
<p>通过 new 关键字, 获得 Fn 构造函数的实例对象, f 实例对象上并没有 hi 方法, 但是我们可以调用成功, 便是因为原型链的存在.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.hi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Fn()</span><br><span class="line">f.hi() <span class="comment">// Hi</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__ === Fn.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="一个简单的深拷贝"><a href="#一个简单的深拷贝" class="headerlink" title="一个简单的深拷贝"></a>一个简单的深拷贝</h2><p>通过两个 api 对 obj 对象进行拷贝, 得到 obj2 改变 obj2 后, obj 内容未发生改变, 但是如果 obj 不是一个严格 json 格式的数据, 他的值是还是一个对象的时候, 这个就无法处理了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'Ginger'</span>,</span><br><span class="line">  age:<span class="number">24</span>,</span><br><span class="line">  web:[<span class="string">'html'</span>, <span class="string">'js'</span>, <span class="string">'css'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">obj2.web.splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj.web) <span class="comment">// ['html', 'js', 'css']</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.web) <span class="comment">// ["js", "css"]</span></span><br></pre></td></tr></table></figure>

<h2 id="另外一个深拷贝"><a href="#另外一个深拷贝" class="headerlink" title="另外一个深拷贝"></a>另外一个深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 边界判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化结果值</span></span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是数组</span></span><br><span class="line">  <span class="keyword">if</span>(obj.constructor === <span class="string">'array'</span>) &#123;</span><br><span class="line">    res = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="comment">// 如果值是对象 递归调用</span></span><br><span class="line">      res[i] = DeepClone(obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/01/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例模式下的类只能存在一个实例对象</p>
</blockquote>
<h2 id="非单例模式实例"><a href="#非单例模式实例" class="headerlink" title="非单例模式实例"></a>非单例模式实例</h2><p>在 JavaScript 中, 我们可以通过 class 类来实例化对象, 我们 new 出两个对象, 但是两个对象是没有直接关联的, 他们储存在不同的内存地址中, 不符合我们的单例模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'单例对象'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Singleton()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Singleton()</span><br><span class="line">s1 === s2 <span class="comment">// false 引用类型储存在堆的不同内存地址中</span></span><br></pre></td></tr></table></figure>

<h2 id="单例模式实例"><a href="#单例模式实例" class="headerlink" title="单例模式实例"></a>单例模式实例</h2><p>如果要实现单例模式, 我们需要保证只能存在一个实例对象, 这就要求我们的类具有是否已存在实例对象的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类 - 静态方法模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    consle.log(<span class="string">'我是一个单例对象'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">    <span class="comment">// 静态方法 重点</span></span><br><span class="line">    <span class="keyword">if</span>(!Singleton.instance)&#123;</span><br><span class="line">      <span class="comment">// 判断是否已存在一个实例</span></span><br><span class="line">      Singleton.instance = <span class="keyword">new</span> Singleton() <span class="comment">// 如果没有就创建一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Singleton.instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包实现单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Singleton.prototype.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance <span class="comment">// 定义局部变量模拟 重点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="单例模式应用"><a href="#单例模式应用" class="headerlink" title="单例模式应用"></a>单例模式应用</h2><p>通过单例模式管理全局唯一存在的一个 Model 模态框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      div &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        line-height: 200px;</span><br><span class="line">        border: 1px solid pink;</span><br><span class="line">        color: pink;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"show"</span>&gt;</span>显示全局模拟框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"hidden"</span>&gt;</span>隐藏全局模拟框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showbtn = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> hiddenbtn = <span class="built_in">document</span>.getElementById(<span class="string">'hidden'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 闭包实现</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> Modal = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> modal = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            if (!modal) &#123;</span><br><span class="line"><span class="javascript">              modal = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="actionscript">              modal.innerText = <span class="string">'我一个单例的模态框'</span></span></span><br><span class="line"><span class="actionscript">              modal.style.display = <span class="string">'none'</span></span></span><br><span class="line"><span class="actionscript">              modal.style.color = <span class="string">'pink'</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">document</span>.body.appendChild(modal)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> modal</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)()</span><br><span class="line"></span><br><span class="line">        showbtn.addEventListener(</span><br><span class="line"><span class="actionscript">          <span class="string">'click'</span>,</span></span><br><span class="line"><span class="actionscript">          <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="actionscript">            modal.style.display = <span class="string">'block'</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="literal">false</span></span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        hiddenbtn.addEventListener(</span><br><span class="line"><span class="actionscript">          <span class="string">'click'</span>,</span></span><br><span class="line"><span class="actionscript">          <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="actionscript">            modal.style.display = <span class="string">'none'</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="literal">false</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2020/01/23/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>在实际的项目开发时, 我们面对的往往不是如此简单的工厂, 而是会面对多个工厂.</p>
<p>在简单工厂模式中, 如果我们再加入学生会干部, 就意味着我们需要修改我们的工厂函数. 长此以往, 我们的工厂函数会变得复杂臃肿.</p>
<p>回顾我们设计模式的<strong>开放封闭原则, 对扩展开放, 对修改封闭</strong> 而我们添加其他判断逻辑则是在修改它.</p>
<p>所以我们需要一个更加合理的方式来处理</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>由于抽象最初源于 Java 等强类型静态语言, 在设计初期, 往往就需要关注类型解耦. 而 JavaScript 是一个动态类型的语言, 天然具有多态性, 但目前的 JavaScript 语法里，不支持抽象类的直接实现, 所以我们只能模拟抽象类.</p>
<h2 id="实现一个生产手机的抽象工厂"><a href="#实现一个生产手机的抽象工厂" class="headerlink" title="实现一个生产手机的抽象工厂"></a>实现一个生产手机的抽象工厂</h2><p>一个手机生产线</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂-只对类抽象的对象基本组成进行约束</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  createOs() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂创建软件系统方法, 需要重写'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  createHardware() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂创建硬件方法, 需要重写'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂-实现具体功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  createOs() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IOS()</span><br><span class="line">  &#125;</span><br><span class="line">  createHardware() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MI()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象出系统部分的抽象工厂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象手机系统工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂, 不允许直接调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体运行系统工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ios</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用ios系统方式启动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用安卓系统启动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象出硬件的抽象工厂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象硬件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂方法, 不允许直接调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">extends</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'使用小米硬件'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUAWEI</span> <span class="keyword">extends</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'使用华为硬件'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始生产手机</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> phone = <span class="keyword">new</span> FakeStarFactory() <span class="comment">// 生产手机</span></span><br><span class="line"><span class="keyword">const</span> phoneOs = phone.createOs() <span class="comment">// 加上系统</span></span><br><span class="line"><span class="keyword">const</span> phonrHardware = phone.createHardware() <span class="comment">// 加上硬件</span></span><br><span class="line">phonrHardware.operating() <span class="comment">// 选择硬件</span></span><br><span class="line">phoneOs.run() <span class="comment">// 运行系统</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2020/01/22/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>构造器模式</li>
<li>简单工厂模式</li>
</ul>
<h2 id="构造器模式-抽象每个对象的变与不变"><a href="#构造器模式-抽象每个对象的变与不变" class="headerlink" title="构造器模式-抽象每个对象的变与不变"></a>构造器模式-抽象每个对象的变与不变</h2><p>你正在开发一个学生管理系统, 开发时只有自己, 于是创建自己的用户信息:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">const</span> zhangsan = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了两天, 你的同事过来说让你加上他的用户信息, 他要使用用户信息, 于是你:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">const</span> zhangsan = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lisi = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了两个星期,产品经理跟你说, 我这里有一点点(1000 个)测试数据, 你给我录入下, 于是你写了个构造函数(构造器)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Students</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 此处省略读取数据, 遍历调用构造器</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Students(name, age, gender)</span><br></pre></td></tr></table></figure>

<h3 id="思考-变与不变"><a href="#思考-变与不变" class="headerlink" title="思考 变与不变"></a>思考 变与不变</h3><p>不变的是每个学生都有姓名、年龄、性别三个属性,这叫<strong>共性</strong><br>变化的是三个属性的值,这叫<strong>个性</strong></p>
<blockquote>
<p>案例中构造器在整个过程中就是抽象了学生这个对象, 将赋值的过程进行了封装, 确定不变的部分, 使每个学生对象都有自己的姓名、年龄、性别三个属性, 在确保不变的同时, 将变化的三个属性的值进行开放, 由用户自己传入, 保证了个性的灵活度</p>
</blockquote>
<h2 id="工厂模式-抽象不同构造器之间的变与不变"><a href="#工厂模式-抽象不同构造器之间的变与不变" class="headerlink" title="工厂模式-抽象不同构造器之间的变与不变"></a>工厂模式-抽象不同构造器之间的变与不变</h2><p>第一期交付后一个月, 学校方面打来电话, 表示要对学生中的班干部进行区分, 备注班干部职责, 于是你加了一个班干部的构造器用来生成班干部的信息,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Students</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 普通学生</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">  <span class="keyword">this</span>.identity = <span class="string">'student'</span></span><br><span class="line">  <span class="keyword">this</span>.duties = [<span class="string">'学习'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cadres</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 班干部</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">  <span class="keyword">this</span>.identity = <span class="string">'cadre'</span></span><br><span class="line">  <span class="keyword">this</span>.duties = [<span class="string">'点名'</span>,<span class="string">'出黑板报'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候, 你发现又出现了 <strong>变数</strong> identity, 你还需要一个方法来判断调用哪一个构造器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name, age, gender, identity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(identity) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'student'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Students(name, age, gender)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cadre'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Cadres(name, age, gender)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 此处省略无数个班干部</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完后, 你发现每类班干部职责实在太多了, 难道要写几十个构造器么</p>
<h3 id="重新思考-变与不变"><a href="#重新思考-变与不变" class="headerlink" title="重新思考 变与不变"></a>重新思考 变与不变</h3><p>在我们的学生与班干部两个构造器中, 都拥有不变的姓名、年龄、性别三个共性, 变化是的身份与职责, 由此可以看出我们的问题, 共性封装不够、共性与个性分离不彻底, 于是我们重新封装下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, gender, identity, duties</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="keyword">this</span>.identity = identity</span><br><span class="line">  <span class="keyword">this</span>.duties = duties</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name, age, gender, identity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> duties</span><br><span class="line">  <span class="keyword">switch</span>(identity)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'student'</span>:</span><br><span class="line">      duties = [<span class="string">'学习'</span>,<span class="string">'做作业'</span>]</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cadre'</span>:</span><br><span class="line">      duties = [<span class="string">'组织活动'</span>,<span class="string">'点名'</span>]</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age, gender, identity, duties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>工厂模式就是对创建对象的过程进行封装, 我们不需要在关心封装内做的事情,只需要拿到工厂交付给我们的结果即可.</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概况</title>
    <url>/2020/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%86%B5/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
</blockquote>
<blockquote>
<p>设计模式是一套现成的工具, 拿来即可用. 就像电饭锅、洗衣机, 不用关心电饭锅、洗衣机的制作原理, 只需将需要的特定事物放入, 即可得到想要的结果.</p>
</blockquote>
<h2 id="JavaScript-主要设计原则–面向对象编程和面向对象设计"><a href="#JavaScript-主要设计原则–面向对象编程和面向对象设计" class="headerlink" title="JavaScript 主要设计原则–面向对象编程和面向对象设计"></a>JavaScript 主要设计原则–面向对象编程和面向对象设计</h2><ul>
<li>单一功能原则</li>
<li>开放封闭原则</li>
</ul>
<h2 id="核心思想–封装变化"><a href="#核心思想–封装变化" class="headerlink" title="核心思想–封装变化"></a>核心思想–封装变化</h2><p>一个简单的产品流程节点可以分为:</p>
<pre><code>想法 -&gt; 需求 -&gt; 设计 -&gt; 开发 -&gt; 测试 -&gt; 部署 -&gt; 产品</code></pre><p>&nbsp;&nbsp;通过上面的关键节点可以看出, 影响一个产品的复杂程度的主要节点是需求与设计, 在抛开个人能力不谈的时候, 设计的复杂程度取决于需求的复杂程度, 所以我们可以说需求是一个产品复杂程度的”罪魁祸首”, 而需求对于开发人员来说, 往往就是<strong>变化</strong></p>
<p>在实际开发过中, 我们需要做的就是将变化造成的影响 <strong>最小化</strong>.</p>
<pre><code>-- 将变与不变分离, 保证变化部分的灵活性, 保证不变部分的稳定性.</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组与函数</title>
    <url>/2020/01/06/js%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0-1/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">知识点 - 数组 - 函数 - 作用域 - 作用域链</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组:一组有序的数据</span></span><br><span class="line"><span class="comment">// 数组的作用:可以一次性储存多个数据</span></span><br><span class="line"><span class="comment">// 数组元素:数组中存储的每个数据,都可以叫数组的元素,比如:存储了3个数据,数组中3个元素</span></span><br><span class="line"><span class="comment">// 数组长度:就是数组的元素的个数,比如有3个元素,就说,这个数组的长度是3</span></span><br><span class="line"><span class="comment">// 数组索引(下标):用来存储或者访问数组中的数据的,索引从0开始,到长度减1结束</span></span><br><span class="line"><span class="comment">// 数组的索引和数组的长度的关系:长度减1就是最大的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、构造函数创建数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()   <span class="comment">// 定义了一个叫arr的空数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)  <span class="comment">// 定义了一个长度为10的数组，数组中每个数据为undefiend</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、字面量方式创建数组</span></span><br><span class="line"><span class="keyword">var</span> arr = []  <span class="comment">// 创建了一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment">// 创建了一个数组并赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中所有值</span></span><br><span class="line"><span class="built_in">console</span>.Log(arr)  <span class="comment">// 打印数组与值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123; <span class="comment">// 循环遍历获取数组中所有元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置数组的值</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">100</span>  <span class="comment">// 设置数组中下标为1的元素为100</span></span><br><span class="line"><span class="comment">// 获取数组中某个位置的值</span></span><br><span class="line"><span class="keyword">var</span> result = arr[<span class="number">1</span>]  <span class="comment">// 获取数组中下标为1的元素</span></span><br><span class="line"><span class="comment">// 获取数组的长度</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length）  <span class="comment">// 打印arr数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结数组</span></span><br><span class="line"><span class="comment">// 数组:存储一组有序的数据</span></span><br><span class="line"><span class="comment">// 数组的作用:一次性存储多个数据</span></span><br><span class="line"><span class="comment">// 数组的定义方式:</span></span><br><span class="line"><span class="comment">// 1.构造函数定义数组: var 数组名=new Array();</span></span><br><span class="line"><span class="comment">// 2.字面量方式定义数组: var 数组名=[];</span></span><br><span class="line"><span class="comment">// var 数组名=new Array();空数组</span></span><br><span class="line"><span class="comment">// var 数组名=new Array(值);数组定义了,有长度</span></span><br><span class="line"><span class="comment">// var 数组名=new Array(值1,值2,值3....);定义数组并且有多个数据</span></span><br><span class="line"><span class="comment">// var 数组名=[];空数组</span></span><br><span class="line"><span class="comment">// var 数组名=[值1,值2,值3];有三个数据</span></span><br><span class="line"><span class="comment">// 数组元素:就是数组中存储的数据</span></span><br><span class="line"><span class="comment">// 数组长度:就是数组中元素的个数</span></span><br><span class="line"><span class="comment">// 数组索引(下标):从0开始,到数组的长度减1结束</span></span><br><span class="line"><span class="comment">// 通过下标设置数组的元素值: 数组名[索引]=值</span></span><br><span class="line"><span class="comment">// 通过下标访问数组的元素值: 数组名[索引]</span></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把数据按照一定的顺序排列(从小到大或从大到小)</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = arr[j]</span><br><span class="line">      arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">      arr[j + <span class="number">1</span>] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数：把重复的代码进行封装，在需要的时候直接调用函数即可。</span></span><br><span class="line"><span class="comment">// 函数作用：代码的重用(重复使用)</span></span><br><span class="line"><span class="comment">// 函数也是一种数据类型 --&gt; function 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名函数(有名字的函数叫命名函数)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 使用function关键字定义了一个叫fn的函数 --&gt; 函数声明</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数体--&gt;重复的代码'</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 函数的调用--&gt;执行函数体中的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数(函数如果没名字，就是匿名函数)</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 函数表达式</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'匿名函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line">f2() <span class="comment">// 匿名函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的自调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数的自调用'</span>)</span><br><span class="line">&#125;)()； <span class="comment">// 函数声明的同时就调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="comment">// 如果一个函数作为参数，那么这个参数(函数)，可以叫做回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f3'</span>)</span><br><span class="line">&#125;</span><br><span class="line">f2(f3) <span class="comment">// 将 f3 函数作为参数传入 f2 函数，在 f2 函数内部执行 f3 函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参与实参</span></span><br><span class="line"><span class="comment">// 函数在定义时，函数名后面的小括号里面的变量叫形参</span></span><br><span class="line"><span class="comment">// 函数在调用时，函数名后面的小括号里面的变量或值叫实参</span></span><br><span class="line"><span class="comment">// 函数返回值，在函数内部有return关键字,并且在关键字后面有内容,这个内容被返回了</span></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; <span class="comment">// 形参</span></span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2</span><br><span class="line">    <span class="built_in">console</span>.log(sum)  <span class="comment">// 打印结果 30</span></span><br><span class="line">    <span class="keyword">return</span> sum	<span class="comment">// return 关键字 函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = sum(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// (10,20)-&gt;实参 result-&gt;接受函数返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象伪数组</span></span><br><span class="line"><span class="comment">// 如果一个函数不确定用户是否传入了参数，或者不知道传入了几个参数，可以使用 arguments 进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// arguments对象可以获取传入的每个参数的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length) <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]) <span class="comment">// 输出每个实参的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小结函数</span></span><br><span class="line"><span class="comment">// 如果一个函数中有return ,那么这个函数就有返回值</span></span><br><span class="line"><span class="comment">// 如果一个函数中没有return,那么这个函数就没有返回值</span></span><br><span class="line"><span class="comment">// 如果一个函数中没有明确的返回值,那么调用的时候接收了,结果就是undefined</span></span><br><span class="line"><span class="comment">// 没有明确返回值:函数中没有return,函数中有return,但是return后面没有任何内容</span></span><br><span class="line"><span class="comment">// 函数没有返回值,但是在调用的时候接收了,那么结果就是undefined</span></span><br><span class="line"><span class="comment">// 变量声明了,没有赋值,结果也是undefined</span></span><br><span class="line"><span class="comment">// 如果一个函数有参数,有参数的函数</span></span><br><span class="line"><span class="comment">// 如果一个函数没有参数,没有参数的函数</span></span><br><span class="line"><span class="comment">// 形参的个数和实参的个数可以不一致</span></span><br><span class="line"><span class="comment">// return 下面的代码是不会执行的</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用域：使用范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量：在函数外部使用 var 关键字定义的变量。</span></span><br><span class="line"><span class="comment">// 局部变量：在函数内部定义的变量是局部变量，外面不能使用。</span></span><br><span class="line"><span class="comment">// 隐式全局变量：在函数内部没有使用 var 定义的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局作用域：全局变量的使用范围</span></span><br><span class="line"><span class="comment">// 局部作用域：局部变量的使用范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">100</span> <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">200</span> <span class="comment">// 局部变量</span></span><br><span class="line">  num3 = <span class="number">300</span> <span class="comment">// 隐式全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// undefiend</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">    f3()</span><br><span class="line">  &#125;</span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 打印输出 10 一层一层往上寻找 num 的值</span></span><br></pre></td></tr></table></figure>

<h3 id="预解析-变量-函数-提升"><a href="#预解析-变量-函数-提升" class="headerlink" title="预解析(变量(函数)提升)"></a>预解析(变量(函数)提升)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预解析:提前解析代码，提升变量的声明与函数的声明</span></span><br><span class="line"><span class="comment">// 预解析做什么事?</span></span><br><span class="line"><span class="comment">// 把变量的声明提前了----提前到当前所在的作用域的最上面</span></span><br><span class="line"><span class="comment">// 函数的声明也会被提前---提前到当前所在的作用域的最上面</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 打印 undefined 不报错</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">f1() <span class="comment">// 打印 '函数预解析'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'函数预解析'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// var num1 等价于增加了此行代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 变量提升到了作用域最上面 --&gt; 输出 undefined</span></span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预解析小结</span></span><br><span class="line"><span class="comment">// 预解析中,变量的提升,只会在当前的作用域中提升,提前到当前的作用域的最上面</span></span><br><span class="line"><span class="comment">// 函数中的变量只会提前到函数的作用域中的最前面,不会出去</span></span><br><span class="line"><span class="comment">// 预解析会分段(多对的script标签中函数重名,预解析的时候不会冲突)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组与函数</title>
    <url>/2020/01/04/js%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">知识点: -分支 - 循环</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流程控制：控制代码的执行过程</span></span><br><span class="line"><span class="comment">// 1、顺序结构:从上到下，从左到右执行的顺序，就是顺序结构（不严谨）</span></span><br><span class="line"><span class="comment">// 2、分支结构：if语句、if-else语句、switch-case语句</span></span><br><span class="line"><span class="comment">// 3、循环结构：while循环、do-while循环、for循环、for-in循环</span></span><br></pre></td></tr></table></figure>

<h3 id="分支语句-主要用于判断"><a href="#分支语句-主要用于判断" class="headerlink" title="分支语句-主要用于判断"></a>分支语句-主要用于判断</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if语句-（如果）</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1是小于3的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 先判断表达式结果是否成立（true/false），如果是true则执行代码块，如果是false，大括号中的代码不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if-else语句-(如果，否则)</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1小于3'</span>) <span class="comment">// 代码1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1大于3'</span>) <span class="comment">// 代码2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 如果表达式结果成立（true/false）,这执行代码1，如果表达式结果是false，这执行代码2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元表达式</span></span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">1</span> &lt; <span class="number">3</span> ? <span class="string">'小于'</span> : <span class="string">'不小于'</span></span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 表达式(1&lt;3)的结果是true还是false，如果是true，则result = '小于'，如果是false，则result = '不小于'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if-else if-else if-else</span></span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>) &#123;</span><br><span class="line">  代码<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">2</span>) &#123;</span><br><span class="line">  代码<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">3</span>) &#123;</span><br><span class="line">  代码<span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  代码<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先判断表达式1的结果，如果为true，则执行代码1，如果是false，再判断表达式2的结果，如果为true就执行代码2，如果是false再判断表达式3的结果，如果为true就执行代码3，如果上面表达式都是false，就执行代码4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case语句</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    代码<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 获取表达式的值，和值1比较，如果一样，就执行代码1，遇到break，跳出整个语句。后面代码不执行，</span></span><br><span class="line"><span class="comment">// 如果和值1不一样，就和值2比较，然后执行代码2，遇到break，跳出整个语句，后面代码不执行。</span></span><br><span class="line"><span class="comment">// 以此类推。。。</span></span><br><span class="line"><span class="comment">// 如果都不一样，执行代码4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结分支语句</span></span><br><span class="line"><span class="comment">// if语句:一个分支</span></span><br><span class="line"><span class="comment">// if-else语句:两个分支,最终只执行一个分支</span></span><br><span class="line"><span class="comment">// if-else if-else if...语句: 多个分支,也是只会执行一个</span></span><br><span class="line"><span class="comment">// switch-case语句:多分支语句,最终也会一个(必须要有break)</span></span><br><span class="line"><span class="comment">// 三元表达式:和if-else语句是一样的</span></span><br><span class="line"><span class="comment">// 什么时候使用if-else if...: 一般是对范围的判断</span></span><br><span class="line"><span class="comment">// 什么时候使用switch-case语句:一般是对具体的值的判断</span></span><br><span class="line"><span class="comment">// 如果有多个分支,是针对范围的判断一般选择if-else if的语句</span></span><br><span class="line"><span class="comment">// 如果有多个分支,是针对具体的值判断,一般选择用switch-case语句</span></span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环：一件事不停的或反复的去做</span></span><br><span class="line"><span class="comment">// 循环要有结束的条件，循环还应该有记录循环次数的计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">  num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先判断条件是否成立，如果为true，那么执行循环体中的代码，计数器加一，再继续判断条件是否成立，如果为true，那么继续执行循环体中的代码，计数器继续加一，再判断循环条件，直到循环条件不成立，循环结束。</span></span><br><span class="line"><span class="comment">// 如果循环的条件一直为true，那么循环体中代码会一直执行，这种称为死循环。我们应该尽量避免死循环。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do-while循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt;= <span class="number">5</span>) <span class="comment">// 条件</span></span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 先执行一次循环体，然后判断条件是否成立，不成立就跳出循环，成立就执行循环体，然后再判断。。以此类推。。直到条件不成立，跳出循环。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环特点:先判断,后循环,有可能一次循环体都不执行</span></span><br><span class="line"><span class="comment">// do-while循环特点:先循环,后判断,至少执行一次循环体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 表达式1、2、3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先执行一次表达式1，然后判断表达式2，如果不成立，就跳出循环，如果成立，就执行循环体的代码，执行完毕后跳到表达式3，然后跳到表达式2，判断表达式2是否成立。。以此类推。。直到表达式2不成立后跳出循环</span></span><br></pre></td></tr></table></figure>

<h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//break关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// 遇到break 跳出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue:在循环中如果遇到continue关键字,直接开始下一次循环</span></span><br><span class="line"><span class="comment">//案例:求100-200之间所有的奇数的和</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="comment">//判断是不是偶数</span></span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是偶数-----&gt;跳过这个数字</span></span><br><span class="line">    i++ <span class="comment">//102</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  sum += i</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js分支与循环</title>
    <url>/2020/01/03/js%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">知识点: -分支 - 循环</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流程控制：控制代码的执行过程</span></span><br><span class="line"><span class="comment">// 1、顺序结构:从上到下，从左到右执行的顺序，就是顺序结构（不严谨）</span></span><br><span class="line"><span class="comment">// 2、分支结构：if语句、if-else语句、switch-case语句</span></span><br><span class="line"><span class="comment">// 3、循环结构：while循环、do-while循环、for循环、for-in循环</span></span><br></pre></td></tr></table></figure>

<h3 id="分支语句-主要用于判断"><a href="#分支语句-主要用于判断" class="headerlink" title="分支语句-主要用于判断"></a>分支语句-主要用于判断</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if语句-（如果）</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1是小于3的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 先判断表达式结果是否成立（true/false），如果是true则执行代码块，如果是false，大括号中的代码不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if-else语句-(如果，否则)</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1小于3'</span>) <span class="comment">// 代码1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1大于3'</span>) <span class="comment">// 代码2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 如果表达式结果成立（true/false）,这执行代码1，如果表达式结果是false，这执行代码2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元表达式</span></span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">1</span> &lt; <span class="number">3</span> ? <span class="string">'小于'</span> : <span class="string">'不小于'</span></span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 表达式(1&lt;3)的结果是true还是false，如果是true，则result = '小于'，如果是false，则result = '不小于'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if-else if-else if-else</span></span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>) &#123;</span><br><span class="line">  代码<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">2</span>) &#123;</span><br><span class="line">  代码<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">3</span>) &#123;</span><br><span class="line">  代码<span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  代码<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先判断表达式1的结果，如果为true，则执行代码1，如果是false，再判断表达式2的结果，如果为true就执行代码2，如果是false再判断表达式3的结果，如果为true就执行代码3，如果上面表达式都是false，就执行代码4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case语句</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    代码<span class="number">3</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    代码<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 获取表达式的值，和值1比较，如果一样，就执行代码1，遇到break，跳出整个语句。后面代码不执行，</span></span><br><span class="line"><span class="comment">// 如果和值1不一样，就和值2比较，然后执行代码2，遇到break，跳出整个语句，后面代码不执行。</span></span><br><span class="line"><span class="comment">// 以此类推。。。</span></span><br><span class="line"><span class="comment">// 如果都不一样，执行代码4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结分支语句</span></span><br><span class="line"><span class="comment">// if语句:一个分支</span></span><br><span class="line"><span class="comment">// if-else语句:两个分支,最终只执行一个分支</span></span><br><span class="line"><span class="comment">// if-else if-else if...语句: 多个分支,也是只会执行一个</span></span><br><span class="line"><span class="comment">// switch-case语句:多分支语句,最终也会一个(必须要有break)</span></span><br><span class="line"><span class="comment">// 三元表达式:和if-else语句是一样的</span></span><br><span class="line"><span class="comment">// 什么时候使用if-else if...: 一般是对范围的判断</span></span><br><span class="line"><span class="comment">// 什么时候使用switch-case语句:一般是对具体的值的判断</span></span><br><span class="line"><span class="comment">// 如果有多个分支,是针对范围的判断一般选择if-else if的语句</span></span><br><span class="line"><span class="comment">// 如果有多个分支,是针对具体的值判断,一般选择用switch-case语句</span></span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环：一件事不停的或反复的去做</span></span><br><span class="line"><span class="comment">// 循环要有结束的条件，循环还应该有记录循环次数的计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">  num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先判断条件是否成立，如果为true，那么执行循环体中的代码，计数器加一，再继续判断条件是否成立，如果为true，那么继续执行循环体中的代码，计数器继续加一，再判断循环条件，直到循环条件不成立，循环结束。</span></span><br><span class="line"><span class="comment">// 如果循环的条件一直为true，那么循环体中代码会一直执行，这种称为死循环。我们应该尽量避免死循环。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do-while循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt;= <span class="number">5</span>) <span class="comment">// 条件</span></span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="comment">// 先执行一次循环体，然后判断条件是否成立，不成立就跳出循环，成立就执行循环体，然后再判断。。以此类推。。直到条件不成立，跳出循环。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环特点:先判断,后循环,有可能一次循环体都不执行</span></span><br><span class="line"><span class="comment">// do-while循环特点:先循环,后判断,至少执行一次循环体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 表达式1、2、3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'循环体'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="comment">// 先执行一次表达式1，然后判断表达式2，如果不成立，就跳出循环，如果成立，就执行循环体的代码，执行完毕后跳到表达式3，然后跳到表达式2，判断表达式2是否成立。。以此类推。。直到表达式2不成立后跳出循环</span></span><br></pre></td></tr></table></figure>

<h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//break关键字:如果在循环中使用,遇到了break,则立刻跳出当前所在的循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// 遇到break 跳出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue:在循环中如果遇到continue关键字,直接开始下一次循环</span></span><br><span class="line"><span class="comment">//案例:求100-200之间所有的奇数的和</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="comment">//判断是不是偶数</span></span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是偶数-----&gt;跳过这个数字</span></span><br><span class="line">    i++ <span class="comment">//102</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  sum += i</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js基本语法</title>
    <url>/2020/01/02/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">知识点:</span><br><span class="line">  - 变量</span><br><span class="line">  - 注释</span><br><span class="line">  - 数据类型</span><br><span class="line">  - 运算符</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>变量—区分大小写</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量的作用: 用来操作数据的(可以存储,可以读取)</span></span><br><span class="line"><span class="keyword">var</span> admin <span class="comment">// 变量的声明-&gt;只声明,没有赋值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'周杰伦'</span> <span class="comment">// 变量的初始化-&gt;声明并赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.使用var关键字(variable:可变的量)</span></span><br><span class="line"><span class="keyword">var</span> uname <span class="comment">// undefined</span></span><br><span class="line">uname = <span class="string">'周杰伦'</span> <span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.声明变量即赋值(推荐)</span></span><br><span class="line"><span class="keyword">var</span> unam = <span class="string">'周杰伦'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> unam = <span class="string">'周杰伦'</span>,</span><br><span class="line">  age = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量名的注意问题—变量名的命名规范,要遵循驼峰命名法</p>
</blockquote>
<pre><code>* 1.变量的名字要有意义,
* 2.变量名有一定的规范:一般以字母,$符号,下划线开头,中间或者后面可以有$符号,字母,数字
* 3.变量名一般都是小写的
* 4.变量名如果是多个单词,第一个单词的首字母是小写的,后面的所有的单词的首字母都是大写的,这种命名方式称为:驼峰命名法
* 5.不能使用关键字(系统自带的一些单词,不能使用)
* 6.不会单词用拼音,拼音也要遵循驼峰命名法</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注释是解释代码的含义,浏览器不会对注释内容进行解析执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> * 建议在代码关键处添加注释</span></span><br><span class="line"><span class="comment"> * 不写注释--&gt;写的时候只有你和上帝看的懂,写完之后你的代码只有上帝看得懂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 另外一种多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始数据类型(6种)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span> <span class="comment">//number 数字类型(整数和小数)</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'周杰伦'</span> <span class="comment">//string 字符串类型(一般用单引号或双引号包裹)</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span> <span class="comment">//boolean 布尔类型(值只有两个 true(真/1) false(假/0))</span></span><br><span class="line"><span class="keyword">var</span> nll = <span class="literal">null</span> <span class="comment">//null 空类型 值只有一个null 一个对象指向为空,可以赋值为null</span></span><br><span class="line"><span class="keyword">var</span> undef <span class="comment">//undefined 未定义值只有一个undefined(变量声明了,没有赋值 函数没有返回值)</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">//object 对象</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> <span class="comment">// 特殊(not an number) undefined加数字会出现NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>###　类型转行</p>
<blockquote>
<p>其他类型转数字类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转整数</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>) <span class="comment">// 10 转整数</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12abc'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1a1'</span>) <span class="comment">// 1 遇到非数字就停止</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc12'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转数字</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1.1'</span>) <span class="comment">// 1.1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc12'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转小数</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12'</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.12'</span>) <span class="comment">// 12.12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'abc12'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他类型转字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果变量有意义调用.tostring（）使用转换  // undefined(无意义)</span></span><br><span class="line"><span class="comment">// 如果变量没有意义使用string（）转换</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">num.toString() <span class="comment">// '20'</span></span><br><span class="line"><span class="built_in">String</span>(num) <span class="comment">// '20'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他类型转布尔类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(Boolean(1)) //true</span></span><br><span class="line"><span class="comment">// console.log(Boolean(0)) //false</span></span><br><span class="line"><span class="comment">// console.log(Boolean(11)) //true</span></span><br><span class="line"><span class="comment">// console.log(Boolean(-10)) //true</span></span><br><span class="line"><span class="comment">// console.log(Boolean("哈哈")) //true</span></span><br><span class="line"><span class="comment">// console.log(Boolean("")) //false</span></span><br><span class="line"><span class="comment">// console.log(Boolean(null)) //false</span></span><br><span class="line"><span class="comment">// console.log(Boolean(undefined)) //false</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算数运算符:  +  -  *  /  %</span></span><br><span class="line"><span class="comment">// 算数运算表达式:由算数运算符连接起来的表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元运算符: 这个操作符只需要一个操作数就可以运算的符号  ++  --</span></span><br><span class="line"><span class="comment">// 二元运算符: 这个操作符需要两个操作数就可以运算,</span></span><br><span class="line"><span class="comment">// 三元运算符: 10 == 10 ? true:false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合运算符: +=  -=  *=  /=  %=</span></span><br><span class="line"><span class="comment">// 复合运算表达式:由复合运算符连接起来的表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算符: &gt;  &lt;  &gt;=  &lt;=  ==不严格的 ===严格的 !=不严格的不等 !==严格的不等</span></span><br><span class="line"><span class="comment">// 关系运算表达式:由关系运算符连接起来的表达式</span></span><br><span class="line"><span class="comment">// 关系运算表达式的结果是布尔类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑运算符:</span></span><br><span class="line"><span class="comment">// &amp;&amp;---逻辑与--并且</span></span><br><span class="line"><span class="comment">// ||---逻辑或---或者</span></span><br><span class="line"><span class="comment">// !---逻辑非---取反--取非</span></span><br><span class="line"><span class="comment">// 逻辑运算表达式:由逻辑运算符连接起来的表达式</span></span><br><span class="line"><span class="comment">// 表达式1 &amp;&amp; 表达式2</span></span><br><span class="line"><span class="comment">// 如果有一个为false,整个的结果就是false</span></span><br><span class="line"><span class="comment">// 表达式1 || 表达式2</span></span><br><span class="line"><span class="comment">// 如果有一个为true,整个的结果为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// !表达式1 取反</span></span><br><span class="line"><span class="comment">// 表达式1的结果是true,整个结果为false</span></span><br><span class="line"><span class="comment">// 表达式1的结果是false,整个结果为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符:  =</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础  ++与--</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">num++ <span class="comment">// 相当于num = num + 1 输出 11</span></span><br><span class="line">num-- <span class="comment">// 相当于num = num - 1 输出 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> sum = num++ + <span class="number">10</span> <span class="comment">// sum = 20</span></span><br><span class="line"><span class="comment">// 如果++在后面：如上： num++ + 10参与运算</span></span><br><span class="line"><span class="comment">// 先运算 再加加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum1 = ++num + <span class="number">10</span> <span class="comment">// sum1 = 21</span></span><br><span class="line"><span class="comment">// 如果++在前面 如上： ++num + 10</span></span><br><span class="line"><span class="comment">// 先加加 再运算加10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript简介</title>
    <url>/2019/12/31/js%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="JavaScript-–-gt-简称-js"><a href="#JavaScript-–-gt-简称-js" class="headerlink" title="JavaScript –&gt; 简称 js"></a>JavaScript –&gt; 简称 js</h4><blockquote>
<p>JavaScript 历史</p>
</blockquote>
<p>​ 1995 年，网景公司希望能在静态 HTML 页面上添加一些动态效果, 让 Brendan Eich 设计出了 JavaScript 语言(用时 2 周)</p>
<blockquote>
<p>JavaScript 分为三个部分:</p>
</blockquote>
<ul>
<li>ECMAScript 标准—-js 的基本语法</li>
<li>DOM—Document Object Model 文档对象模型</li>
<li>BOM—Browser Object Model 浏览器对象模型</li>
</ul>
<blockquote>
<p>JavaScript 是什么?</p>
</blockquote>
<ul>
<li>是一门脚本语言</li>
<li>是一门解释性语言</li>
<li>是一门弱类型的语言</li>
<li>是一门动态类型的语言</li>
<li>是一门基于对象的语言</li>
</ul>
<blockquote>
<p>JavaScript 代码写在哪里</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">第一种:写在html文件中--&gt;使用script标签包裹代码</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	alert(<span class="string">'这对script标签中的就是js代码)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">第二种:可以单独写在js文件中--&gt;js文件中不需要使用&lt;script&gt;标签</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;script&gt;</code>标签的属性:</p>
</blockquote>
<ul>
<li>src 表示要引入的外部文件</li>
<li>type 表示脚本语言的类型 text/javascript,默认值就是它.</li>
<li>language 已废弃。原来用于代码使用的脚本语言。由于大多数浏览器忽略它，所以不要用了。</li>
<li>defer：可选。(等页面加载完成后,才执行 js)表示脚本可以延迟到文档完全被解析和显示之后再执行。由于大多数浏览器不支持，故很少用。</li>
<li>charset：可选。表示通过 src 属性指定的字符集。由于大多数浏览器忽略它，所以很少有人用它。</li>
<li>async:可选,能简单实现 js 的异步加载.</li>
</ul>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li><code>&lt;script&gt;</code>标签尽量放在<code>&lt;body&gt;</code>标签内,放在结束的<code>&lt;/body&gt;</code>标签前</li>
<li>一个<code>&lt;script&gt;</code>标签如果用于引入外部 js 文件,就不要在标签内写 script 代码</li>
<li>html 文件中可以同时存在多对<code>&lt;script&gt;</code>标签,浏览器会依次解析执行</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的 Form 表单组件</title>
    <url>/2019/12/30/myForm/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文主要通过实现一个简单的 Form 组件来学习 Vue 中相关知识点.</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ul>
<li>v-model 指令的实质</li>
<li>父子组件定义属性传值 props $emit</li>
<li>子孙组件传值 provide inject</li>
<li>slot 插槽</li>
<li>在生命周期中监听自定义事件</li>
</ul>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>数据双向绑定</li>
<li>单个规则校验</li>
<li>label</li>
<li>error 错误提示</li>
<li>数据获取</li>
<li>数据传递</li>
<li>全局校验</li>
</ul>
<h3 id="组件拆分-单一性"><a href="#组件拆分-单一性" class="headerlink" title="组件拆分(单一性)"></a>组件拆分(单一性)</h3><ul>
<li>Input 组件</li>
<li>FormItem 组件</li>
<li>Form 组件</li>
</ul>
<h3 id="组件功能划分"><a href="#组件功能划分" class="headerlink" title="组件功能划分"></a>组件功能划分</h3><hr>
<blockquote>
<p>Input 组件</p>
</blockquote>
<p>数据双向绑定<br>触发规则校验</p>
<hr>
<blockquote>
<p>FormItme 组件</p>
</blockquote>
<p>label<br>prop<br>error</p>
<hr>
<blockquote>
<p>Form 组件</p>
</blockquote>
<p>数据模型持有<br>校验规则持有<br>数据传递<br>全局校验</p>
<hr>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Input 组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"value"</span> @input=<span class="string">"onInput"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 职能</span></span><br><span class="line"><span class="comment"> * 1.双向绑定</span></span><br><span class="line"><span class="comment"> * 2.触发校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'KInput'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput(e) &#123;</span><br><span class="line">      <span class="comment">// v-model 监听 input</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.value)</span><br><span class="line">      <span class="comment">// 触发校验</span></span><br><span class="line">      <span class="keyword">this</span>.$parent.$emit(<span class="string">'validate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormItem 组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label v-<span class="keyword">if</span>=<span class="string">"label"</span>&gt;&#123;&#123; label &#125;&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;slot /</span>&gt;</span><br><span class="line">    &lt;span v-show=<span class="string">"error"</span>&gt;&#123;&#123; error &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 职能</span><br><span class="line"> * <span class="number">1.</span>校验</span><br><span class="line"> * <span class="number">2.</span>label</span><br><span class="line"> * <span class="number">3.</span>error</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">import Schema from 'async-validator'</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  inject: ['form'],</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    label: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: ''</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    prop: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: ''</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      error: ''</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    this.$on('validate', () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.validate()</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    validate() &#123;</span></span><br><span class="line"><span class="regexp">      /</span>**</span><br><span class="line">       * 引入 sync-validate 插件</span><br><span class="line">       * 获取校验规则与校验值</span><br><span class="line">       *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      const value = this.form.model[this.prop]</span></span><br><span class="line"><span class="regexp">      const rule = this.form.rules[this.prop]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      const schema = new Schema(&#123; [this.prop]: rule &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      return schema.validate(</span></span><br><span class="line"><span class="regexp">        &#123; [this.prop]: value.trim() &#125;,</span></span><br><span class="line"><span class="regexp">        errors =&gt; (this.error = errors ? errors[0].message : '')</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Form 组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 职能</span></span><br><span class="line"><span class="comment"> * 1.数据持有丶传递</span></span><br><span class="line"><span class="comment"> * 2.全局校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    model: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      form: <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    validate(cb) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 全局校验</span></span><br><span class="line"><span class="comment">       * 获取所有子组件</span></span><br><span class="line"><span class="comment">       * 找到带有prop验证的</span></span><br><span class="line"><span class="comment">       * 调用子组件自身的校验方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> tasks = <span class="keyword">this</span>.$children</span><br><span class="line">        .filter(<span class="function"><span class="params">item</span> =&gt;</span> item.prop)</span><br><span class="line">        .map(<span class="function"><span class="params">item</span> =&gt;</span> item.validate())</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> cb(<span class="literal">true</span>))</span><br><span class="line">        .catch(<span class="function"><span class="params">()</span> =&gt;</span> cb(<span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;KFrom ref=<span class="string">"form"</span> :model=<span class="string">"model"</span> :rules=<span class="string">"rules"</span>&gt;</span><br><span class="line">      &lt;KFormitem lable=<span class="string">"用户名"</span> prop=<span class="string">"uname"</span>&gt;</span><br><span class="line">        &lt;KInput v-model=<span class="string">"model.uname"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">KInput</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/KFormitem&gt;</span></span><br><span class="line"><span class="regexp">      &lt;KFormitem lable="密码" prop="pwd"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;KInput v-model="model.pwd"&gt;&lt;/</span>KInput&gt;</span><br><span class="line">      &lt;<span class="regexp">/KFormitem&gt;</span></span><br><span class="line"><span class="regexp">      &lt;KFormitem&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="submit"&gt;校验&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/KFormitem&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>KFrom&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> KFrom <span class="keyword">from</span> <span class="string">'./KForm'</span></span><br><span class="line"><span class="keyword">import</span> KFormitem <span class="keyword">from</span> <span class="string">'./KFormitem'</span></span><br><span class="line"><span class="keyword">import</span> KInput <span class="keyword">from</span> <span class="string">'./KInput'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; KFrom, KFormitem, KInput &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      model: &#123;</span><br><span class="line">        uname: <span class="string">''</span>,</span><br><span class="line">        pwd: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        uname: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'用户名不能为空'</span> &#125;],</span><br><span class="line">        pwd: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'密码不能为空'</span> &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submit() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs.form.validate(<span class="function"><span class="params">isValidate</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValidate) &#123;</span><br><span class="line">          alert(<span class="string">'校验通过'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'校验失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next + GitHub 搭建博客</title>
    <url>/2019/12/26/hello-blog/</url>
    <content><![CDATA[<p>&emsp;&emsp;秃头一族怎么能没有自己的 Blog 呢? 本想着自己买服务器与域名,使用 Node React 纯手撸 ,奈何钱包与时间它不允许, 所以就有了本站与这篇文章了.</p>
<blockquote>
<p>相关链接</p>
</blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 文档</a><br><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 文档</a><br><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">参考大神博客</a></p>
<blockquote>
<p>一.全局安装 Hexo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二.创建博客项目</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用终端进入准备存放博客项目的目录 输入以下命令</span></span><br><span class="line">hexo init hexo-blog <span class="comment"># hexo-blog 自己取名即可</span></span><br><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三.本地预览博客</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server <span class="comment"># 使用浏览器开大 http://localhost:4000 即可</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>四.打包部署</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML meta标签详解</title>
    <url>/2019/12/26/meta%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写</span><br><span class="line">&lt;head lang=”en”&gt; 标准的 lang 属性写法</span><br><span class="line">&lt;meta charset=’utf<span class="number">-8</span>′&gt;    声明文档使用的字符编码</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=<span class="number">1</span>″/&gt;   优先使用 IE 最新版本和 Chrome</span><br><span class="line">&lt;meta name=”description” content=”不超过<span class="number">150</span>个字符”/&gt;       页面描述</span><br><span class="line">&lt;meta name=”keywords” content=””/&gt;      页面关键词</span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt;    网页作者</span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt;      搜索引擎抓取</span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=<span class="number">1</span>, maximum-scale=<span class="number">3</span>, minimum-scale=<span class="number">1</span>, user-scalable=no”&gt; 为移动设备添加 viewport</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; iOS 设备 begin</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;  添加到主屏后的标题（iOS <span class="number">6</span> 新增）</span><br><span class="line">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span><br><span class="line">&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;</span><br><span class="line">添加智能 App 广告条 Smart App Banner（iOS <span class="number">6</span>+ Safari）</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line">&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  设置苹果工具栏颜色</span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt;  启用<span class="number">360</span>浏览器的极速模式(webkit)</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;     避免IE使用兼容模式</span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;    不让百度转码</span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”<span class="literal">true</span>”&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span><br><span class="line">&lt;meta name=”MobileOptimized” content=”<span class="number">320</span>″&gt;   微软的老式浏览器</span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt;   uc强制竖屏</span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt;    QQ强制竖屏</span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt;              UC强制全屏</span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”<span class="literal">true</span>”&gt;       QQ强制全屏</span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt;   UC应用模式</span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt;    QQ应用模式</span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;    windows phone 点击无高光</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”<span class="number">0</span>″&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
</search>
