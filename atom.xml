<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ginger</title>
  
  <subtitle>一个前端er~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-25T06:46:57.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ginger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack-04-mode</title>
    <link href="http://yoursite.com/2020/04/25/webpack-04-mode/"/>
    <id>http://yoursite.com/2020/04/25/webpack-04-mode/</id>
    <published>2020-04-25T06:46:49.000Z</published>
    <updated>2020-04-25T06:46:57.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>提供 <code>mode</code> 配置选项, 告知 webpack 使用相应的模式的内置优化</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>只在配置中提供 <code>mode</code> 选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>, <span class="comment">// 生产环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在 CLI 参数中传递</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><p>development:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>. 启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></p></li><li><p>production:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>. 启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>.</p></li></ul><h2 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h2><p>mode: development</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode: production</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h2&gt;&lt;p&gt;提供 &lt;code&gt;mode&lt;/code&gt; 配置选项, 告知 webpack 使用相应的模式的内置优化&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>service-服务器篇</title>
    <link href="http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/</id>
    <published>2020-04-25T04:54:24.000Z</published>
    <updated>2020-04-25T04:54:56.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>每个程序员都应该有一台自己的云服务器</p><blockquote><p><a href="https://www.zhihu.com/question/40854395" target="_blank" rel="noopener">知乎-自己拥有一台服务器可以做哪些很酷的事情</a></p></blockquote><p>服务器厂商:</p><ul><li><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a></li><li><a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a></li><li><a href="https://www.sinacloud.com/" target="_blank" rel="noopener">新浪云</a></li><li><a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">华为云</a></li></ul><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><blockquote><p>注: 下面流程以我自己购买的腾讯云服务器为例</p></blockquote><p>点击<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云链接</a>进入腾讯云首页, 点击右上角登录进行登录</p><p>在首页轮播图常年有活动, 新用户与学生一般是活动优惠力度最大的</p><p>点击轮播图活动进入后, 按照需求选择我们需要的服务器配置, 如果是个人学习、博客等使用, 最基本的即可</p><p><img data-src="../images/01/01-01.png" alt="服务器"></p><p>点击立即抢购之后, 跳入一个配置选择界面, 选择离自己所在地最近的城市, 选择机型配置, 选择 CentOS 系统</p><p><img data-src="../images/01/01-02.png" alt="服务器"></p><p>点击<strong>立即购买</strong>即可跳转付款页面, 核对无误后付款即可</p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>在腾讯云首页右上角有一个控制台按钮, 点击即可进入控制台</p><p><img data-src="../images/01/01-02.png" alt="服务器"></p><p>点击服务器后将会跳转至实例界面(如果没有实例就创建一个)</p><p><img data-src="../images/01/01-04.png" alt="实例"></p><blockquote><p>首次购买后会自动跳转至服务器控制台</p></blockquote><h2 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h2><blockquote><p>以 MacOS 为例</p></blockquote><p>打开终端, 输入 <code>ssh root@xx.xx.xx.xx</code> 回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><blockquote><p>xx.xx.xx.xx 替换为自己服务器公网 ip 地址</p></blockquote><p>弹出提示要求输入密码</p><blockquote><p>输入密码不会显示, 输入完成后直接回车即可</p></blockquote><p><img data-src="../images/01/01-05.png" alt="ssh"></p><p>如果看到如下界面就表示密码输入成功</p><p><img data-src="../images/01/01-06.png" alt="ssh"></p><p>输入 <code>cat /etc/redhat-release</code> 查看系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img data-src="../images/01/01-07.png" alt="ssh"></p><h2 id="配置免密验证"><a href="#配置免密验证" class="headerlink" title="配置免密验证"></a>配置免密验证</h2><p>在使用上面的命令登录远程服务器的时候, 是需要输入密码的, 而且以后每次访问都需要输入, 这样就很繁琐.</p><p>我们可以通过—ssh 免密验证</p><h3 id="在本地生成秘钥"><a href="#在本地生成秘钥" class="headerlink" title="在本地生成秘钥"></a>在本地生成秘钥</h3><p>通过如下命令在本地机器生成秘钥</p><blockquote><p>如果你使用过 git 配置, 就无需重复生成</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 指定加密算法； -b 指定生成的密钥长度； -C 一句话，一般都填邮箱地址。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更多参数说明可以在终端输入：ssh-keygen --<span class="built_in">help</span> 查看</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "你的邮箱地址"</span><br></pre></td></tr></table></figure><p>这条命令执行完之后, 会提示指定公钥和私钥在本地机器上储存的位置, 因为我本地已经有秘钥了, 就从网上找了一张图</p><p><img data-src="../images/01/01-08.png" alt="ssh"></p><h3 id="将公钥储存到远程服务器主机"><a href="#将公钥储存到远程服务器主机" class="headerlink" title="将公钥储存到远程服务器主机"></a>将公钥储存到远程服务器主机</h3><p>输入以下命令, 然后回车, 将上一步我们在本地机器上生成的公钥写入服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> i后面接的参数是保存你公钥的文件(我们这里是.ssh/id_rsa.pub)；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> root是远程主机的用户，这条指令会往root这个用户的主目录下的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .ssh/authorized_keys文件写入id_rsa.pub保存的公钥</span></span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><img data-src="../images/01/01-09.png" alt="ssh"></p><p>根据提示, 输入服务器主机登录密码</p><p><img data-src="../images/01/01-10.png" alt="ssh"></p><p>如果看到如下提示, 表示添加成功</p><p><img data-src="../images/01/01-11.png" alt="ssh"></p><p>此时, 我们再使用 <code>ssh root@xx.xx.xx.xx</code> 对服务器进行访问, 就能直接登录, 不需要再输入密码了</p><p><img data-src="../images/01/01-12.png" alt="ssh"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云服务器&quot;&gt;&lt;a href=&quot;#云服务器&quot; class=&quot;headerlink&quot; title=&quot;云服务器&quot;&gt;&lt;/a&gt;云服务器&lt;/h1&gt;&lt;p&gt;每个程序员都应该有一台自己的云服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zh
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>webpack-03-loader</title>
    <link href="http://yoursite.com/2020/04/22/webpack-03-loader/"/>
    <id>http://yoursite.com/2020/04/22/webpack-03-loader/</id>
    <published>2020-04-22T15:15:21.000Z</published>
    <updated>2020-04-22T15:15:34.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换. loader 可以使你在 <code>import</code> 或 “加载” 模块时预处理文件. loader 可以将文件从不同的语言转换为 JavaScript, 或将内联图像转换为 data URL, loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>loader 支持链式传递, 一组链式的 loader 按照相反的顺序执行, loader 链中的第一个 loader 返回值给下一个 loader. 在最后一个 loader 返回 webpack 所预期的 JavaScript</li><li>loader 可以是同步的, 也可以是异步的</li><li>loader 运行在 Node.js 中, 并且能够执行任何可能的操作</li><li>loader 接受查询参数, 用于对 loader 传递配置</li><li>loader 也能够使用 options 对象进行配置</li><li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性, 还可以将普通的 <code>npm</code> 模块导出为 loader, 做法是在 <code>package.json</code> 里定义一个 loader 字段</li><li>插件(plugin)可以为 loader 带来更多特性</li><li>loader 能够产生额外的任意文件</li></ul><h2 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h2><p>可以使用 loader 告诉 webpack 加载 CSS 文件</p><p>先安装对应的loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D css-loader</span><br></pre></td></tr></table></figure><p>然后配置 <code>webpack.config.js</code> 文件, 告诉 webpack 对每个 <code>.css</code> 使用 css-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;loader&quot;&gt;&lt;a href=&quot;#loader&quot; class=&quot;headerlink&quot; title=&quot;loader&quot;&gt;&lt;/a&gt;loader&lt;/h2&gt;&lt;p&gt;loader 用于对模块的源代码进行转换. loader 可以使你在 &lt;code&gt;import&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-02-入口与出口</title>
    <link href="http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/</id>
    <published>2020-04-21T14:58:29.000Z</published>
    <updated>2020-04-21T14:58:44.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点</strong>(entry point)指示 webpack 应该使用哪个模块, 来作为构建其内部依赖图的开始. 进入入口后, webpack 会找出有哪些模块和库是入口起点(直接和简介)依赖的</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>entery: String|Array<string></li></ul><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><p><code>entry</code> 属性的单个入口语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 多入口写法 - 对象写法: </p><p>用法: `entry: {[entruChunkName: string]: string|Array<string>}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><blockquote><p>可应用于多页面程序</p></blockquote><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><strong>output</strong>属性告诉 webpack 在哪里输出它所创建的 bundles, 以及如何命名这些文件, 默认值为 <code>./dist</code>. 整个应用程序结构, 都会被编译到指定的输出路径的文件夹中, </p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>output: Object <code>output</code> 选项可以控制 webpack 如何向硬盘写入编译文件<ul><li>filename: String 打包后的文件名</li><li>path: String 打包输出路径</li></ul></li></ul><h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><p>单入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 NodeJS 的 path 核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure><h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><p>使用 CDN 和资源 hash 的复杂示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'/home/proj/cnd/assets/[hash]'</span>,</span><br><span class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入口-entry&quot;&gt;&lt;a href=&quot;#入口-entry&quot; class=&quot;headerlink&quot; title=&quot;入口(entry)&quot;&gt;&lt;/a&gt;入口(entry)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;入口起点&lt;/strong&gt;(entry point)指示 webpack
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-01-安装与使用</title>
    <link href="http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-20T13:16:47.000Z</published>
    <updated>2020-04-20T13:17:23.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前提: 请确保安装了 Node.js 的最新版本</p></blockquote><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler) 当 webpack 处理应用程序时, 它会递归地构建一个依赖关系图(dependencygraph) 其中包含应用程序需要的每个模块, 然后将所有这些模块打包成一个或多个bundle</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-dmeo # 创建项目文件夹</span><br><span class="line">cd webpack-demo # 进入项目目录</span><br><span class="line">npm init -y # 默认配置初始化</span><br></pre></td></tr></table></figure><p>出现 package.json 信息, 表示初始化成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种安装"><a href="#两种安装" class="headerlink" title="两种安装"></a>两种安装</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版本</span></span><br><span class="line">npm install --save-dev webpack </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用 weboack4+ 版本 还需要安装 CLI</span></span><br><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure><h2 id="webpack-命令使用方式"><a href="#webpack-命令使用方式" class="headerlink" title="webpack 命令使用方式"></a>webpack 命令使用方式</h2><h3 id="项目目录运行"><a href="#项目目录运行" class="headerlink" title="项目目录运行"></a>项目目录运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> webpack-demo 目录中</span></span><br><span class="line">./node_modules/.bin/webpack --sersion</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="NPM-script命令运行"><a href="#NPM-script命令运行" class="headerlink" title="NPM script命令运行"></a>NPM script命令运行</h3><p>添加 script 脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"build"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"webpack --version"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="全局运行"><a href="#全局运行" class="headerlink" title="全局运行"></a>全局运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要全局安装webpack</span></span><br><span class="line">webpack --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前提: 请确保安装了 Node.js 的最新版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpac
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-buildFragment方法</title>
    <link href="http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-31T08:51:47.000Z</published>
    <updated>2020-03-31T08:51:58.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts)将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><p>文档片段 DocumentFragment 表示文档的一部分, 但不属于文档树. 当把 DocumentFragment 插入文档树时, 插入的不是 DocumentFragment 自身, 而是他的所有子孙节点, 即可以一次向文档树中插入多个节点. 当需要插入大量节点时, 相比逐个插入节点, 使用 ocumentFragment 一次插入多个节点, 性能的提升会非常明显</p><p>如果 HTML 代码符合缓存条件, 方法 jQuery.buildFragment()还会把转换后的 DOM 元素缓存起来, 下次转换相同的代码时, 直接从缓存中读取, 不需要重复转换</p><h2 id="方法执行步骤"><a href="#方法执行步骤" class="headerlink" title="方法执行步骤"></a>方法执行步骤</h2><p>jQuery.buildFragment(args, nodes, scripts)执行步骤:</p><ol><li>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</li><li>创建文档片段 DocumentFragment</li><li>调用方法 jQuery.clean(elems, context, Fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</li><li>如果 HTML 代码符合缓存条件,则把转换后的 DOM 元素防褥缓存对象 jQuery.Fragments</li><li>最后返回文档片段和缓存状态 { fragment: fragment, cacheable: cacheable }</li></ol><h2 id="jQuery-buildFragment-方法源码"><a href="#jQuery-buildFragment-方法源码" class="headerlink" title="jQuery.buildFragment() 方法源码"></a>jQuery.buildFragment() 方法源码</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.buildFragment(args, nodes, scripts) &#123;&#125;</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li>ages: 数组, 含有待转换的 DOM 元素的 HTML 代码</li><li>nodes: 数组, 含有文档对象、jQuery 对象或 DOM 元素, 用于修正创建文档片段 DocumentFragment 的文档对象</li><li>scripts: 数组, 用于存放 HTML 代码中的 script 元素. 方法 jQuery.Fragment() 会把该参数传给方法 jQuery.clean(), 后者把 HTML 代码转换为 DOM 元素后, 会提取其中的 script 元素并存入数组 scrtips</li></ul><h3 id="定义局部变量-修正文档对象-doc"><a href="#定义局部变量-修正文档对象-doc" class="headerlink" title="定义局部变量, 修正文档对象 doc"></a>定义局部变量, 修正文档对象 doc</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fragment, <span class="comment">// 指向稍后可能创建的文档片段 Document Fragment</span></span><br><span class="line">  eacheable, <span class="comment">// 表示 HTML 代码 是否符合缓存条件</span></span><br><span class="line">  eacheresults, <span class="comment">// 指向从缓存对象 jQuery.ftagment 中提取到的文档片段 包含了缓存的DOM元素</span></span><br><span class="line">  doc, <span class="comment">// 表示创建文档片段的文档对象</span></span><br><span class="line">  fitst = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修正文档对象 doc</span></span><br><span class="line"><span class="comment"> * nodes 可能包含一个明确的文档对象, 也可能包含jQuery对象或DOM元素</span></span><br><span class="line"><span class="comment"> * 先尝试读取nodes[0]的属性 ownerDocuemt 并赋值给doc</span></span><br><span class="line"><span class="comment"> * 如果不存在 则假定nodes[0]为文档对象并赋值给doc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nodes &amp;&amp; nodes[<span class="number">0</span>]) &#123;</span><br><span class="line">  doc = nodes[<span class="number">0</span>].ownerDocument || node[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查传入参数对象是不是文档对象 如果不是文档对象 而是 JavaScript 对象 就修正 doc 为当前文档对象 document</span></span><br><span class="line"><span class="keyword">if</span> (!doc.createDocumentFragment) &#123;</span><br><span class="line">  doc = <span class="built_in">document</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素"><a href="#尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素" class="headerlink" title="尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素"></a>尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</h3><p>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</p><ul><li>数组 args 长度为 1, 且第一个元素是字符串, 即数组 args 中只有一段 HTML 代码</li><li>HTML 代码长度小于 512, 否则可能会导致缓存占用内存过大</li><li>文档对象 doc 是当前文档对象, 即之缓存为当前文档创建的 DOM 元素</li><li>HTML 代码已左尖括号开头, 即只缓存 DOM 元素, 不缓存文本节点</li><li>HTML 代码中不能含有 <code>&lt;script&gt;</code> <code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;option&gt;</code> <code>&lt;style&gt;</code>标签</li><li>当前浏览器可以正确的复制单选按钮核复选框的选中状态 checked, 或者 HTML 代码中的单选按钮和复选按钮没有被选中</li><li>当前浏览器可以正确的赋值 HTML5 元素, 或者 HTML 代码中不含有 HTML5 标签</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(args.length === <span class="number">1</span></span><br><span class="line">&amp;&amp; <span class="keyword">typeof</span> first === <span class="string">'string'</span></span><br><span class="line">&amp;&amp; first.length &lt; <span class="number">512</span></span><br><span class="line">&amp;&amp; doc === <span class="built_in">document</span></span><br><span class="line">&amp;&amp; first.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span></span><br><span class="line">&amp;&amp; !rnocache.test(first)</span><br><span class="line">&amp;&amp; (jQuery.support.checkClone || !rchecked.test(first))</span><br><span class="line">&amp;&amp; (jQuery.support.html5Clone || !rnshimcache.text(first))&#123;</span><br><span class="line"></span><br><span class="line">  cacheable = <span class="literal">true</span>; <span class="comment">// 如果遍历为 true 必须先赋值一份再使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试从缓存对象jQuery.fragment中读取缓存的DOM元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cacheresults = jQuery.fragments[first];</span><br><span class="line">  <span class="keyword">if</span> (cacheresults &amp;&amp; cacheresults !== <span class="number">1</span>) &#123;</span><br><span class="line">    fragment = cacheresults;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.fragments = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="转换-HTML-代码为-DOM-元素"><a href="#转换-HTML-代码为-DOM-元素" class="headerlink" title="转换 HTML 代码为 DOM 元素"></a>转换 HTML 代码为 DOM 元素</h2><p>先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果为 true 表示需要直型转换过程</span></span><br><span class="line"><span class="keyword">if</span> (!fragment) &#123;</span><br><span class="line">  <span class="comment">// 调用原生方法 创建文档片段</span></span><br><span class="line">  fragment = doc.createDocumentFragment();</span><br><span class="line">  <span class="comment">// 将片段转换为 DOM 元素</span></span><br><span class="line">  jQuery.clean(args, doc, fragment, scripts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把转换后的-DOM-元素防褥缓存对象-jQuery-fragments"><a href="#把转换后的-DOM-元素防褥缓存对象-jQuery-fragments" class="headerlink" title="把转换后的 DOM 元素防褥缓存对象 jQuery.fragments"></a>把转换后的 DOM 元素防褥缓存对象 jQuery.fragments</h2><p>如果 HTML 代码符合缓存条件, 则把转换后的 DOM 元素放入缓存对象 jQuery.fragment 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果符合缓存条件 就缓存</span></span><br><span class="line"><span class="keyword">if</span> (cacheable) &#123;</span><br><span class="line">  jQuery.fragments[first] = cacheresults ? fragment : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回文档片段和缓存状态"><a href="#返回文档片段和缓存状态" class="headerlink" title="返回文档片段和缓存状态"></a>返回文档片段和缓存状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  返回一个包含了文档片段 fragment 和缓存状态 cacheable 的对象</span></span><br><span class="line"><span class="comment">  fragment 中包含了转换后的 DOM 元素, 缓存状态 cacheable 则指示了如果使用这些 DOM 元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  fragment: fragment,</span><br><span class="line">  cacheable: cacheable</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="../../images/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.buildFragment.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 Documen
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-jQuery.fn.init</title>
    <link href="http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/"/>
    <id>http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/</id>
    <published>2020-03-26T07:29:26.000Z</published>
    <updated>2020-03-26T07:29:38.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery-fn-init-selector-context-rootjQuery"><a href="#jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="jQuery.fn.init(selector, context, rootjQuery)"></a>jQuery.fn.init(selector, context, rootjQuery)</h1><p>构造函数 jQuery.fn.init() 负责解析参数 selector 和 context 的类型, 并执行相应的逻辑, 最后返回 jQuery.fn.init() 的实例.</p><blockquote><p>解析参数 selector 和 context 公有 12 个有效分支</p></blockquote><p><img data-src="../../images/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init.png" alt="jQuery.fn.init"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="定义-jQuery-fn-init-selector-context-rootjQuery"><a href="#定义-jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="定义 jQuery.fn.init(selector, context, rootjQuery)"></a>定义 jQuery.fn.init(selector, context, rootjQuery)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">  init: function(selector, context, rootjQuery) &#123;</span><br><span class="line">    <span class="keyword">var</span> match, elem, ret, doc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>init()</code> 构造函数定义中接受三个参数 selector、context、rootjQuery</p><ul><li>selector: 可以是任意类型的值, 但只有 undefined、DOM 元素、字符串、函数、jQuery 对象、普通 JavaScript 对象这几种类型有效</li><li>context: 可以不传入, 或者传入 DOM 元素、jQuery 对象、普通 JavaScript 对象之一</li><li>rootjQuery: 包含了 document 对象的 jQuery 对象, 用于 document.getElementById()查找失败、selector 是选择器表达式且未指定 context、selector 是函数的情况.</li></ul><p>rootjQuery 定义与应用场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document.getElementById() 查找失败</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.find(selector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// slector 是选择器且未指定 context</span></span><br><span class="line"><span class="keyword">return</span> (context || rootjQuery).find(selector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// selector 是函数</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.ready(selector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// rootjQuery 定义</span></span><br><span class="line">rootjQuery = jQuery(doucment);</span><br></pre></td></tr></table></figure><h2 id="参数-selector-可以转换为-false"><a href="#参数-selector-可以转换为-false" class="headerlink" title="参数 selector 可以转换为 false"></a>参数 selector 可以转换为 false</h2><p>参数 selector 可以转换为 false, 例如: undefined、空字符串、null 等, 则直接返回 this, 此时 this 是空 jQuery 对象, 其属性 length 等于 0.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $('')、$(null) or $(undefined)</span></span><br><span class="line"><span class="keyword">if</span> (!selector) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是-DOM-元素"><a href="#参数-selector-是-DOM-元素" class="headerlink" title="参数 selector 是 DOM 元素"></a>参数 selector 是 DOM 元素</h2><p>如果参数 selector 有属性 nodeType, 则认为 selector 是 DOM 元素, 手动设置第一个元素和属性 context 指向该 DOM 元素、属性 length 为 1, 然后返回包含了该 DOM 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $(DOMELement)</span></span><br><span class="line"><span class="keyword">if</span> (selector.nodeType) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="keyword">this</span>[<span class="number">0</span>] = selector;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是字符串-‘body’"><a href="#参数-selector-是字符串-‘body’" class="headerlink" title="参数 selector 是字符串 ‘body’"></a>参数 selector 是字符串 ‘body’</h2><p>如果参数 selector 是字符串 “body”, 手动设置属性 context 指向 document 对象、第一个元素指向 body 元素、属性 length 为 1, 最后返回包含了 body 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The body element only exists once, optimize finding it</span></span><br><span class="line"><span class="keyword">if</span> (selector === <span class="string">'body'</span> &amp;&amp; !context &amp;&amp; <span class="built_in">document</span>.body) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">0</span>] = <span class="built_in">document</span>.body;</span><br><span class="line">  <span class="keyword">this</span>.selector = selector;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是其他字符串"><a href="#参数-selector-是其他字符串" class="headerlink" title="参数 selector 是其他字符串"></a>参数 selector 是其他字符串</h2><p>如果参数 selector 是其他字符串, 则先检测 selector 是 HTML 代码还是 <code>#id</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理参数是字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> selector === <span class="string">'string'</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是 HTML 代码 还是 #ID</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    selector.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span> &amp;&amp;</span><br><span class="line">    selector.charAt(selector.length - <span class="number">1</span>) === <span class="string">'&gt;'</span> &amp;&amp;</span><br><span class="line">    selector.length &gt;= <span class="number">3</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是以 `&lt;` 开头 `&gt;` 结尾的  并且长度大于等于 3  跳过 正则 检查</span></span><br><span class="line">    match = [<span class="literal">null</span>, selector, mull];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用正则检查  quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/</span></span><br><span class="line"><span class="comment">     * 依次匹配 HTML 代码和 id 如果匹配成功 match 数组第一个元素为参数 selector, 第二个元素为匹配的 HTML 代码或 undefined 第三个元素为匹配的 id 或 undefined</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('#target'); // ["#target",undefined,"target"]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;'); // ["&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;'); // ["abc&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;abc#id'); // ["abc&lt;div&gt;abc#id","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('div'); // null</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;&lt;img&gt;&lt;/div&gt;'); // ["&lt;div&gt;&lt;img&gt;&lt;/div&gt;","&lt;div&gt;&lt;img&gt;&lt;/div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = quickExpr.exec(selector);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果-selector-是单独标签"><a href="#如果-selector-是单独标签" class="headerlink" title="如果 selector 是单独标签"></a>如果 selector 是单独标签</h2><p>如果 selector 是单独标签, 就调用 document.createElement() 创建标签对应的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查正则匹配结果</span></span><br><span class="line"><span class="comment"> * 如果 match[1] 不是 undefined 即 selector 是 HTML 代码 或者 match[2] 不是 undefined, 即参数 selector 是 #id 并且未传入 context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (match &amp;&amp; (match[<span class="number">1</span>] || !context)) &#123;</span><br><span class="line">  <span class="comment">// HANDLE: $(html) -&gt; $(array)</span></span><br><span class="line">  <span class="keyword">if</span> (match[<span class="number">1</span>]) &#123;</span><br><span class="line">    context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context;</span><br><span class="line"></span><br><span class="line">    doc = context ? context.ownerDocument || context : <span class="built_in">document</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入单个字符 并且是个单标签 直接创建 跳过其他</span></span><br><span class="line">    <span class="comment">// rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,</span></span><br><span class="line">    ret = rsingleTag.exec(selector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="comment">// jQuery.isPlainObject() 用于检测对象是否是纯粹的对象 即用对象直接量 &#123;&#125; 或者 new Object() 创建的对象</span></span><br><span class="line">      <span class="keyword">if</span> (jQuery.isPlainObject(context)) &#123;</span><br><span class="line">        selector = [<span class="built_in">document</span>.createElement(ret[<span class="number">1</span>])];</span><br><span class="line">        <span class="comment">// attr() 遇到特殊属性和事件类型时会执行同名 jQuery 方法</span></span><br><span class="line">        jQuery.fn.attr.call(selector, context, <span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selector = [doc.createElement(res[<span class="number">1</span>])];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以把创建的 DOM 源码放入数组中, 是为了后面方便的调用 jQuery.merge() 方法, 此方法用于合并两个数组的元素到一个数组</p></blockquote><h2 id="参数-selector-是复杂-HTML-代码"><a href="#参数-selector-是复杂-HTML-代码" class="headerlink" title="参数 selector 是复杂 HTML 代码"></a>参数 selector 是复杂 HTML 代码</h2><p>如果参数 selector 是复杂 HTML 代码, 则利用浏览器 innerHTML 创建 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建过程由 buildFragment 和 clean 实现</span></span><br><span class="line"><span class="comment">    * buildFragment 返回 -&gt; &#123; fragment: 含有转换后的 DOM 元素的文档片段 , cacheable: HTML代码是否满足缓存条件&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ret = jQuery.buildFragment([ match[<span class="number">1</span>] ], [ doc ])</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果满足缓存条件, 在使用前 先复制一份</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   selector = (ret.cacheable ? jQuery.clone(ret.fragment): rest.fragment).childNodes</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将创建的 DOM 元素 合并到当前 jQuery 对象中返回</span></span><br><span class="line"> <span class="keyword">return</span> jQuery.merage(<span class="keyword">this</span>, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-id-且未指定参数-context"><a href="#如果参数-selector-是-id-且未指定参数-context" class="headerlink" title="如果参数 selector 是 #id, 且未指定参数 context"></a>如果参数 selector 是 <code>#id</code>, 且未指定参数 context</h2><p>如果参数 selector 是 <code>#id</code>, 且未指定参数 context, 则调用 document.getElementById() 查找含有指定 id 属性的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 查找含有指定 id 属性的 DOM 元素</span></span><br><span class="line">  elem = <span class="built_in">document</span>.getElementById(mathc[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elem &amp;&amp; elem.parentNode) &#123;</span><br><span class="line">    <span class="comment">// 检查 id 是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (elem.id !== match[<span class="number">2</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> rootjQuery.find(selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>[<span class="number">0</span>] = elem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span>;</span><br><span class="line">  <span class="keyword">this</span>.selector = selector;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是选择器表达式"><a href="#参数-selector-是选择器表达式" class="headerlink" title="参数 selector 是选择器表达式"></a>参数 selector 是选择器表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HANDLE: $(expr, $(...))</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context || context.jquery) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果执行了上下文 且上下文是 jQuery 对象 执行 context.find() 方法</span></span><br><span class="line"><span class="comment">   * 如果没有指定上下文 就执行 rootjQuery.find()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (context || rootjQuery).find(selector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HANDLE: $(expr, context)</span></span><br><span class="line">  <span class="comment">// (which is just equivalent to: $(context).find(expr)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果指定了上下文 但上下文不是jQuery对象 则执行方法先创建一个包含 context 的 jQuery 对象, 然后调用 find() 方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.constructor(context).find(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是函数"><a href="#参数-selector-是函数" class="headerlink" title="参数 selector 是函数"></a>参数 selector 是函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是函数 就绑定 ready 事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jQuery.isFunction(selector))&#123;</span><br><span class="line">  <span class="keyword">return</span> rootjQuery.ready(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-jQuery-对象"><a href="#如果参数-selector-是-jQuery-对象" class="headerlink" title="如果参数 selector 是 jQuery 对象"></a>如果参数 selector 是 jQuery 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参数包含 selector 就认为是 jQuery 对象</span></span><br><span class="line"><span class="keyword">if</span> (selector.selector !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// 复制他的属性 selector 和 context</span></span><br><span class="line">  <span class="keyword">this</span>.selector = selector.selector;</span><br><span class="line">  <span class="keyword">this</span>.context = selector.context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是任意其他值"><a href="#参数-selector-是任意其他值" class="headerlink" title="参数 selector 是任意其他值"></a>参数 selector 是任意其他值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 selector 是数组或伪数组, 则添加到当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果 selector 是 JavaScript 对象, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果是其他类型的值, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 最后返回当前 jQuery 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> jQuery.makeArray(selector, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img data-src="../../images/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init_.png" alt="jQuery.fn.init_"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery-fn-init-selector-context-rootjQuery&quot;&gt;&lt;a href=&quot;#jQuery-fn-init-selector-context-rootjQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery.f
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery源码结构</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-25T07:54:10.000Z</published>
    <updated>2020-03-25T08:29:59.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造-jQuery-对象的总体源码结构"><a href="#构造-jQuery-对象的总体源码结构" class="headerlink" title="构造 jQuery 对象的总体源码结构"></a>构造 jQuery 对象的总体源码结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自调用匿名函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 jQuery</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回 jQuery.fn.init 的实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 定义一堆变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖构造函数 jQuery() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn = jQuery.protottype = &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 覆盖原型对象的属性 constructor</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">      /**</span><br><span class="line">       * 定义原型方法 负责解析 selector 和 context 的类型并执行相应的查找</span><br><span class="line">      */</span><br><span class="line">      init: function(selector, context, rootjQuery) &#123;</span><br><span class="line">        <span class="comment">// ... 一堆原型属性和方法</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 jQuery 构造函数的原型对象 jQuery.fn 覆盖 jQuery.fn.init() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个或多个对象的属性到第一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 jQuery.extend() 在jQuery构造器上定义了一堆静态属性和方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">      <span class="comment">// 一堆静态属性和方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 jQuery 构造函数并赋值给外层变量 jQuery</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把 jQuery 、 $ 暴露给全局作用域 window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h2 id="为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例"><a href="#为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例" class="headerlink" title="为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例"></a>为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例</h2><p>如果构造函数有返回值, 运算符 new 所创建的对象会被丢弃, 返回值将作为 new 表达式的值</p><p>jQuery 利用这一特性, 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例, 省去构造函数 jQuery() 前面的运算符 new</p><h2 id="为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype"></a>为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype</h2><p>jQuery.fn 是 jQuery.prototype 的简写, 方便拼写</p><h2 id="jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性"><a href="#jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性" class="headerlink" title="jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性"></a>jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性</h2><p>用 jQuery()构造函数的原型对象覆盖了构造函数 jQuery.fn.init()的原型对象, 从而使得 jQuery.fn.init() 的实例也可以访问 jQuery()构造函数的原型方法核属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><h2 id="为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中"><a href="#为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中" class="headerlink" title="为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中"></a>为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中</h2><p>在自调用安徽省农户中定义了很多其他局部变量, 这些局部变量只在 jQuery 对象内部使用, 使用自调用匿名函数可以减少与其他模块的耦合度</p><h2 id="为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype"></a>为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype</h2><p>在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，可以有效减少每个 jQuery 对象所需的内存。事实上，jQuery 对象只包含 5 种非继承属性，其余都继承自原型对象 jQuery.prototype；在构造函数 jQuery.fn.init()中设置了整型属性、length、selector、context；在原型方法.pushStack()中设置了 prevObject。因此，也不必因为 jQuery 对象带有太多的属性和方法而担心会占用太多的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造-jQuery-对象的总体源码结构&quot;&gt;&lt;a href=&quot;#构造-jQuery-对象的总体源码结构&quot; class=&quot;headerlink&quot; title=&quot;构造 jQuery 对象的总体源码结构&quot;&gt;&lt;/a&gt;构造 jQuery 对象的总体源码结构&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/</id>
    <published>2020-03-25T07:51:57.000Z</published>
    <updated>2020-03-25T07:52:07.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数-jQuery"><a href="#构造函数-jQuery" class="headerlink" title="构造函数 jQuery"></a>构造函数 jQuery</h1><p>构造函数 jQuery 有七种用法:</p><ul><li>jQuery(select [,context]): 接受一个 CSS 选择器表达式和可选的选择器上下文, 返回一个包含了匹配的 DOM 元素的 jQuery 对象</li><li>jQuery(html,[, ownerDocument])、jQuery(html, props): 用提供的 HTML 代码创建 DOM 元素</li><li>jQuery(element)、jQuery(elementArray): 封装 DOM 元素为 jQuery 对象</li><li>jQuery(object): 封装普通对象为 jQuery 对象</li><li>jQuery(callback): 绑定 ready 事件监听函数, 当 DOM 结构加载完成时执行</li><li>jQuery(jQuery object): 接受一个 jQuery 对象, 返回该 jQuery 对象的拷贝副本</li><li>jQuery(): 创建一个 jQuery 对象</li></ul><h2 id="jQuery-select-context"><a href="#jQuery-select-context" class="headerlink" title="jQuery(select [,context])"></a>jQuery(select [,context])</h2><p>如果传入一个字符串参数, jQuery 会检查这个字符串是选择器表达式还是 HTML 代码. 如果是选择器表达式, 则遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象. 如果没有元素与之匹配, 则创建一个空 jQuery 对象, 其中不包含任何元素, 其属性 length 等于 0.</p><p>默认情况下, 对匹配元素的查找将从根元素 document 对象开始, 即查找范围是整个文档树, 不过也可以传入第二个参数 context 来限定查找范围</p><p>如果选择器表达式 selector 是简单的 <code>#id</code>, 且没有指定上下文 context, 则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素; 如果是比 <code>#id</code> 复杂的选择器表达式或指定了上下文, 则通过 jQuery 方法 <code>.find()</code> 查找, 因此 <code>$(&#39;span&#39;, this)</code> 等价于 <code>$(this).find(&#39;span&#39;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#app'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $('span', this).html(222);</span></span><br><span class="line">  $(<span class="keyword">this</span>)</span><br><span class="line">    .find(<span class="string">'span'</span>)</span><br><span class="line">    .html(<span class="string">'find'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-html-ownerDocument-、jQuery-html-props"><a href="#jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="jQuery(html [,ownerDocument])、jQuery(html, props)"></a>jQuery(html [,ownerDocument])、jQuery(html, props)</h2><h3 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h3><p>如果传入的字符串参数看起来像一段 HTML 代码, jQuery 则尝试用这段 HTML 代码创建新的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;button&gt;CLICK ME&lt;/button&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><p>如果 HTML 代码是一个单独标签, jQuery 会使用浏览器原生方法 document.createElement() 创建 DOM 元素</p><p>如果是多层嵌套 HTML 片段, 则利用浏览器的 innerHTML 机制创建 DOM 元素, 这个过程由 <code>jQuery.buildFragment()</code> 和 <code>jQuery.clean()</code> 实现</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>ownerDocument 用于指定创建新 DOM 元素的文档对象, 如果不传入, 则默认为当前文档对象</p><p>如果 HTML 代码是一个单独标签, 那么第二个参数还可以是 props, props 是一个包含了属性、事件的普通对象; 在调用 document.createElement() 创建 DOM 元素后, 参数 props 会被传给 jQuery 方法 <code>.attr()</code>, 然后由 <code>.attr()</code> 负责把 props 中的属性、事件设置到新穿创建的 DOM 元素上</p><p>参数 props 的属性可以是任意的事件类型（如”click”），此时属性值应该是事件监听函数，它将被绑定到新创建的 DOM 元素上；参数 props 可以含有以下特殊属性：val、css、html、text、data、width、height、offset，相应的 jQuery 方法：<code>.val()</code>、<code>.css()</code>、<code>.html()</code>、<code>.text()</code>、<code>.data()</code>、<code>.width()</code>、<code>.height()</code>、`.offset()将被执行，并且属性值会作为参数传入；其他类型的属性则会被设置到新创建的 DOM 元素上，某些特殊属性还会做跨浏览器兼容（如 type、value、tabindex 等）；可以通过属性名 class 设置类样式，但要用引号把 class 包裹起来，因为 class 是 JavaScript 保留字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;div /&gt;'</span>, &#123;</span><br><span class="line">  text: <span class="string">'哈哈'</span>,</span><br><span class="line">  class: 'active',</span><br><span class="line">  click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="keyword">this</span>.innerHTML = <span class="string">'嘻嘻'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><h2 id="jQuery-element-、jQuery-elementArray"><a href="#jQuery-element-、jQuery-elementArray" class="headerlink" title="jQuery(element)、jQuery(elementArray)"></a>jQuery(element)、jQuery(elementArray)</h2><p>如果传入一个 DOM 元素或 DOM 元素数组, 则把 DOM 元素封装到 jQuery 对象中并返回</p><p>这个功能常见于事件监听函数, 即把关键字 this 因用那个的 DOM 元素封装为 jQuery 对象, 然后在该 jQuery 对象上调用 jQuery 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).slideUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-object"><a href="#jQuery-object" class="headerlink" title="jQuery(object)"></a>jQuery(object)</h2><p>如果传入一个普通 JavaScript 对象, 则把该对象封装到 jQuery 对象中并返回</p><p>这个功能可以方便的在普通 JavaScript 对象上实现自定义事件的绑定和触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $foo = $(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'worldd'</span> &#125;);</span><br><span class="line">$foo.on(<span class="string">'custom'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;);</span><br><span class="line">$foo.trigger(<span class="string">'custom'</span>); <span class="comment">// -&gt; foo</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-callback"><a href="#jQuery-callback" class="headerlink" title="jQuery(callback)"></a>jQuery(callback)</h2><p>如果传入一个函数, 则在 document 上绑定一个 ready 事件监听函数, 当 DOM 结构加载完成时执行. ready 事件的触发要早于 load 事件.</p><p>ready 事件并不是浏览器原生事件, 而是 DOMContentLoaded 事件、onreadystatechange 事件和函数 doScrollCheck() 的统称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM 加载完毕'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-jQuery-object"><a href="#jQuery-jQuery-object" class="headerlink" title="jQuery(jQuery object)"></a>jQuery(jQuery object)</h2><p>如果传入一个 jQuery 对象, 则创建该 jQuery 对象的一个副本并返回, 副本与传入的 jQuery 对象引用完全相同的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $app = $(<span class="string">'#app'</span>);</span><br><span class="line">$app.html(<span class="string">'xuxu'</span>); <span class="comment">// -&gt; $('#app').html('xuxu')</span></span><br></pre></td></tr></table></figure><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery()"></a>jQuery()</h2><p>如果不传入任何参数, 则返回一个空的 jQuery 对象, 属性 length 为 0.</p><p>这个功能可以用来复用 jQuery 对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数-jQuery&quot;&gt;&lt;a href=&quot;#构造函数-jQuery&quot; class=&quot;headerlink&quot; title=&quot;构造函数 jQuery&quot;&gt;&lt;/a&gt;构造函数 jQuery&lt;/h1&gt;&lt;p&gt;构造函数 jQuery 有七种用法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQ
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-总体架构</title>
    <link href="http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-23T06:47:26.000Z</published>
    <updated>2020-03-23T06:47:59.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>jQuery 的模块总体分为三大部分:</p><ul><li>入口模块(构造 jQuery 对象模块)</li><li>功能模块</li><li>底层支持模块</li></ul><p><img data-src="../images/01%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/jQuery.png" alt="模块导图"></p><h2 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h2><p>入口模块主要功能是构造 jQuery 对象, 如果在调用构造函数 <code>jQuery()</code> 创建 jQuery 对象时传入了选择器表达式, 则会调用功能模块中的选择器 <code>Sizzle</code> 遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象</p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>在功能模块中, 事件系统提供了统一的事件绑定、响应、手动触发和移除机制, 它并没有将事件直接绑定到 DOM 元素上, 而是基于数据缓存模块来管理事件</p><h3 id="Ajax-模块"><a href="#Ajax-模块" class="headerlink" title="Ajax 模块"></a>Ajax 模块</h3><p>Ajax 模块允许从服务器上加载数据, 而不用刷新页面, 它基于异步队列模块来管理核触发回调函数</p><h3 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h3><p>动画模块用于向网页中添加动画效果, 它基于队列模块来管理和执行动画函数</p><h3 id="属性操作模块"><a href="#属性操作模块" class="headerlink" title="属性操作模块"></a>属性操作模块</h3><p>属性操作模块时用于对 HTML 属性和 DOM 属性进行读取、设置和移除操作</p><h3 id="DOM-遍历模块"><a href="#DOM-遍历模块" class="headerlink" title="DOM 遍历模块"></a>DOM 遍历模块</h3><p>DOM 遍历模块用于在 DOM 树中遍历父元素、子元素和兄弟元素</p><h3 id="DOM-操作模块"><a href="#DOM-操作模块" class="headerlink" title="DOM 操作模块"></a>DOM 操作模块</h3><p>DOM 操作模块用于插入、移除、复制和替换 DOM 元素</p><h3 id="样式操作模块"><a href="#样式操作模块" class="headerlink" title="样式操作模块"></a>样式操作模块</h3><p>样式操作模块用于获取计算样式或设置内联样式</p><h3 id="坐标模块"><a href="#坐标模块" class="headerlink" title="坐标模块"></a>坐标模块</h3><p>坐标模块用于读取或设置 DOM 元素的文档坐标</p><h3 id="尺寸模块"><a href="#尺寸模块" class="headerlink" title="尺寸模块"></a>尺寸模块</h3><p>尺寸模块用于获取 DOM 元素的高度和宽度</p><h2 id="底层支持模块"><a href="#底层支持模块" class="headerlink" title="底层支持模块"></a>底层支持模块</h2><p>底层支持模块又分为诸多子模块:</p><ul><li>工具方法: Utilities</li><li>回调函数列表: Callbacks Object</li><li>异步队列: Deferred Object</li><li>浏览器功能测试: Support</li><li>数据缓存: Data</li><li>队列: Queue</li><li>选择器: Sizzle</li></ul><h3 id="工具方法模块"><a href="#工具方法模块" class="headerlink" title="工具方法模块"></a>工具方法模块</h3><p>工具方法模块提供了一些编程辅助方法, 用于简化对 jQuery 对象、DOM 元素、数组、对象、字符串等的操作, 其他模块都会用到工具方法模块</p><h3 id="回调函数列表模块"><a href="#回调函数列表模块" class="headerlink" title="回调函数列表模块"></a>回调函数列表模块</h3><p>回调函数列表模块用于增强对回调函数的管理，支持添加、移除、触发、锁定、禁用回调函数等功能；</p><h3 id="异步队列模块"><a href="#异步队列模块" class="headerlink" title="异步队列模块"></a>异步队列模块</h3><p>异步队列模块用于解耦异步任务和回调函数, 他再回调列表的基础上为回调函数增加了状态, 并提供多个回调函数列表, 支持传播任意同步或异步回调函数的成功或失败状态</p><h3 id="浏览器功能测试模块"><a href="#浏览器功能测试模块" class="headerlink" title="浏览器功能测试模块"></a>浏览器功能测试模块</h3><p>浏览器功能测试模块提供了针对不同浏览器功能和 bug 的测试结果, 其他模块基于这些测试结果来解决浏览器之间的兼容性问题</p><h3 id="数据缓存模块"><a href="#数据缓存模块" class="headerlink" title="数据缓存模块"></a>数据缓存模块</h3><p>数据缓存模块用于为 DOM 元素和 JavaScript 对象附加任意类型的数据</p><h3 id="队列模块"><a href="#队列模块" class="headerlink" title="队列模块"></a>队列模块</h3><p>队列模块用于管理一组函数, 支持函数的入队核出队操作, 并确保函数按顺序执行, 它基于数据缓存模块实现</p><h3 id="选择器模块"><a href="#选择器模块" class="headerlink" title="选择器模块"></a>选择器模块</h3><p>选择器 <code>sizzle</code> 是一个纯 JavaScript 实现的 CSS 选择器引擎, 用于查找与选择表达式匹配的元素集合</p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jQuery = (</span><br><span class="line">    <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery)</span><br><span class="line">    &#125;)()</span><br><span class="line">    <span class="keyword">return</span> jQuery</span><br><span class="line">  )()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工具方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调函数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浏览器功能测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件系统</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 样式操作 CSS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坐标</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h1&gt;&lt;p&gt;jQuery 的模块总体分为三大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口模块(构造 jQuery 对象模块)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>vuex-api</title>
    <link href="http://yoursite.com/2020/03/21/vuex-api/"/>
    <id>http://yoursite.com/2020/03/21/vuex-api/</id>
    <published>2020-03-21T01:40:44.000Z</published>
    <updated>2020-03-21T01:41:01.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex-Store"><a href="#Vuex-Store" class="headerlink" title="Vuex.Store"></a>Vuex.Store</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; ...options &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex-Store-构造器选项"><a href="#Vuex-Store-构造器选项" class="headerlink" title="Vuex.Store 构造器选项"></a>Vuex.Store 构造器选项</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>类型: <code>Object | Function</code><br>Vuex store 实例的根 state 对象</p><p>如果传入返回一个对象的函数, 其返回的对象会被用作根 state.</p></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li>类型: <code>{ [type: string ]: Function }</code><br>在 store 上注册 mutation, 处理函数总是接受 <code>state</code> 作为第一个参数(如果定义在模块中, 则为模块的局部状态), <code>payload</code>作为第二个参数</li></ul><h3 id="sctions"><a href="#sctions" class="headerlink" title="sctions"></a>sctions</h3><ul><li><p>类型: <code>{ [type: string]: Function }</code><br>在 store 上注册 action. 处理函数总是接受 <code>context</code> 作为第一个参数, <code>payload</code> 作为第二个参数</p><p><code>context</code> 对象包含以下属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state, <span class="comment">// 等同于 `store.state`，若在模块中则为局部状态</span></span><br><span class="line">    rootState, <span class="comment">// 等同于 `store.state`，只存在于模块中</span></span><br><span class="line">    commit, <span class="comment">// 等同于 `store.commit`</span></span><br><span class="line">    dispatch, <span class="comment">// 等同于 `store.dispatch`</span></span><br><span class="line">    getters, <span class="comment">// 等同于 `store.getters`</span></span><br><span class="line">    rootGetters <span class="comment">// 等同于 `store.getters`，只存在于模块中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ul><li><p>类型: <code>{ [type: string ]: Function}</code></p><p>在 store 上注册 getter, getter 方法接受以下参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state, getters</span><br></pre></td></tr></table></figure><p>当定义在一个模块粒时会特别一些:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state, <span class="comment">// 如果在模块中定义则为模块的局部状态</span></span><br><span class="line">  getters, <span class="comment">// 等同于 store.getters</span></span><br><span class="line">  rootState, <span class="comment">// 等同于 store.state</span></span><br><span class="line">  rootGetters <span class="comment">// 所有 getters</span></span><br></pre></td></tr></table></figure><p>注册的 getter 为暴露为 getters</p></li></ul><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ul><li>类型: <code>Object</code><br>包含了子模块的对象, 会被合并到 store<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    state,</span><br><span class="line">    namespaced?,</span><br><span class="line">    mutations,</span><br><span class="line">    actions?,</span><br><span class="line">    getters?,</span><br><span class="line">    modules?</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>与根模块的选项一样, 每个模块也包含 <code>state</code> 和 <code>mutations</code> 选项. 模块的状态使用 <code>key</code> 关联到 store 的根状态. 模块的 mutation 和 getter 只会接受 module 的局部状态作为第一个参数, 而不是根状态, 并且模块的 action 的 <code>context.state</code> 同样指向局部状态</li></ul><h3 id="pulgins"><a href="#pulgins" class="headerlink" title="pulgins"></a>pulgins</h3><ul><li>类型: <code>Array&lt;Function&gt;</code><br>一个数组, 包含应用在 store 上的插件方法. 这些插件直接接受 store 作为唯一参数, 可以监听 mutation 或者提交 mutation</li></ul><h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><ul><li>类型: <code>Boolean</code></li><li>默认值: <code>false</code><br>使 Vuex store 进入严格模式, 在严格模式下, 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</li></ul><h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul><li>类型: <code>Boolean</code><br>为某个特定的 Vuex 实例打开或关闭 devtools. 对于传入 false 的实例来说 Vuex store 不会订阅到 devtools 插件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  devtools: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vuex-Store-实例属性"><a href="#Vuex-Store-实例属性" class="headerlink" title="Vuex.Store 实例属性"></a>Vuex.Store 实例属性</h2><h3 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h3><ul><li>类型: <code>Object</code><br>根状态, 只读</li></ul><h3 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h3><ul><li>类型: <code>Object</code><br>暴露出注册的 getter, 只读</li></ul><h2 id="Vuex-Store-实例方法"><a href="#Vuex-Store-实例方法" class="headerlink" title="Vuex.Store 实例方法"></a>Vuex.Store 实例方法</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul><li><p><code>commit(type: string, payload?:any, options?: Object)</code></p></li><li><p><code>commit(mutation: Object, options?: Object)</code></p><p>提交 mutation, <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里提交根的 mutation</p></li></ul><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><ul><li><p><code>dispatch(type: string, payload?:any, options?: Pbject)</code></p></li><li><p><code>dispatch(action: Object, options?: Object)</code></p><p>分发 action. <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里分发根的 action. 返回一个解析所有被触发的 action 处理器的 Promise</p></li></ul><h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h3><ul><li><p><code>replaceState(state: Object)</code></p><p>替换 store 的根状态, 仅用状态合并或时光旅行调试</p></li></ul><h3 id="wathc"><a href="#wathc" class="headerlink" title="wathc"></a>wathc</h3><ul><li><p><code>watch(fn: Function, callback: Funtion, options?: Object): Function</code></p><p>响应式的侦听 <code>fn</code> 的返回值, 当值改变时调用回调函数. <code>fn</code> 接受 store 的 state 作为第一个参数, 其 getter 作为第二个参数, 最后接受一个可选对象参数表示 Vue 的<code>vm.$watch</code>方法的参数</p><p>要停止侦听, 调用此方法返回的函数即可停止侦听</p></li></ul><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><ul><li><p><code>subscribe(handler: Function):Function</code></p><p>订阅 store 的 mutation. <code>hanlder</code> 会在每个 mutation 完成后调用, 接受 mutation 和经过 mutation 后的状态作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.type)</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.paylaod)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅, 调用此方法返回的函数可停止订阅</p></li></ul><h3 id="subscribeAction"><a href="#subscribeAction" class="headerlink" title="subscribeAction"></a>subscribeAction</h3><ul><li><p><code>subscribeAction(handler: Function): Function</code></p><p>订阅 store 的 action。handler 会在每个 action 分发的时候调用并接收 action 描述和当前的 store 的 state 这两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(action.type)</span><br><span class="line">  <span class="built_in">console</span>.log(action.payload)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅，调用此方法返回的函数即可停止订阅。</p><p>从 3.1.0 起，subscribeAction 也可以指定订阅处理函数的被调用时机应该在一个 action 分发之前还是之后 (默认行为是之前)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(&#123;</span><br><span class="line">  before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="registerModule"><a href="#registerModule" class="headerlink" title="registerModule"></a>registerModule</h3><ul><li><p><code>registerModule(path: string | Array&lt;string&gt;, module: Module, options?: Object)</code></p><p>注册一个动态模块</p><p>options 可以包含 <code>preserveState: true</code> 以允许保留之前的 state。用于服务端渲染。</p></li></ul><h3 id="unregisterModule"><a href="#unregisterModule" class="headerlink" title="unregisterModule"></a>unregisterModule</h3><ul><li><p><code>unregisterModule(path: string | Array&lt;string&gt;)</code></p><p>卸载一个动态模块。</p></li></ul><h3 id="hotUpdate"><a href="#hotUpdate" class="headerlink" title="hotUpdate"></a>hotUpdate</h3><ul><li><p><code>hotUpdate(newOptions: Object)</code></p><p>热替换新的 action 和 mutation。详细介绍</p></li></ul><h2 id="组件绑定的辅助函数"><a href="#组件绑定的辅助函数" class="headerlink" title="组件绑定的辅助函数"></a>组件绑定的辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><ul><li><p><code>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | Function&gt;): Object</code></p><p>为组件创建计算属性以返回 Vuex store 中的状态</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数</p></li></ul><h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><ul><li><p><code>mapGetters(namespace?: string, map: Array&lt;string&gt; | Object&lt;string&gt;): Object</code></p><p>为组件创建计算属性以返回 getter 的返回值</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p></li></ul><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><ul><li><p><code>mapActions(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法分发 action</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(dispatch: function, ...args: any[])</code></p></li></ul><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><ul><li><p><code>mapMutations(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法提交的 mutation</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(commit: function, ...args: any[])</code></p></li></ul><h3 id="createNamespacedHelpers"><a href="#createNamespacedHelpers" class="headerlink" title="createNamespacedHelpers"></a>createNamespacedHelpers</h3><ul><li><p><code>createNamespacedHelpers(namespace: string): Object</code></p><p>创建基于命名空间的组件绑定辅助函数。其返回一个包含 mapState、mapGetters、mapActions 和 mapMutations 的对象。它们都已经绑定在了给定的命名空间上</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex-Store&quot;&gt;&lt;a href=&quot;#Vuex-Store&quot; class=&quot;headerlink&quot; title=&quot;Vuex.Store&quot;&gt;&lt;/a&gt;Vuex.Store&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Module</title>
    <link href="http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/"/>
    <id>http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/</id>
    <published>2020-03-20T01:48:54.000Z</published>
    <updated>2020-03-20T01:49:10.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有可能变得相当臃肿</p><p>为了解决以上问题, Vuex 允许我们将 store 分割成模块. 每个模块拥有自己的 state、Mutation、Action、Getter、甚至是嵌套子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><h2 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h2><p>对于模块内部的 mutaion 和 getter, 接受的第一个参数是模块的局部状态对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 此处 state 是局部的状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样, 对于模块内部的 action, 局部状态通过 <code>context.state</code> 暴露出来, 根节点状态则为 <code>context.rootState</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum(&#123;state, commit, rootState&#125;)&#123;</span><br><span class="line">      <span class="keyword">if</span>((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于模块内部的 getter, 根节点状态会作为第三个参数暴露出来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount(state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下, 模块内部的 action、mutation 和 getter 是注册在全局命名空间的–这样使得多个模块能够对同一 mutation 或 action 做出反应</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容 (module assets)</span></span><br><span class="line">      state: &#123; ... &#125; <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>, <code>dispatch</code> 和 <code>commit</code>. 换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码</p><h3 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h3><p>如果希望使用全局 state 和 getter, <code>rootState</code> 和 ``rootState<code>会作为第三和第四参数传入 getter, 也会通过</code>context<code>对象的属性传入</code>action`</p><p>若需要在全局命名空间内分发 action 或提交 mutation, 将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中, getters 被局部化了</span></span><br><span class="line">      <span class="comment">// 可以使用 getter 的第四个参数来调用 rootGetters</span></span><br><span class="line">      someGetter( state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; foo/someOtherGetter</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; someOtherGetter</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    acctions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中, dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 root 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction(&#123;dispatch, commit, getters, rootGetters&#125;) &#123;</span><br><span class="line">        getters.somegetter <span class="comment">// -&gt; foo/somegetter</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; somegetter</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; foo/someOtherAction</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someOtherAction</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; foo/someMutation</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someMutation</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction(ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="headerlink" title="在带命名空间的模块注册全局 action"></a>在带命名空间的模块注册全局 action</h3><p>若要在带命名空间的模块注册全局 action, 可以添加 <code>root: true</code>, 并将这个 action 定义放在函数 <code>handler</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction(&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">'someAction'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler( namespacedContext, patload) &#123; ... &#125; <span class="comment">// -&gt; someAction</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>当使用 <code>mapState</code>、<code>mapgetters</code>、<code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时, 写起来可能比较繁琐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  )]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述情况, 可以将模块的空间名称字符串作为第一个参数传递给上述函数, 这样所有绑定都会自动将该模块作为上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且可以使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数, 它返回一个对象, 对象里有新的绑定在给定命名空间值上的组件绑定辅助函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapAcrions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapActions([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h2><p>如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过插件的参数对象得到空间名称</span></span><br><span class="line"><span class="comment">// 然后返回 Vuex 插件函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPlugin</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把空间名字添加到插件模块的类型（type）中去</span></span><br><span class="line">    <span class="keyword">const</span> namespace = options.namespace || <span class="string">''</span></span><br><span class="line">    store.dispatch(namespace + <span class="string">'pluginAction'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h2><p>在 <code>store</code> 创建之后, 可以使用 <code>store.registerModule</code> 方法注册模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）</p><h3 id="保留-state"><a href="#保留-state" class="headerlink" title="保留 state"></a>保留 state</h3><p>在注册一个新 module 时, 你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</p><p>当你设置 preserveState: true 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</p><h2 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h2><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li>创建多个 store, 他们公用一个模块</li><li>在一个 store 中多次注册同一模块</li></ul><p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p><p>实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Module&quot;&gt;&lt;a href=&quot;#Module&quot; class=&quot;headerlink&quot; title=&quot;Module&quot;&gt;&lt;/a&gt;Module&lt;/h2&gt;&lt;p&gt;由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Action</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/</id>
    <published>2020-03-19T02:24:14.000Z</published>
    <updated>2020-03-21T01:40:54.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation, 不同在于:</p><ul><li>Action 提交的是 mutation, 而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><p>注册一个简单的 action:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个 store 实例具有相同方法核属性的 context 对象, 因此你可以调用 <code>context.commit</code> 提交一个 mutation, 或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p><p>实践中, 我们经常会用到 ES2015 的参数解构来简化代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h2><p>Action 通过 <code>store.dispatch</code> 方法触发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><p>action 内部可以执行异步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync(&#123;commit&#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  cmount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h2><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action, 或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">    <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h2><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise, 并且 <code>store.dispatch</code> 仍旧返回 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 可以利用 async/await 组合 action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>)</span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h2&gt;&lt;p&gt;Action 类似于 mutation, 不同在于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action 提交的是 mu
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Mutation</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/</id>
    <published>2020-03-19T01:58:02.000Z</published>
    <updated>2020-03-19T01:58:13.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的 mutation 非常类似于事件:每个 mutation 都有一个字符串的事件类型和一个回调函数. 这个回调函数就是我们实际进行状态更改的地方, 并且他会接受 state 作为第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不能直接调用一个 mutation handler. 这个选项更像是事件注册: “当触发一个类型为 <code>increment</code> 的 mutation 时, 调用此函数. “要唤醒一个 mutation handler, 需要已相应的 type 调用 <code>store.commit</code> 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><h2 id="提交载荷-Payload"><a href="#提交载荷-Payload" class="headerlink" title="提交载荷 (Payload)"></a>提交载荷 (Payload)</h2><p>可以向 <code>store.commit</code> 传入额外的参数, 即 mutation 的载荷 (Payload)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: <span class="function">(<span class="params">state, n</span>) =&gt;</span> &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在大多数情况下, 载荷应该是一个对象, 这样可以包含多个字段并且记录的 mutation 会更易读:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123; <span class="attr">amount</span>: <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用对象风格的提交方式, 整个对象都作为载荷传给 mutation 函数, 因此 handler 保持不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h2><p>既然 Vuex 的 store 中的状态是响应式的, 那么当我们变更状态时, 监视状态的 Vue 组件也会自动更新. 这也意味着 Vuex 中的 mutation 也需要与使用 Vuex 一样遵守一些注意事项</p><ol><li>最好提前在 store 中初始化好所有的所需属性</li><li>当需要在对象上添加新属性时, 应该:</li></ol><ul><li>使用 Vue.set(obj, ‘newProp’, 123)</li><li>以新对象替换老对象. 例如, 利用对象展开运算符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用常亮代替-Mutation-事件类型"><a href="#使用常亮代替-Mutation-事件类型" class="headerlink" title="使用常亮代替 Mutation 事件类型"></a>使用常亮代替 Mutation 事件类型</h2><p>使用常亮替代 mutation 事件类型在各种 Flux 实现中是很常见的模式. 这样可以使 linter 之类的工具发挥作用, 同时把这些常亮放在单独的文件中可以让代码合作者对整个 app 包含的 mutation 一目了然</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION](state) &#123;</span><br><span class="line">      <span class="comment">//  mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h2><p>一条重要的原则就是 mutation 必须是同步函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation(state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h2 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h2><p>可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation, 或者使用 <code>mapMutation</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">'increment'</span>, <span class="string">'incrementby'</span>]),</span><br><span class="line">    ...mapMutations([(add: <span class="string">'increment'</span>)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mutation&quot;&gt;&lt;a href=&quot;#Mutation&quot; class=&quot;headerlink&quot; title=&quot;Mutation&quot;&gt;&lt;/a&gt;Mutation&lt;/h2&gt;&lt;p&gt;更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Getter</title>
    <link href="http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/"/>
    <id>http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/</id>
    <published>2020-03-18T08:30:52.000Z</published>
    <updated>2020-03-18T08:31:06.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个组件需要用到此属性, 我们要复制这个函数, 或者抽取到一个共享函数然后在多处导入它</p><p>Vuex 允许我们在 store 中定义 getter(可以认为是 store 的计算属性). 就像计算属性一样. getter 的返回值会根据他的依赖被缓存起来, 且只有当它的依赖值发生了改变才会被重新计算.</p><p>Getter 接受 state 作为其第一个参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h2><p>getter 会暴露 <code>store.getters</code> 对象, 可以以属性的形式访问这些值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123;id:1, text: '...', done: true&#125;]</span></span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.state.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们可以很容易的在任何组件中使用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的</p><h2 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h2><p>也可以通过让 getter 返回一个函数, 来实现给 getter 传参.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> tido.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// &#123; id: 2, text: '...', done: false&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>getter 在通过方法访问时, 每次都会去进行调用, 不会缓存结果.</p></blockquote><h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p><code>mapgetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapgetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([<span class="string">'doneTodosCount'</span>, <span class="string">'anotherGetter'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想将一个 getter 属性另取一个名字, 使用对象形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapGetters([(doneCount: <span class="string">'doneTodosCount'</span>)])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Getter&quot;&gt;&lt;a href=&quot;#Getter&quot; class=&quot;headerlink&quot; title=&quot;Getter&quot;&gt;&lt;/a&gt;Getter&lt;/h2&gt;&lt;p&gt;有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-State</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/</id>
    <published>2020-03-17T07:30:16.000Z</published>
    <updated>2020-03-17T07:30:29.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用 <strong>单一状态树</strong> 用一个对象就包含了全部的应用层级状态. 至此它便作为一个唯一数据源而存在. 意味着, 每个应用将仅仅包含一个 store 实例. 单一状态树让我们能够直接地定位任一特定的状态片段, 在调试的过程中也能轻易地取得整个当前应用状态的快照.</p><h3 id="在组件中获得-Vuex-状态"><a href="#在组件中获得-Vuex-状态" class="headerlink" title="在组件中获得 Vuex 状态"></a>在组件中获得 Vuex 状态</h3><p>由于 Vuex 的状态储存是响应式的, 从 store 实例中读取状态的最简单的方法就是在计算属性中返回某个状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter - &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性, 并且触发更新相关联的 DOM</p><p>然而, 这种模式导致组件依赖全局状态单例. 在模块化的构建系统中, 在每个需要使用 state 的组件中需要频繁的导入, 并且在测试组件时需要模拟状态</p><p>Vuex 通过 <code>store</code> 选项, 提供了一种机制将状态从根组件注入到每一个子组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class='app'&gt;</span></span><br><span class="line"><span class="string">    &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过在根实例中注册 <code>store</code> 选项, 该 store 实例会注入到根组件下的所有子组件中, 且子组件能通过 <code>this.$store</code> 访问到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>当一个组件需要获取多个状态的时候, 将这些状态都声明为计算属性会有些重复和冗余, 为了解决这个问题, 我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数更简洁</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 count 等同于 state =&gt; state.count</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性名称与 state 的子节点名称相同时, 我们也可以给 <code>mapState</code> 传一个字符串数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">computed: mapState([<span class="string">'count'</span>])</span><br></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p><code>mapState</code> 函数返回的是一个对象, 可以通过展开运算符将它与局部计算属性混合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState([<span class="string">'count'</span>]),</span><br><span class="line">  localComputed() &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件仍保有局部状态"><a href="#组件仍保有局部状态" class="headerlink" title="组件仍保有局部状态"></a>组件仍保有局部状态</h3><p>使用 Vuex 并不意味着需要将所有的状态放入 Vuex. 如果有些状态严格属于单个组件, 最好还是作为组件的局部状态.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;State&quot;&gt;&lt;a href=&quot;#State&quot; class=&quot;headerlink&quot; title=&quot;State&quot;&gt;&lt;/a&gt;State&lt;/h2&gt;&lt;p&gt;Vuex 使用 &lt;strong&gt;单一状态树&lt;/strong&gt; 用一个对象就包含了全部的应用层级状态. 至此它便作为一
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex安装介绍与起步</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/</id>
    <published>2020-03-17T07:02:31.000Z</published>
    <updated>2020-03-17T07:02:47.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>直接下载 || CDN 引用 <a href="https://unpkg.com/vuex" target="_blank" rel="noopener">vuex</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vuex.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>NPM</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><ul><li>Yarn</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure><ul><li>在一个模块化的打包系统中, 必须显示地通过 <code>Vue.use()</code> 来安装 <code>Vuex</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h2 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么?"></a>Vuex 是什么?</h2><p>Vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式. 它采用集中式存储管理应用的所有组件的状态, 并已相应的规则保证状态以一种可预测的方式发生变化. Vuex 也集成到 Vue 的官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</p><h2 id="什么是状态管理模式"><a href="#什么是状态管理模式" class="headerlink" title="什么是状态管理模式?"></a>什么是状态管理模式?</h2><p>已一个简单的 Vue 记数应用开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个状态管理应用包含以下几个部分:</p><ul><li>state: 驱动应用的数据源</li><li>view: 以声明方式将 state 映射到试图</li><li>actions: 响应在 view 上的用户输入导致的状态变化</li></ul><p>以下是一个表示单项数据流理念的简单示意图:</p><p><img data-src="../../image/flow.png" alt="flow"></p><p>当我们遇到多个组件共享状态时, 单项数据流的简洁性很容易被破坏:</p><ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul><p>对于问题一, 传参的方法对于多层嵌套的组件将会非常繁琐, 并且对于兄弟组件间的状态传递无能为力<br>对于问题二, 我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝.</p><p>因此, 我们为什么不把组件的共享状态抽取出来, 以一个全局单例模式管理呢? 在这种模式下, 我们组件树构成了一个巨大的试图, 不管树在那个位置, 任何组件都能获取状态或者触发行为.</p><p>通过定义和隔离状态管理中的各种概念并通过强制规则维持试图和状态间的独立性,我们的代码将会变得更结构化且易维护</p><p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新</p><p><img data-src="../../image/vuex.png" alt="vuex"></p><h2 id="什么情况下应该使用-Vuex"><a href="#什么情况下应该使用-Vuex" class="headerlink" title="什么情况下应该使用 Vuex?"></a>什么情况下应该使用 Vuex?</h2><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每个 Vuex 应用的核心就是 store. store 基本上就是个容器, 它包含着你的应用中大部分的状态(state). Vuex 和单纯的全局对象有以下两个点不同</p><ol><li><p>Vuex 的状态存储是响应式的. 当 Vue 组件从 store 中读取状态的时候, 若 store 中的状态发生改变, 那么相应的组件也会响应的得到高效更新</p></li><li><p>不能直接修改 store 中的状态. 改变 store 中的状态的唯一途径就是显示的提交(commit)mutation. 这样使得我们可以方便的跟踪没一个状态的变化, 从而让我们能够实现一些工具帮助我们更好的了解我们的应用</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装 Vuex 之后, 我们可以创建一个 store.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在, 可以通过 <code>store.state</code> 来获取状态对象, 以及通过 <code>store.commit</code> 方法触发状态变更</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p><p>由于 store 中的状态是响应式的, 在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可. 触发变化也仅仅是在组件的 methods 中提交 mutation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接下载 || CDN 引用 &lt;a href=&quot;https://unpkg.com/vuex&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由对象与组件注入</title>
    <link href="http://yoursite.com/2020/03/16/vue-router%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/16/vue-router%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-16T05:11:19.000Z</published>
    <updated>2020-03-16T05:11:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由对象"><a href="#路由对象" class="headerlink" title="路由对象"></a>路由对象</h2><p>一个路由对象表示当前激活的路由的状态信息, 包含了当前 URL 解析得到的信息, 还有 URL 匹配到的路由记录</p><p>路由对象是不可变的, 每次成功导航后都会产生一个新的对象</p><p>路由对象出现在多个地方:</p><ul><li><p>组件内, <code>this.$route</code></p></li><li><p>在 <code>$route</code> 观察者回调内</p></li><li><p><code>router.match(localtion)</code> 返回值</p></li><li><p>导航守卫的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to 和 from 都是路由对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>scrollBehavior</code> 方法的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VurRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition)=&gt; &#123;</span><br><span class="line">    <span class="comment">// to 和 from 都是路由对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由对象属性"><a href="#路由对象属性" class="headerlink" title="路由对象属性"></a>路由对象属性</h2><ul><li><code>$route.path</code><ul><li>类型: string<br>字符串, 对应当前路由的路径, 总是解析为绝对路径,如: ‘/foo/bar’</li></ul></li><li><code>$route.params</code><ul><li>类型: Object<br>一个 key/value 对象, 包含了动态片段和全匹配片段, 如果没有路由参数, 就是一个空对象</li></ul></li><li><code>$route.query</code><ul><li>类型: Object<br>一个 key/value 对象，表示 URL 查询参数。例如，对于路径 <code>/foo?user=1</code>，则有 <code>$route.query.user == 1</code>，如果没有查询参数，则是个空对象。</li></ul></li><li><code>$route.hash</code><ul><li>类型: string<br>当前路由的 hash 值(带#), 如果没有 hash 值, 则为空字符串</li></ul></li><li><code>$route.fullPath</code><ul><li>类型: string<br>完成解析后的 url, 包含查询参数核 hash 的完整路径</li></ul></li><li><code>$route.matched</code><ul><li>类型: Array<RouteRecord><br>一个数组，包含当前路由的所有嵌套路径片段的路由记录 。路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。</li></ul></li></ul><pre><code>当 URL 为 `/foo/bar`，`$route.matched` 将会是一个包含从上到下的所有对象 (副本)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 下面的对象就是路由记录</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        <span class="comment">// 这也是个路由记录</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'bar'</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>$route.name</code><br>当前路由的名称</p></li><li><p><code>$route.redirectedFrom</code><br>如果存在重定向, 即为重定向来源的路由的名字</p></li></ul><h2 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h2><h3 id="注入的属性"><a href="#注入的属性" class="headerlink" title="注入的属性"></a>注入的属性</h3><p>通过在 Vue 根实例的 router 配置传入 router 实例，下面这些属性成员会被注入到每个子组件。</p><ul><li><p><code>this.$router</code></p></li><li><p>router 实例。</p></li><li><p><code>this.$route</code></p></li></ul><p>当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。</p><h3 id="增加的组件配置选项"><a href="#增加的组件配置选项" class="headerlink" title="增加的组件配置选项"></a>增加的组件配置选项</h3><ul><li><p>beforeRouteEnter</p></li><li><p>beforeRouteUpdate</p></li><li><p>beforeRouteLeave</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由对象&quot;&gt;&lt;a href=&quot;#路由对象&quot; class=&quot;headerlink&quot; title=&quot;路由对象&quot;&gt;&lt;/a&gt;路由对象&lt;/h2&gt;&lt;p&gt;一个路由对象表示当前激活的路由的状态信息, 包含了当前 URL 解析得到的信息, 还有 URL 匹配到的路由记录&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router实例</title>
    <link href="http://yoursite.com/2020/03/12/vue-router%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/12/vue-router%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-03-12T07:15:07.000Z</published>
    <updated>2020-03-12T07:15:17.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Router-实例属性"><a href="#Router-实例属性" class="headerlink" title="Router 实例属性"></a>Router 实例属性</h2><ul><li><p>router.app</p></li><li><p>类型: Vue instance<br>配置了 router 的 Vue 根实例</p></li><li><p>router.mode</p></li><li><p>类型: string<br>路由使用的模式</p></li><li><p>router.currentRoute</p></li><li><p>类型 Route<br>当前路由对应的路由信息对象</p></li></ul><h2 id="Router-实例方法"><a href="#Router-实例方法" class="headerlink" title="Router 实例方法"></a>Router 实例方法</h2><h3 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h3><ul><li><p>router.beforeEach</p></li><li><p>router.beforeResolv</p></li><li><p>router.afterResolve</p></li><li><p>router.afterEach</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都返回一个移除已注册的守卫/钩子的函数。</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 必须调用 `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 必须调用 `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态导航到一个新的-URL"><a href="#动态导航到一个新的-URL" class="headerlink" title="动态导航到一个新的 URL"></a>动态导航到一个新的 URL</h3><ul><li><p>router.push</p></li><li><p>router.replace</p></li><li><p>router.go</p></li><li><p>router.back</p></li><li><p>router.forward</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br><span class="line">router.push(location).then(onComplete).catch(onAbort)</span><br><span class="line">router.replace(location, onComplete?, onAbort?)</span><br><span class="line">router.replace(location).then(onComplete).catch(onAbort)</span><br><span class="line">router.go(n)</span><br><span class="line">router.back()</span><br><span class="line">router.forward()</span><br></pre></td></tr></table></figure></li></ul><h3 id="返回目标位置或当前路由匹配的组件数组"><a href="#返回目标位置或当前路由匹配的组件数组" class="headerlink" title="返回目标位置或当前路由匹配的组件数组"></a>返回目标位置或当前路由匹配的组件数组</h3><ul><li><p>router.getMatchedComponents</p><p>函数签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在服务端渲染的数据预加载时使用。</span></span><br><span class="line"><span class="keyword">const</span> matchedComponents: <span class="built_in">Array</span>&lt;Component&gt; = router.getMatchedComponents(location?)</span><br></pre></td></tr></table></figure></li></ul><h3 id="解析目标位置"><a href="#解析目标位置" class="headerlink" title="解析目标位置"></a>解析目标位置</h3><ul><li><p>router.resolve</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved: &#123;</span><br><span class="line">  location: Location;</span><br><span class="line">  route: Route;</span><br><span class="line">  href: string;</span><br><span class="line">&#125; = router.resolve(location, current?, append?)</span><br></pre></td></tr></table></figure><p>解析目标位置 (格式和 <router-link> 的 to prop 一样)</p></li><li><p>current 是当前默认的路由 (通常你不需要改变它)</p></li><li><p>append 允许你在 current 路由上附加路径 (如同 router-link)</p></li></ul><h3 id="动态添加更多的路由规则"><a href="#动态添加更多的路由规则" class="headerlink" title="动态添加更多的路由规则"></a>动态添加更多的路由规则</h3><ul><li><p>router.addRoutes</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。</span></span><br><span class="line">router.addRoutes((routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;))</span><br></pre></td></tr></table></figure></li></ul><h3 id="router-onReady"><a href="#router-onReady" class="headerlink" title="router.onReady"></a>router.onReady</h3><p>该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。<br>这可以有效确保服务端渲染时服务端和客户端输出的一致。<br>第二个参数 errorCallback 只在 2.4+ 支持。它会在初始化路由解析运行出错 (比如解析一个异步组件失败) 时被调用。</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.onReady(callback, [errorCallback])</span><br></pre></td></tr></table></figure><h3 id="router-onError"><a href="#router-onError" class="headerlink" title="router.onError"></a>router.onError</h3><p>注册一个回调，该回调会在路由导航过程中出错时被调用。注意被调用的错误必须是下列情形中的一种：</p><ul><li><p>错误在一个路由守卫函数中被同步抛出；</p></li><li><p>错误在一个路由守卫函数中通过调用 next(err) 的方式异步捕获并处理；</p></li><li><p>渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。</p></li></ul><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.onError(callback)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Router-实例属性&quot;&gt;&lt;a href=&quot;#Router-实例属性&quot; class=&quot;headerlink&quot; title=&quot;Router 实例属性&quot;&gt;&lt;/a&gt;Router 实例属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;router.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router构建选项</title>
    <link href="http://yoursite.com/2020/03/11/vue-router%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9/"/>
    <id>http://yoursite.com/2020/03/11/vue-router%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9/</id>
    <published>2020-03-11T06:51:56.000Z</published>
    <updated>2020-03-11T06:52:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h2><ul><li><p>类型: Array<RouteConfig><br>RouteConfig 的类型定义:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RouteConfig = &#123;</span><br><span class="line">  path: <span class="built_in">string</span>,</span><br><span class="line">  component?: Component,</span><br><span class="line">  name?: <span class="built_in">string</span>, <span class="comment">// 命名路由</span></span><br><span class="line">  components?: &#123; [name: <span class="built_in">string</span>]: Component &#125;, <span class="comment">// 命名视图组件</span></span><br><span class="line">  redirect?: <span class="built_in">string</span> | Location | <span class="built_in">Function</span>,</span><br><span class="line">  props?: <span class="built_in">boolean</span> | <span class="built_in">Object</span> | <span class="built_in">Function</span>,</span><br><span class="line">  alias?: <span class="built_in">string</span> | <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  children?: <span class="built_in">Array</span>&lt;RouteConfig&gt;, <span class="comment">// 嵌套路由</span></span><br><span class="line">  beforeEnter?: <span class="function">(<span class="params">to: Route, <span class="keyword">from</span>: Route, next: <span class="built_in">Function</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  meta?: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.6.0+</span></span><br><span class="line">  caseSensitive?: <span class="built_in">boolean</span>, <span class="comment">// 匹配规则是否大小写敏感？(默认值：false)</span></span><br><span class="line">  pathToRegexpOptions?: <span class="built_in">Object</span> <span class="comment">// 编译正则的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><ul><li>类型: string</li><li>默认值: hash | abstract</li><li>可选值: hash | history | abstract<br>配置路由模式:<ul><li>hash: 使用 URL hash 值来作路由. 支持所有浏览器, 包括不支持 HTML5 History Api 的浏览器</li><li>history: 依赖 HTML5 History API 和服务器配置</li><li>abstract: 支持所有 JavaScript 运行环境, 如 Node.js 服务器端, 如果发现没有浏览器的 API, 路由会自动强制进入这个模式</li></ul></li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><ul><li>类型: string</li><li>默认值: ‘/‘<br>应用的基路径, 例如, 如果整个单页应用服务在 <code>/app/</code> 下, 然后 base 就应该设为 <code>/app/</code></li></ul><h2 id="linkActiveClass"><a href="#linkActiveClass" class="headerlink" title="linkActiveClass"></a>linkActiveClass</h2><ul><li>类型: string</li><li>默认值: router-link-active<br>全局配置 <code>&lt;router-link&gt;</code> 默认的激活 class</li></ul><h2 id="linkExactActiveClass"><a href="#linkExactActiveClass" class="headerlink" title="linkExactActiveClass"></a>linkExactActiveClass</h2><ul><li>类型: string</li><li>默认值: router-link-exact-active<br>全局配置 <code>&lt;router-link&gt;</code> 默认的精确激活的 class</li></ul><h2 id="scrollBehavior"><a href="#scrollBehavior" class="headerlink" title="scrollBehavior"></a>scrollBehavior</h2><ul><li><p>类型: Function<br>签名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type PositionDescriptor &#x3D;</span><br><span class="line">&#123; x: number, y: number &#125; |</span><br><span class="line">&#123; selector: string &#125; |</span><br><span class="line">?&#123;&#125;</span><br><span class="line"></span><br><span class="line">type scrollBehaviorHandler &#x3D; (</span><br><span class="line">to: Route,</span><br><span class="line">from: Route,</span><br><span class="line">savedPosition?: &#123; x: number, y: number &#125;</span><br><span class="line">) &#x3D;&gt; PositionDescriptor | Promise&lt;PositionDescriptor&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="parseQuery-stringifyQuery"><a href="#parseQuery-stringifyQuery" class="headerlink" title="parseQuery / stringifyQuery"></a>parseQuery / stringifyQuery</h2><ul><li>类型: Function<br>提供自定义查询字符串的解析/反解析函数</li></ul><h2 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h2><ul><li>类型: boolean<br>当浏览器不支持 <code>history.pushState</code> 控制路由是否应该回退到 hash 模式. 默认为 <code>true</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;routes&quot;&gt;&lt;a href=&quot;#routes&quot; class=&quot;headerlink&quot; title=&quot;routes&quot;&gt;&lt;/a&gt;routes&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型: Array&lt;RouteConfig&gt;&lt;br&gt;RouteConfig 的类型定义:&lt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
</feed>
