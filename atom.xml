<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ginger</title>
  
  <subtitle>一个前端er~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-11T13:29:08.101Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ginger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>service-Docker篇</title>
    <link href="http://yoursite.com/2020/05/11/service-Docker%E7%AF%87/"/>
    <id>http://yoursite.com/2020/05/11/service-Docker%E7%AF%87/</id>
    <published>2020-05-11T13:27:49.000Z</published>
    <updated>2020-05-11T13:29:08.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="Docker-的应用场景"><a href="#Docker-的应用场景" class="headerlink" title="Docker 的应用场景"></a>Docker 的应用场景</h2><ul><li><p>Web 应用的自动化打包和发布。</p></li><li><p>自动化测试和持续集成、发布。</p></li><li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p></li><li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p></li></ul><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 包括三个基本概念:</p><ul><li><p><strong>镜像</strong> (Image): Docker 镜像, 就相当于是一个 root 文件系统. 比如官方镜像 ubuntu:16.04 就包含了一套 Ubuntu16.04 最小系统的 root 文件系统</p></li><li><p><strong>容器</strong> (Container): 镜像和容器的关系, 就像面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体. 容器可以被创建、启动、停止、删除、暂停等</p></li><li><p><strong>仓库</strong> (Repository): 仓库可以看做一个代码控制中心, 用来保存镜像</p></li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><h2 id="CentOS7-安装-Docker"><a href="#CentOS7-安装-Docker" class="headerlink" title="CentOS7 安装 Docker"></a>CentOS7 安装 Docker</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧的 Docker 版本称为 docker 或 docker-engine 如果已经安装过这些程序, 需要先卸载以及相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-01.png" alt="remove"></p><h3 id="安装-epel-更新源"><a href="#安装-epel-更新源" class="headerlink" title="安装 epel 更新源"></a>安装 epel 更新源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vim wget epel-release</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-02.png" alt="remove"></p><h3 id="使用-Docker-仓库进行安装"><a href="#使用-Docker-仓库进行安装" class="headerlink" title="使用 Docker 仓库进行安装"></a>使用 Docker 仓库进行安装</h3><p>在新主机上首次安装 Docker Engine-Community 之前, 需要设置 Docker 仓库. 之后可以从仓库安装和更新 Docker</p><h4 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h4><p>安装所需的软件包, yum-utils 提供了 yum-config-manager, 并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-ytils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-03.png" alt="remove"></p><p>鉴于国内网络问题, 执行以下命令添加 yum 软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">  --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-04.png" alt="remove"></p><h4 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>安装最新版本的 Docker Engine-Community 和 containerd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-05.png" alt="remove"><br><img data-src="../images/service-ci-cd/02/02-06.png" alt="remove"></p><h4 id="配置-163-镜像加速"><a href="#配置-163-镜像加速" class="headerlink" title="配置 163 镜像加速"></a>配置 163 镜像加速</h4><p>增加配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;  "registry-mirrors": ["http://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>重启 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装 docker 命令补全工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bash-completion</span><br></pre></td></tr></table></figure><p>设置 docker 开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-08.png" alt="remove"></p><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><blockquote><p><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">更多 Dokcer 命令</a></p></blockquote><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>创建一个新的容器并运行一个命令</p><p>语法:</p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND][arg…]</p></blockquote><p>OPTIONS 说明：</p><p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p><p>-d: 后台运行容器，并返回容器 ID；</p><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p><p>-P: 随机端口映射，容器内部端口随机映射到主机的高端口</p><p>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</p><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>–name=”nginx-lb”: 为容器指定一个名称；</p><p>–dns 8.8.8.8: 指定容器使用的 DNS 服务器，默认和宿主一致；</p><p>–dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；</p><p>-h “mars”: 指定容器的 hostname；</p><p>-e username=”ritchie”: 设置环境变量；</p><p>–env-file=[]: 从指定文件读入环境变量；</p><p>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定 CPU 运行；</p><p>-m :设置容器使用内存最大值；</p><p>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p><p>–link=[]: 添加链接到另一个容器；</p><p>–expose=[]: 开放一个端口或一组端口；</p><p>–volume , -v: 绑定一个卷</p><h3 id="docker-start-stop-restart-命令"><a href="#docker-start-stop-restart-命令" class="headerlink" title="docker start/stop/restart 命令"></a>docker start/stop/restart 命令</h3><p><strong>docker start</strong> : 启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> : 停止一个运行中的容器</p><p><strong>docker restart</strong> : 重启容器</p><p>语法</p><blockquote><p>docker start [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker stop [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>实例</p><p>启动已被停止的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start jenkins</span><br></pre></td></tr></table></figure><p>停止运行中的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop jenkins</span><br></pre></td></tr></table></figure><p>重启容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure><h3 id="Docker-kill-命令"><a href="#Docker-kill-命令" class="headerlink" title="Docker kill 命令"></a>Docker kill 命令</h3><p>杀掉一个运行中的容器。</p><p>语法</p><blockquote><p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>OPTIONS 说明：</p><p>-s :向容器发送一个信号</p><p>实例</p><p>杀掉运行中的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill -s KILL jenkins</span><br></pre></td></tr></table></figure><h3 id="Docker-rm-命令"><a href="#Docker-rm-命令" class="headerlink" title="Docker rm 命令"></a>Docker rm 命令</h3><p>删除一个或多个容器。</p><p>语法:</p><blockquote><p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>OPTIONS 说明：</p><p>-f :通过 SIGKILL 信号强制删除一个运行中的容器。</p><p>-l :移除容器间的网络连接，而非容器本身。</p><p>-v :删除与容器关联的卷。</p><p>实例:</p><p>强制删除容器 db01、db02：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm \$(docker ps -a -q)</span><br></pre></td></tr></table></figure><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><p>语法</p><blockquote><p>docker pause [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker unpause [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>实例</p><p>暂停数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause db01</span><br></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h3 id="Docker-ps-命令"><a href="#Docker-ps-命令" class="headerlink" title="Docker ps 命令"></a>Docker ps 命令</h3><p>列出容器</p><p>语法</p><blockquote><p>docker ps [OPTIONS]</p></blockquote><p>OPTIONS 说明：</p><p>-a :显示所有的容器，包括未运行的。</p><p>-f :根据条件过滤显示的内容。</p><p>–format :指定返回值的模板文件。</p><p>-l :显示最近创建的容器。</p><p>-n :列出最近创建的 n 个容器。</p><p>–no-trunc :不截断输出。</p><p>-q :静默模式，只显示容器编号。</p><p>-s :显示总的文件大小。</p><p>实例</p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">CONTAINER ID IMAGE COMMAND ... PORTS NAMES</span><br><span class="line">09b93464c2f7 nginx:latest "nginx -g 'daemon off" ... 80/tcp, 443/tcp myrunoob</span><br></pre></td></tr></table></figure><p>输出详情介绍：</p><p>CONTAINER ID: 容器 ID。</p><p>IMAGE: 使用的镜像。</p><p>COMMAND: 启动容器时运行的命令。</p><p>CREATED: 容器的创建时间。</p><p>STATUS: 容器状态。</p><p>状态有 7 种：</p><pre><code>created（已创建）restarting（重启中）running（运行中）removing（迁移中）paused（暂停）exited（停止）dead（死亡）PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</code></pre><p>NAMES: 自动分配的容器名称。</p><h3 id="Docker-logs-命令"><a href="#Docker-logs-命令" class="headerlink" title="Docker logs 命令"></a>Docker logs 命令</h3><p>获取容器的日志</p><p>语法</p><blockquote><p>docker logs [OPTIONS] CONTAINER</p></blockquote><p>OPTIONS 说明：</p><p>-f : 跟踪日志输出</p><p>–since :显示某个开始时间的所有日志</p><p>-t : 显示时间戳</p><p>–tail :仅列出最新 N 条容器日志</p><h3 id="Docker-images-命令"><a href="#Docker-images-命令" class="headerlink" title="Docker images 命令"></a>Docker images 命令</h3><p>列出本地镜像。</p><p>语法</p><blockquote><p>docker images [OPTIONS]REPOSITORY[:TAG]]</p></blockquote><p>OPTIONS 说明：</p><p>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p><p>–digests :显示镜像的摘要信息；</p><p>-f :显示满足条件的镜像；</p><p>–format :指定返回值的模板文件；</p><p>–no-trunc :显示完整的镜像信息；</p><p>-q :只显示镜像 ID。</p><h3 id="Docker-commit-命令"><a href="#Docker-commit-命令" class="headerlink" title="Docker commit 命令"></a>Docker commit 命令</h3><p>从容器创建一个新的镜像。</p><p>语法</p><blockquote><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p></blockquote><p>OPTIONS 说明：</p><p>-a :提交的镜像作者；</p><p>-c :使用 Dockerfile 指令来创建镜像；</p><p>-m :提交时的说明文字；</p><p>-p :在 commit 时，将容器暂停。</p><h3 id="Docker-cp-命令"><a href="#Docker-cp-命令" class="headerlink" title="Docker cp 命令"></a>Docker cp 命令</h3><p>用于容器与主机之间的数据拷贝。</p><p>语法</p><blockquote><p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</p></blockquote><p>OPTIONS 说明：</p><p>-L :保持源目标中的链接</p><p>Docker rmi 命令</p><p>删除本地一个或多少镜像。</p><p>语法</p><blockquote><p>docker rmi [OPTIONS] IMAGE [IMAGE…]</p></blockquote><p>OPTIONS 说明：</p><p>-f :强制删除；</p><p>–no-prune :不移除该镜像的过程镜像，默认移除；</p><p>Docker exec 命令</p><p>在运行的容器中执行命令</p><p>语法</p><blockquote><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p></blockquote><p>OPTIONS 说明：</p><p>-d :分离模式: 在后台运行</p><p>-i :即使没有附加也保持 STDIN 打开</p><p>-t :分配一个伪终端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>React-初体验</title>
    <link href="http://yoursite.com/2020/05/09/React-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/05/09/React-%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-05-09T06:24:32.000Z</published>
    <updated>2020-05-09T06:30:36.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从-JS-基本语法去理解-React"><a href="#从-JS-基本语法去理解-React" class="headerlink" title="从 JS 基本语法去理解 React"></a>从 JS 基本语法去理解 React</h2><p>实现创建元素并且加入到页面进行渲染</p><p>第一版<br>实现功能:</p><ul><li>1、创建节点元素</li><li>2、元素嵌套</li><li>3、元素渲染到页面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">div.appendChild(p)</span><br><span class="line">p.appendChild(span)</span><br><span class="line">span.innerText = <span class="string">'我是一个span'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br></pre></td></tr></table></figure><p>第二版 代码优化:</p><ul><li>1、将重复的 document.createElement() 提取成一个函数方法</li><li>2、方法接受一个 tagName 返回创建好的元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(tagName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> div = createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> p = createElement(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">const</span> span = createElement(<span class="string">'span'</span>)</span><br><span class="line">div.appendChild(p)</span><br><span class="line">p.appendChild(span)</span><br><span class="line">span.innerText = <span class="string">'我是一个 span'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br></pre></td></tr></table></figure><p>第三版 继续优化:</p><ul><li>1、方法接受第二个参数 参数值可以是一个元素节点 也可以是元素节点需要渲染的内容</li><li>2、将函数调用提取到一个函数方法中 返回一个组装好了子元素或内容的的元素节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, childer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="built_in">document</span>.createElement(tagName)</span><br><span class="line">  <span class="keyword">if</span> (childer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> childer === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> child = <span class="built_in">document</span>.createTextNode(childer)</span><br><span class="line">      parent.appendChild(child)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.appendChild(childer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    createElement(<span class="string">'p'</span>, createElement(<span class="string">'span'</span>, <span class="string">'我是一个 span'</span>))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).appendChild(render())</span><br></pre></td></tr></table></figure><h2 id="React-思想推导"><a href="#React-思想推导" class="headerlink" title="React 思想推导"></a>React 思想推导</h2><p>使用 React 实现 JS 模拟实现的最终版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><p>第一版 :暂时不考虑 render 内部实现原理</p><ul><li>通过 React.createElement 创建 节点对象</li><li>通过 ReactDom.render 渲染</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    React.createElement(</span><br><span class="line">      <span class="string">'p'</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'我是 React 实现节点创建'</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">Node</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><p>第二版: 加入 JSX</p><ul><li>每次要写 React.createElement 实在太繁琐了</li><li>于是 React 提供了 JSX 语法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Node = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;span&gt;我是 React JSX 创建的节点&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;Node /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><p>React 组件提供了 class 类写法与函数式组件写法</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>第一版:</p><ul><li>事件无法传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setN(n + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;span&gt;这是 React 函数式组件 &#123;n&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="函数式组件-1"><a href="#函数式组件-1" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>第二版:</p><ul><li>利用闭包实现事件传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">step</span>) </span>&#123;</span><br><span class="line">    setN(n + step)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;span&gt;这是 React 函数式组件 &#123;n&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; onClick(2)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="class-类-组件"><a href="#class-类-组件" class="headerlink" title="class 类 组件"></a>class 类 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: props.count &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &lt;span&gt;我是 React <span class="class"><span class="keyword">class</span> 类 创建的组件 </span>&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; console.log(this)&#125;&gt;this&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从-JS-基本语法去理解-React&quot;&gt;&lt;a href=&quot;#从-JS-基本语法去理解-React&quot; class=&quot;headerlink&quot; title=&quot;从 JS 基本语法去理解 React&quot;&gt;&lt;/a&gt;从 JS 基本语法去理解 React&lt;/h2&gt;&lt;p&gt;实现创建元素
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>webpack-05-plugins-mode</title>
    <link href="http://yoursite.com/2020/04/26/webpack-05-plugins/"/>
    <id>http://yoursite.com/2020/04/26/webpack-05-plugins/</id>
    <published>2020-04-26T14:46:32.000Z</published>
    <updated>2020-04-26T14:46:55.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件是 webpack 的支柱功能. 插件的目的在于解决 loader 无法实现的其他事</p><h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>webpack 插件是一个具有 apply 属性的 JavaScript 对象. apply 属性会被 webpack compiler 调用, 并且 compiler 对象可在整个编译生命周期访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'webpack 构建过程开始！'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。</p><p>根据你的 webpack 用法，这里有多种方式使用插件。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>) <span class="comment">//通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>) <span class="comment">//访问内置的插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'./src/index.html'</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><h2 id="Node-API"><a href="#Node-API" class="headerlink" title="Node API"></a>Node API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>) <span class="comment">//访问 webpack 运行时(runtime)</span></span><br><span class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compiler = webpack(configuration)</span><br><span class="line">compiler.apply(<span class="keyword">new</span> webpack.ProgressPlugin())</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;plugins&quot;&gt;&lt;a href=&quot;#plugins&quot; class=&quot;headerlink&quot; title=&quot;plugins&quot;&gt;&lt;/a&gt;plugins&lt;/h2&gt;&lt;p&gt;插件是 webpack 的支柱功能. 插件的目的在于解决 loader 无法实现的其他事&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-04-mode</title>
    <link href="http://yoursite.com/2020/04/25/webpack-04-mode/"/>
    <id>http://yoursite.com/2020/04/25/webpack-04-mode/</id>
    <published>2020-04-25T06:46:49.000Z</published>
    <updated>2020-04-25T06:46:57.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>提供 <code>mode</code> 配置选项, 告知 webpack 使用相应的模式的内置优化</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>只在配置中提供 <code>mode</code> 选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>, <span class="comment">// 生产环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在 CLI 参数中传递</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><p>development:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>. 启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></p></li><li><p>production:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>. 启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>.</p></li></ul><h2 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h2><p>mode: development</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode: production</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h2&gt;&lt;p&gt;提供 &lt;code&gt;mode&lt;/code&gt; 配置选项, 告知 webpack 使用相应的模式的内置优化&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>service-服务器篇</title>
    <link href="http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/</id>
    <published>2020-04-25T04:54:24.000Z</published>
    <updated>2020-05-09T06:41:41.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>每个程序员都应该有一台自己的云服务器</p><blockquote><p><a href="https://www.zhihu.com/question/40854395" target="_blank" rel="noopener">知乎-自己拥有一台服务器可以做哪些很酷的事情</a></p></blockquote><p>服务器厂商:</p><ul><li><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a></li><li><a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a></li><li><a href="https://www.sinacloud.com/" target="_blank" rel="noopener">新浪云</a></li><li><a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">华为云</a></li></ul><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><blockquote><p>注: 下面流程以我自己购买的腾讯云服务器为例</p></blockquote><p>点击<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云链接</a>进入腾讯云首页, 点击右上角登录进行登录</p><p>在首页轮播图常年有活动, 新用户与学生一般是活动优惠力度最大的</p><p>点击轮播图活动进入后, 按照需求选择我们需要的服务器配置, 如果是个人学习、博客等使用, 最基本的即可</p><p><img data-src="../images/service-ci-cd/01/01-01.png" alt="服务器"></p><p>点击立即抢购之后, 跳入一个配置选择界面, 选择离自己所在地最近的城市, 选择机型配置, 选择 CentOS 系统</p><p><img data-src="../images/service-ci-cd/01/01-02.png" alt="服务器"></p><p>点击<strong>立即购买</strong>即可跳转付款页面, 核对无误后付款即可</p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>在腾讯云首页右上角有一个控制台按钮, 点击即可进入控制台</p><p><img data-src="../images/service-ci-cd/01/01-02.png" alt="服务器"></p><p>点击服务器后将会跳转至实例界面(如果没有实例就创建一个)</p><p><img data-src="../images/service-ci-cd/01/01-04.png" alt="实例"></p><blockquote><p>首次购买后会自动跳转至服务器控制台</p></blockquote><h2 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h2><blockquote><p>以 MacOS 为例</p></blockquote><p>打开终端, 输入 <code>ssh root@xx.xx.xx.xx</code> 回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><blockquote><p>xx.xx.xx.xx 替换为自己服务器公网 ip 地址</p></blockquote><p>弹出提示要求输入密码</p><blockquote><p>输入密码不会显示, 输入完成后直接回车即可</p></blockquote><p><img data-src="../images/service-ci-cd/01/01-05.png" alt="ssh"></p><p>如果看到如下界面就表示密码输入成功</p><p><img data-src="../images/service-ci-cd/01/01-06.png" alt="ssh"></p><p>输入 <code>cat /etc/redhat-release</code> 查看系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/01/01-07.png" alt="ssh"></p><h2 id="配置免密验证"><a href="#配置免密验证" class="headerlink" title="配置免密验证"></a>配置免密验证</h2><p>在使用上面的命令登录远程服务器的时候, 是需要输入密码的, 而且以后每次访问都需要输入, 这样就很繁琐.</p><p>我们可以通过—ssh 免密验证</p><h3 id="在本地生成秘钥"><a href="#在本地生成秘钥" class="headerlink" title="在本地生成秘钥"></a>在本地生成秘钥</h3><p>通过如下命令在本地机器生成秘钥</p><blockquote><p>如果你使用过 git 配置, 就无需重复生成</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 指定加密算法； -b 指定生成的密钥长度； -C 一句话，一般都填邮箱地址。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更多参数说明可以在终端输入：ssh-keygen --<span class="built_in">help</span> 查看</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "你的邮箱地址"</span><br></pre></td></tr></table></figure><p>这条命令执行完之后, 会提示指定公钥和私钥在本地机器上储存的位置, 因为我本地已经有秘钥了, 就从网上找了一张图</p><p><img data-src="../images/service-ci-cd/01/01-08.png" alt="ssh"></p><h3 id="将公钥储存到远程服务器主机"><a href="#将公钥储存到远程服务器主机" class="headerlink" title="将公钥储存到远程服务器主机"></a>将公钥储存到远程服务器主机</h3><p>输入以下命令, 然后回车, 将上一步我们在本地机器上生成的公钥写入服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> i后面接的参数是保存你公钥的文件(我们这里是.ssh/id_rsa.pub)；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> root是远程主机的用户，这条指令会往root这个用户的主目录下的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .ssh/authorized_keys文件写入id_rsa.pub保存的公钥</span></span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/01/01-09.png" alt="ssh"></p><p>根据提示, 输入服务器主机登录密码</p><p><img data-src="../images/service-ci-cd/01/01-10.png" alt="ssh"></p><p>如果看到如下提示, 表示添加成功</p><p><img data-src="../images/service-ci-cd/01/01-11.png" alt="ssh"></p><p>此时, 我们再使用 <code>ssh root@xx.xx.xx.xx</code> 对服务器进行访问, 就能直接登录, 不需要再输入密码了</p><p><img data-src="../images/service-ci-cd/01/01-12.png" alt="ssh"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云服务器&quot;&gt;&lt;a href=&quot;#云服务器&quot; class=&quot;headerlink&quot; title=&quot;云服务器&quot;&gt;&lt;/a&gt;云服务器&lt;/h1&gt;&lt;p&gt;每个程序员都应该有一台自己的云服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zh
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>webpack-03-loader</title>
    <link href="http://yoursite.com/2020/04/22/webpack-03-loader/"/>
    <id>http://yoursite.com/2020/04/22/webpack-03-loader/</id>
    <published>2020-04-22T15:15:21.000Z</published>
    <updated>2020-04-22T15:15:34.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换. loader 可以使你在 <code>import</code> 或 “加载” 模块时预处理文件. loader 可以将文件从不同的语言转换为 JavaScript, 或将内联图像转换为 data URL, loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>loader 支持链式传递, 一组链式的 loader 按照相反的顺序执行, loader 链中的第一个 loader 返回值给下一个 loader. 在最后一个 loader 返回 webpack 所预期的 JavaScript</li><li>loader 可以是同步的, 也可以是异步的</li><li>loader 运行在 Node.js 中, 并且能够执行任何可能的操作</li><li>loader 接受查询参数, 用于对 loader 传递配置</li><li>loader 也能够使用 options 对象进行配置</li><li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性, 还可以将普通的 <code>npm</code> 模块导出为 loader, 做法是在 <code>package.json</code> 里定义一个 loader 字段</li><li>插件(plugin)可以为 loader 带来更多特性</li><li>loader 能够产生额外的任意文件</li></ul><h2 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h2><p>可以使用 loader 告诉 webpack 加载 CSS 文件</p><p>先安装对应的loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D css-loader</span><br></pre></td></tr></table></figure><p>然后配置 <code>webpack.config.js</code> 文件, 告诉 webpack 对每个 <code>.css</code> 使用 css-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;loader&quot;&gt;&lt;a href=&quot;#loader&quot; class=&quot;headerlink&quot; title=&quot;loader&quot;&gt;&lt;/a&gt;loader&lt;/h2&gt;&lt;p&gt;loader 用于对模块的源代码进行转换. loader 可以使你在 &lt;code&gt;import&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-02-入口与出口</title>
    <link href="http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/</id>
    <published>2020-04-21T14:58:29.000Z</published>
    <updated>2020-04-21T14:58:44.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点</strong>(entry point)指示 webpack 应该使用哪个模块, 来作为构建其内部依赖图的开始. 进入入口后, webpack 会找出有哪些模块和库是入口起点(直接和简介)依赖的</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>entery: String|Array<string></li></ul><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><p><code>entry</code> 属性的单个入口语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 多入口写法 - 对象写法: </p><p>用法: `entry: {[entruChunkName: string]: string|Array<string>}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><blockquote><p>可应用于多页面程序</p></blockquote><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><strong>output</strong>属性告诉 webpack 在哪里输出它所创建的 bundles, 以及如何命名这些文件, 默认值为 <code>./dist</code>. 整个应用程序结构, 都会被编译到指定的输出路径的文件夹中, </p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>output: Object <code>output</code> 选项可以控制 webpack 如何向硬盘写入编译文件<ul><li>filename: String 打包后的文件名</li><li>path: String 打包输出路径</li></ul></li></ul><h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><p>单入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 NodeJS 的 path 核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure><h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><p>使用 CDN 和资源 hash 的复杂示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'/home/proj/cnd/assets/[hash]'</span>,</span><br><span class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入口-entry&quot;&gt;&lt;a href=&quot;#入口-entry&quot; class=&quot;headerlink&quot; title=&quot;入口(entry)&quot;&gt;&lt;/a&gt;入口(entry)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;入口起点&lt;/strong&gt;(entry point)指示 webpack
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-01-安装与使用</title>
    <link href="http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-20T13:16:47.000Z</published>
    <updated>2020-04-20T13:17:23.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前提: 请确保安装了 Node.js 的最新版本</p></blockquote><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler) 当 webpack 处理应用程序时, 它会递归地构建一个依赖关系图(dependencygraph) 其中包含应用程序需要的每个模块, 然后将所有这些模块打包成一个或多个bundle</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-dmeo # 创建项目文件夹</span><br><span class="line">cd webpack-demo # 进入项目目录</span><br><span class="line">npm init -y # 默认配置初始化</span><br></pre></td></tr></table></figure><p>出现 package.json 信息, 表示初始化成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种安装"><a href="#两种安装" class="headerlink" title="两种安装"></a>两种安装</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版本</span></span><br><span class="line">npm install --save-dev webpack </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用 weboack4+ 版本 还需要安装 CLI</span></span><br><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure><h2 id="webpack-命令使用方式"><a href="#webpack-命令使用方式" class="headerlink" title="webpack 命令使用方式"></a>webpack 命令使用方式</h2><h3 id="项目目录运行"><a href="#项目目录运行" class="headerlink" title="项目目录运行"></a>项目目录运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> webpack-demo 目录中</span></span><br><span class="line">./node_modules/.bin/webpack --sersion</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="NPM-script命令运行"><a href="#NPM-script命令运行" class="headerlink" title="NPM script命令运行"></a>NPM script命令运行</h3><p>添加 script 脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"build"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"webpack --version"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="全局运行"><a href="#全局运行" class="headerlink" title="全局运行"></a>全局运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要全局安装webpack</span></span><br><span class="line">webpack --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前提: 请确保安装了 Node.js 的最新版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpac
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-buildFragment方法</title>
    <link href="http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-31T08:51:47.000Z</published>
    <updated>2020-05-09T06:51:49.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts)将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><p>文档片段 DocumentFragment 表示文档的一部分, 但不属于文档树. 当把 DocumentFragment 插入文档树时, 插入的不是 DocumentFragment 自身, 而是他的所有子孙节点, 即可以一次向文档树中插入多个节点. 当需要插入大量节点时, 相比逐个插入节点, 使用 ocumentFragment 一次插入多个节点, 性能的提升会非常明显</p><p>如果 HTML 代码符合缓存条件, 方法 jQuery.buildFragment()还会把转换后的 DOM 元素缓存起来, 下次转换相同的代码时, 直接从缓存中读取, 不需要重复转换</p><h2 id="方法执行步骤"><a href="#方法执行步骤" class="headerlink" title="方法执行步骤"></a>方法执行步骤</h2><p>jQuery.buildFragment(args, nodes, scripts)执行步骤:</p><ol><li>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</li><li>创建文档片段 DocumentFragment</li><li>调用方法 jQuery.clean(elems, context, Fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</li><li>如果 HTML 代码符合缓存条件,则把转换后的 DOM 元素防褥缓存对象 jQuery.Fragments</li><li>最后返回文档片段和缓存状态 { fragment: fragment, cacheable: cacheable }</li></ol><h2 id="jQuery-buildFragment-方法源码"><a href="#jQuery-buildFragment-方法源码" class="headerlink" title="jQuery.buildFragment() 方法源码"></a>jQuery.buildFragment() 方法源码</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.buildFragment(args, nodes, scripts) &#123;&#125;</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li>ages: 数组, 含有待转换的 DOM 元素的 HTML 代码</li><li>nodes: 数组, 含有文档对象、jQuery 对象或 DOM 元素, 用于修正创建文档片段 DocumentFragment 的文档对象</li><li>scripts: 数组, 用于存放 HTML 代码中的 script 元素. 方法 jQuery.Fragment() 会把该参数传给方法 jQuery.clean(), 后者把 HTML 代码转换为 DOM 元素后, 会提取其中的 script 元素并存入数组 scrtips</li></ul><h3 id="定义局部变量-修正文档对象-doc"><a href="#定义局部变量-修正文档对象-doc" class="headerlink" title="定义局部变量, 修正文档对象 doc"></a>定义局部变量, 修正文档对象 doc</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fragment, <span class="comment">// 指向稍后可能创建的文档片段 Document Fragment</span></span><br><span class="line">  eacheable, <span class="comment">// 表示 HTML 代码 是否符合缓存条件</span></span><br><span class="line">  eacheresults, <span class="comment">// 指向从缓存对象 jQuery.ftagment 中提取到的文档片段 包含了缓存的DOM元素</span></span><br><span class="line">  doc, <span class="comment">// 表示创建文档片段的文档对象</span></span><br><span class="line">  fitst = args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修正文档对象 doc</span></span><br><span class="line"><span class="comment"> * nodes 可能包含一个明确的文档对象, 也可能包含jQuery对象或DOM元素</span></span><br><span class="line"><span class="comment"> * 先尝试读取nodes[0]的属性 ownerDocuemt 并赋值给doc</span></span><br><span class="line"><span class="comment"> * 如果不存在 则假定nodes[0]为文档对象并赋值给doc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nodes &amp;&amp; nodes[<span class="number">0</span>]) &#123;</span><br><span class="line">  doc = nodes[<span class="number">0</span>].ownerDocument || node[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查传入参数对象是不是文档对象 如果不是文档对象 而是 JavaScript 对象 就修正 doc 为当前文档对象 document</span></span><br><span class="line"><span class="keyword">if</span> (!doc.createDocumentFragment) &#123;</span><br><span class="line">  doc = <span class="built_in">document</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素"><a href="#尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素" class="headerlink" title="尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素"></a>尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</h3><p>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</p><ul><li>数组 args 长度为 1, 且第一个元素是字符串, 即数组 args 中只有一段 HTML 代码</li><li>HTML 代码长度小于 512, 否则可能会导致缓存占用内存过大</li><li>文档对象 doc 是当前文档对象, 即之缓存为当前文档创建的 DOM 元素</li><li>HTML 代码已左尖括号开头, 即只缓存 DOM 元素, 不缓存文本节点</li><li>HTML 代码中不能含有 <code>&lt;script&gt;</code> <code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;option&gt;</code> <code>&lt;style&gt;</code>标签</li><li>当前浏览器可以正确的复制单选按钮核复选框的选中状态 checked, 或者 HTML 代码中的单选按钮和复选按钮没有被选中</li><li>当前浏览器可以正确的赋值 HTML5 元素, 或者 HTML 代码中不含有 HTML5 标签</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(args.length === <span class="number">1</span></span><br><span class="line">&amp;&amp; <span class="keyword">typeof</span> first === <span class="string">'string'</span></span><br><span class="line">&amp;&amp; first.length &lt; <span class="number">512</span></span><br><span class="line">&amp;&amp; doc === <span class="built_in">document</span></span><br><span class="line">&amp;&amp; first.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span></span><br><span class="line">&amp;&amp; !rnocache.test(first)</span><br><span class="line">&amp;&amp; (jQuery.support.checkClone || !rchecked.test(first))</span><br><span class="line">&amp;&amp; (jQuery.support.html5Clone || !rnshimcache.text(first))&#123;</span><br><span class="line"></span><br><span class="line">  cacheable = <span class="literal">true</span>; <span class="comment">// 如果遍历为 true 必须先赋值一份再使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试从缓存对象jQuery.fragment中读取缓存的DOM元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cacheresults = jQuery.fragments[first];</span><br><span class="line">  <span class="keyword">if</span> (cacheresults &amp;&amp; cacheresults !== <span class="number">1</span>) &#123;</span><br><span class="line">    fragment = cacheresults;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.fragments = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="转换-HTML-代码为-DOM-元素"><a href="#转换-HTML-代码为-DOM-元素" class="headerlink" title="转换 HTML 代码为 DOM 元素"></a>转换 HTML 代码为 DOM 元素</h2><p>先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果为 true 表示需要直型转换过程</span></span><br><span class="line"><span class="keyword">if</span> (!fragment) &#123;</span><br><span class="line">  <span class="comment">// 调用原生方法 创建文档片段</span></span><br><span class="line">  fragment = doc.createDocumentFragment()</span><br><span class="line">  <span class="comment">// 将片段转换为 DOM 元素</span></span><br><span class="line">  jQuery.clean(args, doc, fragment, scripts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把转换后的-DOM-元素防褥缓存对象-jQuery-fragments"><a href="#把转换后的-DOM-元素防褥缓存对象-jQuery-fragments" class="headerlink" title="把转换后的 DOM 元素防褥缓存对象 jQuery.fragments"></a>把转换后的 DOM 元素防褥缓存对象 jQuery.fragments</h2><p>如果 HTML 代码符合缓存条件, 则把转换后的 DOM 元素放入缓存对象 jQuery.fragment 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果符合缓存条件 就缓存</span></span><br><span class="line"><span class="keyword">if</span> (cacheable) &#123;</span><br><span class="line">  jQuery.fragments[first] = cacheresults ? fragment : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回文档片段和缓存状态"><a href="#返回文档片段和缓存状态" class="headerlink" title="返回文档片段和缓存状态"></a>返回文档片段和缓存状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  返回一个包含了文档片段 fragment 和缓存状态 cacheable 的对象</span></span><br><span class="line"><span class="comment">  fragment 中包含了转换后的 DOM 元素, 缓存状态 cacheable 则指示了如果使用这些 DOM 元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  fragment: fragment,</span><br><span class="line">  cacheable: cacheable,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.buildFragment.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 Documen
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-jQuery.fn.init</title>
    <link href="http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/"/>
    <id>http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/</id>
    <published>2020-03-26T07:29:26.000Z</published>
    <updated>2020-05-09T06:51:30.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery-fn-init-selector-context-rootjQuery"><a href="#jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="jQuery.fn.init(selector, context, rootjQuery)"></a>jQuery.fn.init(selector, context, rootjQuery)</h1><p>构造函数 jQuery.fn.init() 负责解析参数 selector 和 context 的类型, 并执行相应的逻辑, 最后返回 jQuery.fn.init() 的实例.</p><blockquote><p>解析参数 selector 和 context 公有 12 个有效分支</p></blockquote><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init.png" alt="jQuery.fn.init"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="定义-jQuery-fn-init-selector-context-rootjQuery"><a href="#定义-jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="定义 jQuery.fn.init(selector, context, rootjQuery)"></a>定义 jQuery.fn.init(selector, context, rootjQuery)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">  init: function (selector, context, rootjQuery) &#123;</span><br><span class="line">    <span class="keyword">var</span> match, elem, ret, doc</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>init()</code> 构造函数定义中接受三个参数 selector、context、rootjQuery</p><ul><li>selector: 可以是任意类型的值, 但只有 undefined、DOM 元素、字符串、函数、jQuery 对象、普通 JavaScript 对象这几种类型有效</li><li>context: 可以不传入, 或者传入 DOM 元素、jQuery 对象、普通 JavaScript 对象之一</li><li>rootjQuery: 包含了 document 对象的 jQuery 对象, 用于 document.getElementById()查找失败、selector 是选择器表达式且未指定 context、selector 是函数的情况.</li></ul><p>rootjQuery 定义与应用场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document.getElementById() 查找失败</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.find(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slector 是选择器且未指定 context</span></span><br><span class="line"><span class="keyword">return</span> (context || rootjQuery).find(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// selector 是函数</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.ready(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rootjQuery 定义</span></span><br><span class="line">rootjQuery = jQuery(doucment)</span><br></pre></td></tr></table></figure><h2 id="参数-selector-可以转换为-false"><a href="#参数-selector-可以转换为-false" class="headerlink" title="参数 selector 可以转换为 false"></a>参数 selector 可以转换为 false</h2><p>参数 selector 可以转换为 false, 例如: undefined、空字符串、null 等, 则直接返回 this, 此时 this 是空 jQuery 对象, 其属性 length 等于 0.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $('')、$(null) or $(undefined)</span></span><br><span class="line"><span class="keyword">if</span> (!selector) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是-DOM-元素"><a href="#参数-selector-是-DOM-元素" class="headerlink" title="参数 selector 是 DOM 元素"></a>参数 selector 是 DOM 元素</h2><p>如果参数 selector 有属性 nodeType, 则认为 selector 是 DOM 元素, 手动设置第一个元素和属性 context 指向该 DOM 元素、属性 length 为 1, 然后返回包含了该 DOM 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $(DOMELement)</span></span><br><span class="line"><span class="keyword">if</span> (selector.nodeType) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="keyword">this</span>[<span class="number">0</span>] = selector</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是字符串-‘body’"><a href="#参数-selector-是字符串-‘body’" class="headerlink" title="参数 selector 是字符串 ‘body’"></a>参数 selector 是字符串 ‘body’</h2><p>如果参数 selector 是字符串 “body”, 手动设置属性 context 指向 document 对象、第一个元素指向 body 元素、属性 length 为 1, 最后返回包含了 body 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The body element only exists once, optimize finding it</span></span><br><span class="line"><span class="keyword">if</span> (selector === <span class="string">'body'</span> &amp;&amp; !context &amp;&amp; <span class="built_in">document</span>.body) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">0</span>] = <span class="built_in">document</span>.body</span><br><span class="line">  <span class="keyword">this</span>.selector = selector</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是其他字符串"><a href="#参数-selector-是其他字符串" class="headerlink" title="参数 selector 是其他字符串"></a>参数 selector 是其他字符串</h2><p>如果参数 selector 是其他字符串, 则先检测 selector 是 HTML 代码还是 <code>#id</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理参数是字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> selector === <span class="string">'string'</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是 HTML 代码 还是 #ID</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    selector.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span> &amp;&amp;</span><br><span class="line">    selector.charAt(selector.length - <span class="number">1</span>) === <span class="string">'&gt;'</span> &amp;&amp;</span><br><span class="line">    selector.length &gt;= <span class="number">3</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是以 `&lt;` 开头 `&gt;` 结尾的  并且长度大于等于 3  跳过 正则 检查</span></span><br><span class="line">    match = [<span class="literal">null</span>, selector, mull]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用正则检查  quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/</span></span><br><span class="line"><span class="comment">     * 依次匹配 HTML 代码和 id 如果匹配成功 match 数组第一个元素为参数 selector, 第二个元素为匹配的 HTML 代码或 undefined 第三个元素为匹配的 id 或 undefined</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('#target'); // ["#target",undefined,"target"]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;'); // ["&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;'); // ["abc&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;abc#id'); // ["abc&lt;div&gt;abc#id","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('div'); // null</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;&lt;img&gt;&lt;/div&gt;'); // ["&lt;div&gt;&lt;img&gt;&lt;/div&gt;","&lt;div&gt;&lt;img&gt;&lt;/div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = quickExpr.exec(selector)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果-selector-是单独标签"><a href="#如果-selector-是单独标签" class="headerlink" title="如果 selector 是单独标签"></a>如果 selector 是单独标签</h2><p>如果 selector 是单独标签, 就调用 document.createElement() 创建标签对应的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查正则匹配结果</span></span><br><span class="line"><span class="comment"> * 如果 match[1] 不是 undefined 即 selector 是 HTML 代码 或者 match[2] 不是 undefined, 即参数 selector 是 #id 并且未传入 context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (match &amp;&amp; (match[<span class="number">1</span>] || !context)) &#123;</span><br><span class="line">  <span class="comment">// HANDLE: $(html) -&gt; $(array)</span></span><br><span class="line">  <span class="keyword">if</span> (match[<span class="number">1</span>]) &#123;</span><br><span class="line">    context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context</span><br><span class="line"></span><br><span class="line">    doc = context ? context.ownerDocument || context : <span class="built_in">document</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入单个字符 并且是个单标签 直接创建 跳过其他</span></span><br><span class="line">    <span class="comment">// rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,</span></span><br><span class="line">    ret = rsingleTag.exec(selector)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="comment">// jQuery.isPlainObject() 用于检测对象是否是纯粹的对象 即用对象直接量 &#123;&#125; 或者 new Object() 创建的对象</span></span><br><span class="line">      <span class="keyword">if</span> (jQuery.isPlainObject(context)) &#123;</span><br><span class="line">        selector = [<span class="built_in">document</span>.createElement(ret[<span class="number">1</span>])]</span><br><span class="line">        <span class="comment">// attr() 遇到特殊属性和事件类型时会执行同名 jQuery 方法</span></span><br><span class="line">        jQuery.fn.attr.call(selector, context, <span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selector = [doc.createElement(res[<span class="number">1</span>])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以把创建的 DOM 源码放入数组中, 是为了后面方便的调用 jQuery.merge() 方法, 此方法用于合并两个数组的元素到一个数组</p></blockquote><h2 id="参数-selector-是复杂-HTML-代码"><a href="#参数-selector-是复杂-HTML-代码" class="headerlink" title="参数 selector 是复杂 HTML 代码"></a>参数 selector 是复杂 HTML 代码</h2><p>如果参数 selector 是复杂 HTML 代码, 则利用浏览器 innerHTML 创建 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建过程由 buildFragment 和 clean 实现</span></span><br><span class="line"><span class="comment">    * buildFragment 返回 -&gt; &#123; fragment: 含有转换后的 DOM 元素的文档片段 , cacheable: HTML代码是否满足缓存条件&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ret = jQuery.buildFragment([ match[<span class="number">1</span>] ], [ doc ])</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果满足缓存条件, 在使用前 先复制一份</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   selector = (ret.cacheable ? jQuery.clone(ret.fragment): rest.fragment).childNodes</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将创建的 DOM 元素 合并到当前 jQuery 对象中返回</span></span><br><span class="line"> <span class="keyword">return</span> jQuery.merage(<span class="keyword">this</span>, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-id-且未指定参数-context"><a href="#如果参数-selector-是-id-且未指定参数-context" class="headerlink" title="如果参数 selector 是 #id, 且未指定参数 context"></a>如果参数 selector 是 <code>#id</code>, 且未指定参数 context</h2><p>如果参数 selector 是 <code>#id</code>, 且未指定参数 context, 则调用 document.getElementById() 查找含有指定 id 属性的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 查找含有指定 id 属性的 DOM 元素</span></span><br><span class="line">  elem = <span class="built_in">document</span>.getElementById(mathc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elem &amp;&amp; elem.parentNode) &#123;</span><br><span class="line">    <span class="comment">// 检查 id 是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (elem.id !== match[<span class="number">2</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> rootjQuery.find(selector)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">0</span>] = elem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span></span><br><span class="line">  <span class="keyword">this</span>.selector = selector</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是选择器表达式"><a href="#参数-selector-是选择器表达式" class="headerlink" title="参数 selector 是选择器表达式"></a>参数 selector 是选择器表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HANDLE: $(expr, $(...))</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context || context.jquery) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果执行了上下文 且上下文是 jQuery 对象 执行 context.find() 方法</span></span><br><span class="line"><span class="comment">   * 如果没有指定上下文 就执行 rootjQuery.find()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (context || rootjQuery).find(selector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HANDLE: $(expr, context)</span></span><br><span class="line">  <span class="comment">// (which is just equivalent to: $(context).find(expr)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果指定了上下文 但上下文不是jQuery对象 则执行方法先创建一个包含 context 的 jQuery 对象, 然后调用 find() 方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.constructor(context).find(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是函数"><a href="#参数-selector-是函数" class="headerlink" title="参数 selector 是函数"></a>参数 selector 是函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是函数 就绑定 ready 事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jQuery.isFunction(selector))&#123;</span><br><span class="line">  <span class="keyword">return</span> rootjQuery.ready(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-jQuery-对象"><a href="#如果参数-selector-是-jQuery-对象" class="headerlink" title="如果参数 selector 是 jQuery 对象"></a>如果参数 selector 是 jQuery 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参数包含 selector 就认为是 jQuery 对象</span></span><br><span class="line"><span class="keyword">if</span> (selector.selector !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// 复制他的属性 selector 和 context</span></span><br><span class="line">  <span class="keyword">this</span>.selector = selector.selector</span><br><span class="line">  <span class="keyword">this</span>.context = selector.context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是任意其他值"><a href="#参数-selector-是任意其他值" class="headerlink" title="参数 selector 是任意其他值"></a>参数 selector 是任意其他值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 selector 是数组或伪数组, 则添加到当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果 selector 是 JavaScript 对象, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果是其他类型的值, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 最后返回当前 jQuery 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> jQuery.makeArray(selector, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init_.png" alt="jQuery.fn.init_"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery-fn-init-selector-context-rootjQuery&quot;&gt;&lt;a href=&quot;#jQuery-fn-init-selector-context-rootjQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery.f
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery源码结构</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-25T07:54:10.000Z</published>
    <updated>2020-03-25T08:29:59.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造-jQuery-对象的总体源码结构"><a href="#构造-jQuery-对象的总体源码结构" class="headerlink" title="构造 jQuery 对象的总体源码结构"></a>构造 jQuery 对象的总体源码结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自调用匿名函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 jQuery</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回 jQuery.fn.init 的实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 定义一堆变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖构造函数 jQuery() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn = jQuery.protottype = &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 覆盖原型对象的属性 constructor</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">      /**</span><br><span class="line">       * 定义原型方法 负责解析 selector 和 context 的类型并执行相应的查找</span><br><span class="line">      */</span><br><span class="line">      init: function(selector, context, rootjQuery) &#123;</span><br><span class="line">        <span class="comment">// ... 一堆原型属性和方法</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 jQuery 构造函数的原型对象 jQuery.fn 覆盖 jQuery.fn.init() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个或多个对象的属性到第一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 jQuery.extend() 在jQuery构造器上定义了一堆静态属性和方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">      <span class="comment">// 一堆静态属性和方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 jQuery 构造函数并赋值给外层变量 jQuery</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把 jQuery 、 $ 暴露给全局作用域 window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h2 id="为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例"><a href="#为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例" class="headerlink" title="为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例"></a>为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例</h2><p>如果构造函数有返回值, 运算符 new 所创建的对象会被丢弃, 返回值将作为 new 表达式的值</p><p>jQuery 利用这一特性, 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例, 省去构造函数 jQuery() 前面的运算符 new</p><h2 id="为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype"></a>为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype</h2><p>jQuery.fn 是 jQuery.prototype 的简写, 方便拼写</p><h2 id="jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性"><a href="#jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性" class="headerlink" title="jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性"></a>jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性</h2><p>用 jQuery()构造函数的原型对象覆盖了构造函数 jQuery.fn.init()的原型对象, 从而使得 jQuery.fn.init() 的实例也可以访问 jQuery()构造函数的原型方法核属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><h2 id="为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中"><a href="#为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中" class="headerlink" title="为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中"></a>为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中</h2><p>在自调用安徽省农户中定义了很多其他局部变量, 这些局部变量只在 jQuery 对象内部使用, 使用自调用匿名函数可以减少与其他模块的耦合度</p><h2 id="为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype"></a>为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype</h2><p>在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，可以有效减少每个 jQuery 对象所需的内存。事实上，jQuery 对象只包含 5 种非继承属性，其余都继承自原型对象 jQuery.prototype；在构造函数 jQuery.fn.init()中设置了整型属性、length、selector、context；在原型方法.pushStack()中设置了 prevObject。因此，也不必因为 jQuery 对象带有太多的属性和方法而担心会占用太多的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造-jQuery-对象的总体源码结构&quot;&gt;&lt;a href=&quot;#构造-jQuery-对象的总体源码结构&quot; class=&quot;headerlink&quot; title=&quot;构造 jQuery 对象的总体源码结构&quot;&gt;&lt;/a&gt;构造 jQuery 对象的总体源码结构&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/</id>
    <published>2020-03-25T07:51:57.000Z</published>
    <updated>2020-03-25T07:52:07.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数-jQuery"><a href="#构造函数-jQuery" class="headerlink" title="构造函数 jQuery"></a>构造函数 jQuery</h1><p>构造函数 jQuery 有七种用法:</p><ul><li>jQuery(select [,context]): 接受一个 CSS 选择器表达式和可选的选择器上下文, 返回一个包含了匹配的 DOM 元素的 jQuery 对象</li><li>jQuery(html,[, ownerDocument])、jQuery(html, props): 用提供的 HTML 代码创建 DOM 元素</li><li>jQuery(element)、jQuery(elementArray): 封装 DOM 元素为 jQuery 对象</li><li>jQuery(object): 封装普通对象为 jQuery 对象</li><li>jQuery(callback): 绑定 ready 事件监听函数, 当 DOM 结构加载完成时执行</li><li>jQuery(jQuery object): 接受一个 jQuery 对象, 返回该 jQuery 对象的拷贝副本</li><li>jQuery(): 创建一个 jQuery 对象</li></ul><h2 id="jQuery-select-context"><a href="#jQuery-select-context" class="headerlink" title="jQuery(select [,context])"></a>jQuery(select [,context])</h2><p>如果传入一个字符串参数, jQuery 会检查这个字符串是选择器表达式还是 HTML 代码. 如果是选择器表达式, 则遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象. 如果没有元素与之匹配, 则创建一个空 jQuery 对象, 其中不包含任何元素, 其属性 length 等于 0.</p><p>默认情况下, 对匹配元素的查找将从根元素 document 对象开始, 即查找范围是整个文档树, 不过也可以传入第二个参数 context 来限定查找范围</p><p>如果选择器表达式 selector 是简单的 <code>#id</code>, 且没有指定上下文 context, 则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素; 如果是比 <code>#id</code> 复杂的选择器表达式或指定了上下文, 则通过 jQuery 方法 <code>.find()</code> 查找, 因此 <code>$(&#39;span&#39;, this)</code> 等价于 <code>$(this).find(&#39;span&#39;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#app'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $('span', this).html(222);</span></span><br><span class="line">  $(<span class="keyword">this</span>)</span><br><span class="line">    .find(<span class="string">'span'</span>)</span><br><span class="line">    .html(<span class="string">'find'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-html-ownerDocument-、jQuery-html-props"><a href="#jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="jQuery(html [,ownerDocument])、jQuery(html, props)"></a>jQuery(html [,ownerDocument])、jQuery(html, props)</h2><h3 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h3><p>如果传入的字符串参数看起来像一段 HTML 代码, jQuery 则尝试用这段 HTML 代码创建新的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;button&gt;CLICK ME&lt;/button&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><p>如果 HTML 代码是一个单独标签, jQuery 会使用浏览器原生方法 document.createElement() 创建 DOM 元素</p><p>如果是多层嵌套 HTML 片段, 则利用浏览器的 innerHTML 机制创建 DOM 元素, 这个过程由 <code>jQuery.buildFragment()</code> 和 <code>jQuery.clean()</code> 实现</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>ownerDocument 用于指定创建新 DOM 元素的文档对象, 如果不传入, 则默认为当前文档对象</p><p>如果 HTML 代码是一个单独标签, 那么第二个参数还可以是 props, props 是一个包含了属性、事件的普通对象; 在调用 document.createElement() 创建 DOM 元素后, 参数 props 会被传给 jQuery 方法 <code>.attr()</code>, 然后由 <code>.attr()</code> 负责把 props 中的属性、事件设置到新穿创建的 DOM 元素上</p><p>参数 props 的属性可以是任意的事件类型（如”click”），此时属性值应该是事件监听函数，它将被绑定到新创建的 DOM 元素上；参数 props 可以含有以下特殊属性：val、css、html、text、data、width、height、offset，相应的 jQuery 方法：<code>.val()</code>、<code>.css()</code>、<code>.html()</code>、<code>.text()</code>、<code>.data()</code>、<code>.width()</code>、<code>.height()</code>、`.offset()将被执行，并且属性值会作为参数传入；其他类型的属性则会被设置到新创建的 DOM 元素上，某些特殊属性还会做跨浏览器兼容（如 type、value、tabindex 等）；可以通过属性名 class 设置类样式，但要用引号把 class 包裹起来，因为 class 是 JavaScript 保留字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;div /&gt;'</span>, &#123;</span><br><span class="line">  text: <span class="string">'哈哈'</span>,</span><br><span class="line">  class: 'active',</span><br><span class="line">  click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="keyword">this</span>.innerHTML = <span class="string">'嘻嘻'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><h2 id="jQuery-element-、jQuery-elementArray"><a href="#jQuery-element-、jQuery-elementArray" class="headerlink" title="jQuery(element)、jQuery(elementArray)"></a>jQuery(element)、jQuery(elementArray)</h2><p>如果传入一个 DOM 元素或 DOM 元素数组, 则把 DOM 元素封装到 jQuery 对象中并返回</p><p>这个功能常见于事件监听函数, 即把关键字 this 因用那个的 DOM 元素封装为 jQuery 对象, 然后在该 jQuery 对象上调用 jQuery 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).slideUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-object"><a href="#jQuery-object" class="headerlink" title="jQuery(object)"></a>jQuery(object)</h2><p>如果传入一个普通 JavaScript 对象, 则把该对象封装到 jQuery 对象中并返回</p><p>这个功能可以方便的在普通 JavaScript 对象上实现自定义事件的绑定和触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $foo = $(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'worldd'</span> &#125;);</span><br><span class="line">$foo.on(<span class="string">'custom'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;);</span><br><span class="line">$foo.trigger(<span class="string">'custom'</span>); <span class="comment">// -&gt; foo</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-callback"><a href="#jQuery-callback" class="headerlink" title="jQuery(callback)"></a>jQuery(callback)</h2><p>如果传入一个函数, 则在 document 上绑定一个 ready 事件监听函数, 当 DOM 结构加载完成时执行. ready 事件的触发要早于 load 事件.</p><p>ready 事件并不是浏览器原生事件, 而是 DOMContentLoaded 事件、onreadystatechange 事件和函数 doScrollCheck() 的统称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM 加载完毕'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-jQuery-object"><a href="#jQuery-jQuery-object" class="headerlink" title="jQuery(jQuery object)"></a>jQuery(jQuery object)</h2><p>如果传入一个 jQuery 对象, 则创建该 jQuery 对象的一个副本并返回, 副本与传入的 jQuery 对象引用完全相同的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $app = $(<span class="string">'#app'</span>);</span><br><span class="line">$app.html(<span class="string">'xuxu'</span>); <span class="comment">// -&gt; $('#app').html('xuxu')</span></span><br></pre></td></tr></table></figure><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery()"></a>jQuery()</h2><p>如果不传入任何参数, 则返回一个空的 jQuery 对象, 属性 length 为 0.</p><p>这个功能可以用来复用 jQuery 对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数-jQuery&quot;&gt;&lt;a href=&quot;#构造函数-jQuery&quot; class=&quot;headerlink&quot; title=&quot;构造函数 jQuery&quot;&gt;&lt;/a&gt;构造函数 jQuery&lt;/h1&gt;&lt;p&gt;构造函数 jQuery 有七种用法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQ
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-总体架构</title>
    <link href="http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-23T06:47:26.000Z</published>
    <updated>2020-05-09T06:52:21.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>jQuery 的模块总体分为三大部分:</p><ul><li>入口模块(构造 jQuery 对象模块)</li><li>功能模块</li><li>底层支持模块</li></ul><p><img data-src="../images/jQuery-source-code/01%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/jQuery.png" alt="模块导图"></p><h2 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h2><p>入口模块主要功能是构造 jQuery 对象, 如果在调用构造函数 <code>jQuery()</code> 创建 jQuery 对象时传入了选择器表达式, 则会调用功能模块中的选择器 <code>Sizzle</code> 遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象</p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>在功能模块中, 事件系统提供了统一的事件绑定、响应、手动触发和移除机制, 它并没有将事件直接绑定到 DOM 元素上, 而是基于数据缓存模块来管理事件</p><h3 id="Ajax-模块"><a href="#Ajax-模块" class="headerlink" title="Ajax 模块"></a>Ajax 模块</h3><p>Ajax 模块允许从服务器上加载数据, 而不用刷新页面, 它基于异步队列模块来管理核触发回调函数</p><h3 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h3><p>动画模块用于向网页中添加动画效果, 它基于队列模块来管理和执行动画函数</p><h3 id="属性操作模块"><a href="#属性操作模块" class="headerlink" title="属性操作模块"></a>属性操作模块</h3><p>属性操作模块时用于对 HTML 属性和 DOM 属性进行读取、设置和移除操作</p><h3 id="DOM-遍历模块"><a href="#DOM-遍历模块" class="headerlink" title="DOM 遍历模块"></a>DOM 遍历模块</h3><p>DOM 遍历模块用于在 DOM 树中遍历父元素、子元素和兄弟元素</p><h3 id="DOM-操作模块"><a href="#DOM-操作模块" class="headerlink" title="DOM 操作模块"></a>DOM 操作模块</h3><p>DOM 操作模块用于插入、移除、复制和替换 DOM 元素</p><h3 id="样式操作模块"><a href="#样式操作模块" class="headerlink" title="样式操作模块"></a>样式操作模块</h3><p>样式操作模块用于获取计算样式或设置内联样式</p><h3 id="坐标模块"><a href="#坐标模块" class="headerlink" title="坐标模块"></a>坐标模块</h3><p>坐标模块用于读取或设置 DOM 元素的文档坐标</p><h3 id="尺寸模块"><a href="#尺寸模块" class="headerlink" title="尺寸模块"></a>尺寸模块</h3><p>尺寸模块用于获取 DOM 元素的高度和宽度</p><h2 id="底层支持模块"><a href="#底层支持模块" class="headerlink" title="底层支持模块"></a>底层支持模块</h2><p>底层支持模块又分为诸多子模块:</p><ul><li>工具方法: Utilities</li><li>回调函数列表: Callbacks Object</li><li>异步队列: Deferred Object</li><li>浏览器功能测试: Support</li><li>数据缓存: Data</li><li>队列: Queue</li><li>选择器: Sizzle</li></ul><h3 id="工具方法模块"><a href="#工具方法模块" class="headerlink" title="工具方法模块"></a>工具方法模块</h3><p>工具方法模块提供了一些编程辅助方法, 用于简化对 jQuery 对象、DOM 元素、数组、对象、字符串等的操作, 其他模块都会用到工具方法模块</p><h3 id="回调函数列表模块"><a href="#回调函数列表模块" class="headerlink" title="回调函数列表模块"></a>回调函数列表模块</h3><p>回调函数列表模块用于增强对回调函数的管理，支持添加、移除、触发、锁定、禁用回调函数等功能；</p><h3 id="异步队列模块"><a href="#异步队列模块" class="headerlink" title="异步队列模块"></a>异步队列模块</h3><p>异步队列模块用于解耦异步任务和回调函数, 他再回调列表的基础上为回调函数增加了状态, 并提供多个回调函数列表, 支持传播任意同步或异步回调函数的成功或失败状态</p><h3 id="浏览器功能测试模块"><a href="#浏览器功能测试模块" class="headerlink" title="浏览器功能测试模块"></a>浏览器功能测试模块</h3><p>浏览器功能测试模块提供了针对不同浏览器功能和 bug 的测试结果, 其他模块基于这些测试结果来解决浏览器之间的兼容性问题</p><h3 id="数据缓存模块"><a href="#数据缓存模块" class="headerlink" title="数据缓存模块"></a>数据缓存模块</h3><p>数据缓存模块用于为 DOM 元素和 JavaScript 对象附加任意类型的数据</p><h3 id="队列模块"><a href="#队列模块" class="headerlink" title="队列模块"></a>队列模块</h3><p>队列模块用于管理一组函数, 支持函数的入队核出队操作, 并确保函数按顺序执行, 它基于数据缓存模块实现</p><h3 id="选择器模块"><a href="#选择器模块" class="headerlink" title="选择器模块"></a>选择器模块</h3><p>选择器 <code>sizzle</code> 是一个纯 JavaScript 实现的 CSS 选择器引擎, 用于查找与选择表达式匹配的元素集合</p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jQuery = (</span><br><span class="line">    <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery)</span><br><span class="line">    &#125;)()</span><br><span class="line">    <span class="keyword">return</span> jQuery</span><br><span class="line">  )()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工具方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调函数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浏览器功能测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件系统</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 样式操作 CSS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坐标</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h1&gt;&lt;p&gt;jQuery 的模块总体分为三大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口模块(构造 jQuery 对象模块)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>vuex-api</title>
    <link href="http://yoursite.com/2020/03/21/vuex-api/"/>
    <id>http://yoursite.com/2020/03/21/vuex-api/</id>
    <published>2020-03-21T01:40:44.000Z</published>
    <updated>2020-03-21T01:41:01.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex-Store"><a href="#Vuex-Store" class="headerlink" title="Vuex.Store"></a>Vuex.Store</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; ...options &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex-Store-构造器选项"><a href="#Vuex-Store-构造器选项" class="headerlink" title="Vuex.Store 构造器选项"></a>Vuex.Store 构造器选项</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>类型: <code>Object | Function</code><br>Vuex store 实例的根 state 对象</p><p>如果传入返回一个对象的函数, 其返回的对象会被用作根 state.</p></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li>类型: <code>{ [type: string ]: Function }</code><br>在 store 上注册 mutation, 处理函数总是接受 <code>state</code> 作为第一个参数(如果定义在模块中, 则为模块的局部状态), <code>payload</code>作为第二个参数</li></ul><h3 id="sctions"><a href="#sctions" class="headerlink" title="sctions"></a>sctions</h3><ul><li><p>类型: <code>{ [type: string]: Function }</code><br>在 store 上注册 action. 处理函数总是接受 <code>context</code> 作为第一个参数, <code>payload</code> 作为第二个参数</p><p><code>context</code> 对象包含以下属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state, <span class="comment">// 等同于 `store.state`，若在模块中则为局部状态</span></span><br><span class="line">    rootState, <span class="comment">// 等同于 `store.state`，只存在于模块中</span></span><br><span class="line">    commit, <span class="comment">// 等同于 `store.commit`</span></span><br><span class="line">    dispatch, <span class="comment">// 等同于 `store.dispatch`</span></span><br><span class="line">    getters, <span class="comment">// 等同于 `store.getters`</span></span><br><span class="line">    rootGetters <span class="comment">// 等同于 `store.getters`，只存在于模块中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ul><li><p>类型: <code>{ [type: string ]: Function}</code></p><p>在 store 上注册 getter, getter 方法接受以下参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state, getters</span><br></pre></td></tr></table></figure><p>当定义在一个模块粒时会特别一些:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state, <span class="comment">// 如果在模块中定义则为模块的局部状态</span></span><br><span class="line">  getters, <span class="comment">// 等同于 store.getters</span></span><br><span class="line">  rootState, <span class="comment">// 等同于 store.state</span></span><br><span class="line">  rootGetters <span class="comment">// 所有 getters</span></span><br></pre></td></tr></table></figure><p>注册的 getter 为暴露为 getters</p></li></ul><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ul><li>类型: <code>Object</code><br>包含了子模块的对象, 会被合并到 store<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    state,</span><br><span class="line">    namespaced?,</span><br><span class="line">    mutations,</span><br><span class="line">    actions?,</span><br><span class="line">    getters?,</span><br><span class="line">    modules?</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>与根模块的选项一样, 每个模块也包含 <code>state</code> 和 <code>mutations</code> 选项. 模块的状态使用 <code>key</code> 关联到 store 的根状态. 模块的 mutation 和 getter 只会接受 module 的局部状态作为第一个参数, 而不是根状态, 并且模块的 action 的 <code>context.state</code> 同样指向局部状态</li></ul><h3 id="pulgins"><a href="#pulgins" class="headerlink" title="pulgins"></a>pulgins</h3><ul><li>类型: <code>Array&lt;Function&gt;</code><br>一个数组, 包含应用在 store 上的插件方法. 这些插件直接接受 store 作为唯一参数, 可以监听 mutation 或者提交 mutation</li></ul><h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><ul><li>类型: <code>Boolean</code></li><li>默认值: <code>false</code><br>使 Vuex store 进入严格模式, 在严格模式下, 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</li></ul><h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul><li>类型: <code>Boolean</code><br>为某个特定的 Vuex 实例打开或关闭 devtools. 对于传入 false 的实例来说 Vuex store 不会订阅到 devtools 插件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  devtools: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vuex-Store-实例属性"><a href="#Vuex-Store-实例属性" class="headerlink" title="Vuex.Store 实例属性"></a>Vuex.Store 实例属性</h2><h3 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h3><ul><li>类型: <code>Object</code><br>根状态, 只读</li></ul><h3 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h3><ul><li>类型: <code>Object</code><br>暴露出注册的 getter, 只读</li></ul><h2 id="Vuex-Store-实例方法"><a href="#Vuex-Store-实例方法" class="headerlink" title="Vuex.Store 实例方法"></a>Vuex.Store 实例方法</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul><li><p><code>commit(type: string, payload?:any, options?: Object)</code></p></li><li><p><code>commit(mutation: Object, options?: Object)</code></p><p>提交 mutation, <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里提交根的 mutation</p></li></ul><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><ul><li><p><code>dispatch(type: string, payload?:any, options?: Pbject)</code></p></li><li><p><code>dispatch(action: Object, options?: Object)</code></p><p>分发 action. <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里分发根的 action. 返回一个解析所有被触发的 action 处理器的 Promise</p></li></ul><h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h3><ul><li><p><code>replaceState(state: Object)</code></p><p>替换 store 的根状态, 仅用状态合并或时光旅行调试</p></li></ul><h3 id="wathc"><a href="#wathc" class="headerlink" title="wathc"></a>wathc</h3><ul><li><p><code>watch(fn: Function, callback: Funtion, options?: Object): Function</code></p><p>响应式的侦听 <code>fn</code> 的返回值, 当值改变时调用回调函数. <code>fn</code> 接受 store 的 state 作为第一个参数, 其 getter 作为第二个参数, 最后接受一个可选对象参数表示 Vue 的<code>vm.$watch</code>方法的参数</p><p>要停止侦听, 调用此方法返回的函数即可停止侦听</p></li></ul><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><ul><li><p><code>subscribe(handler: Function):Function</code></p><p>订阅 store 的 mutation. <code>hanlder</code> 会在每个 mutation 完成后调用, 接受 mutation 和经过 mutation 后的状态作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.type)</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.paylaod)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅, 调用此方法返回的函数可停止订阅</p></li></ul><h3 id="subscribeAction"><a href="#subscribeAction" class="headerlink" title="subscribeAction"></a>subscribeAction</h3><ul><li><p><code>subscribeAction(handler: Function): Function</code></p><p>订阅 store 的 action。handler 会在每个 action 分发的时候调用并接收 action 描述和当前的 store 的 state 这两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(action.type)</span><br><span class="line">  <span class="built_in">console</span>.log(action.payload)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅，调用此方法返回的函数即可停止订阅。</p><p>从 3.1.0 起，subscribeAction 也可以指定订阅处理函数的被调用时机应该在一个 action 分发之前还是之后 (默认行为是之前)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(&#123;</span><br><span class="line">  before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="registerModule"><a href="#registerModule" class="headerlink" title="registerModule"></a>registerModule</h3><ul><li><p><code>registerModule(path: string | Array&lt;string&gt;, module: Module, options?: Object)</code></p><p>注册一个动态模块</p><p>options 可以包含 <code>preserveState: true</code> 以允许保留之前的 state。用于服务端渲染。</p></li></ul><h3 id="unregisterModule"><a href="#unregisterModule" class="headerlink" title="unregisterModule"></a>unregisterModule</h3><ul><li><p><code>unregisterModule(path: string | Array&lt;string&gt;)</code></p><p>卸载一个动态模块。</p></li></ul><h3 id="hotUpdate"><a href="#hotUpdate" class="headerlink" title="hotUpdate"></a>hotUpdate</h3><ul><li><p><code>hotUpdate(newOptions: Object)</code></p><p>热替换新的 action 和 mutation。详细介绍</p></li></ul><h2 id="组件绑定的辅助函数"><a href="#组件绑定的辅助函数" class="headerlink" title="组件绑定的辅助函数"></a>组件绑定的辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><ul><li><p><code>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | Function&gt;): Object</code></p><p>为组件创建计算属性以返回 Vuex store 中的状态</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数</p></li></ul><h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><ul><li><p><code>mapGetters(namespace?: string, map: Array&lt;string&gt; | Object&lt;string&gt;): Object</code></p><p>为组件创建计算属性以返回 getter 的返回值</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p></li></ul><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><ul><li><p><code>mapActions(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法分发 action</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(dispatch: function, ...args: any[])</code></p></li></ul><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><ul><li><p><code>mapMutations(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法提交的 mutation</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(commit: function, ...args: any[])</code></p></li></ul><h3 id="createNamespacedHelpers"><a href="#createNamespacedHelpers" class="headerlink" title="createNamespacedHelpers"></a>createNamespacedHelpers</h3><ul><li><p><code>createNamespacedHelpers(namespace: string): Object</code></p><p>创建基于命名空间的组件绑定辅助函数。其返回一个包含 mapState、mapGetters、mapActions 和 mapMutations 的对象。它们都已经绑定在了给定的命名空间上</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex-Store&quot;&gt;&lt;a href=&quot;#Vuex-Store&quot; class=&quot;headerlink&quot; title=&quot;Vuex.Store&quot;&gt;&lt;/a&gt;Vuex.Store&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Module</title>
    <link href="http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/"/>
    <id>http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/</id>
    <published>2020-03-20T01:48:54.000Z</published>
    <updated>2020-03-20T01:49:10.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有可能变得相当臃肿</p><p>为了解决以上问题, Vuex 允许我们将 store 分割成模块. 每个模块拥有自己的 state、Mutation、Action、Getter、甚至是嵌套子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><h2 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h2><p>对于模块内部的 mutaion 和 getter, 接受的第一个参数是模块的局部状态对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 此处 state 是局部的状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样, 对于模块内部的 action, 局部状态通过 <code>context.state</code> 暴露出来, 根节点状态则为 <code>context.rootState</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum(&#123;state, commit, rootState&#125;)&#123;</span><br><span class="line">      <span class="keyword">if</span>((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于模块内部的 getter, 根节点状态会作为第三个参数暴露出来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount(state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下, 模块内部的 action、mutation 和 getter 是注册在全局命名空间的–这样使得多个模块能够对同一 mutation 或 action 做出反应</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容 (module assets)</span></span><br><span class="line">      state: &#123; ... &#125; <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>, <code>dispatch</code> 和 <code>commit</code>. 换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码</p><h3 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h3><p>如果希望使用全局 state 和 getter, <code>rootState</code> 和 ``rootState<code>会作为第三和第四参数传入 getter, 也会通过</code>context<code>对象的属性传入</code>action`</p><p>若需要在全局命名空间内分发 action 或提交 mutation, 将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中, getters 被局部化了</span></span><br><span class="line">      <span class="comment">// 可以使用 getter 的第四个参数来调用 rootGetters</span></span><br><span class="line">      someGetter( state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; foo/someOtherGetter</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; someOtherGetter</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    acctions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中, dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 root 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction(&#123;dispatch, commit, getters, rootGetters&#125;) &#123;</span><br><span class="line">        getters.somegetter <span class="comment">// -&gt; foo/somegetter</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; somegetter</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; foo/someOtherAction</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someOtherAction</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; foo/someMutation</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someMutation</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction(ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="headerlink" title="在带命名空间的模块注册全局 action"></a>在带命名空间的模块注册全局 action</h3><p>若要在带命名空间的模块注册全局 action, 可以添加 <code>root: true</code>, 并将这个 action 定义放在函数 <code>handler</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction(&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">'someAction'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler( namespacedContext, patload) &#123; ... &#125; <span class="comment">// -&gt; someAction</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>当使用 <code>mapState</code>、<code>mapgetters</code>、<code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时, 写起来可能比较繁琐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  )]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述情况, 可以将模块的空间名称字符串作为第一个参数传递给上述函数, 这样所有绑定都会自动将该模块作为上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且可以使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数, 它返回一个对象, 对象里有新的绑定在给定命名空间值上的组件绑定辅助函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapAcrions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapActions([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h2><p>如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过插件的参数对象得到空间名称</span></span><br><span class="line"><span class="comment">// 然后返回 Vuex 插件函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPlugin</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把空间名字添加到插件模块的类型（type）中去</span></span><br><span class="line">    <span class="keyword">const</span> namespace = options.namespace || <span class="string">''</span></span><br><span class="line">    store.dispatch(namespace + <span class="string">'pluginAction'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h2><p>在 <code>store</code> 创建之后, 可以使用 <code>store.registerModule</code> 方法注册模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）</p><h3 id="保留-state"><a href="#保留-state" class="headerlink" title="保留 state"></a>保留 state</h3><p>在注册一个新 module 时, 你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</p><p>当你设置 preserveState: true 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</p><h2 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h2><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li>创建多个 store, 他们公用一个模块</li><li>在一个 store 中多次注册同一模块</li></ul><p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p><p>实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Module&quot;&gt;&lt;a href=&quot;#Module&quot; class=&quot;headerlink&quot; title=&quot;Module&quot;&gt;&lt;/a&gt;Module&lt;/h2&gt;&lt;p&gt;由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Action</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/</id>
    <published>2020-03-19T02:24:14.000Z</published>
    <updated>2020-03-21T01:40:54.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation, 不同在于:</p><ul><li>Action 提交的是 mutation, 而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><p>注册一个简单的 action:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个 store 实例具有相同方法核属性的 context 对象, 因此你可以调用 <code>context.commit</code> 提交一个 mutation, 或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p><p>实践中, 我们经常会用到 ES2015 的参数解构来简化代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h2><p>Action 通过 <code>store.dispatch</code> 方法触发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><p>action 内部可以执行异步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync(&#123;commit&#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  cmount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h2><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action, 或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">    <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h2><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise, 并且 <code>store.dispatch</code> 仍旧返回 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 可以利用 async/await 组合 action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>)</span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h2&gt;&lt;p&gt;Action 类似于 mutation, 不同在于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action 提交的是 mu
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Mutation</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/</id>
    <published>2020-03-19T01:58:02.000Z</published>
    <updated>2020-03-19T01:58:13.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的 mutation 非常类似于事件:每个 mutation 都有一个字符串的事件类型和一个回调函数. 这个回调函数就是我们实际进行状态更改的地方, 并且他会接受 state 作为第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不能直接调用一个 mutation handler. 这个选项更像是事件注册: “当触发一个类型为 <code>increment</code> 的 mutation 时, 调用此函数. “要唤醒一个 mutation handler, 需要已相应的 type 调用 <code>store.commit</code> 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><h2 id="提交载荷-Payload"><a href="#提交载荷-Payload" class="headerlink" title="提交载荷 (Payload)"></a>提交载荷 (Payload)</h2><p>可以向 <code>store.commit</code> 传入额外的参数, 即 mutation 的载荷 (Payload)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: <span class="function">(<span class="params">state, n</span>) =&gt;</span> &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在大多数情况下, 载荷应该是一个对象, 这样可以包含多个字段并且记录的 mutation 会更易读:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123; <span class="attr">amount</span>: <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用对象风格的提交方式, 整个对象都作为载荷传给 mutation 函数, 因此 handler 保持不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h2><p>既然 Vuex 的 store 中的状态是响应式的, 那么当我们变更状态时, 监视状态的 Vue 组件也会自动更新. 这也意味着 Vuex 中的 mutation 也需要与使用 Vuex 一样遵守一些注意事项</p><ol><li>最好提前在 store 中初始化好所有的所需属性</li><li>当需要在对象上添加新属性时, 应该:</li></ol><ul><li>使用 Vue.set(obj, ‘newProp’, 123)</li><li>以新对象替换老对象. 例如, 利用对象展开运算符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用常亮代替-Mutation-事件类型"><a href="#使用常亮代替-Mutation-事件类型" class="headerlink" title="使用常亮代替 Mutation 事件类型"></a>使用常亮代替 Mutation 事件类型</h2><p>使用常亮替代 mutation 事件类型在各种 Flux 实现中是很常见的模式. 这样可以使 linter 之类的工具发挥作用, 同时把这些常亮放在单独的文件中可以让代码合作者对整个 app 包含的 mutation 一目了然</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION](state) &#123;</span><br><span class="line">      <span class="comment">//  mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h2><p>一条重要的原则就是 mutation 必须是同步函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation(state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h2 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h2><p>可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation, 或者使用 <code>mapMutation</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">'increment'</span>, <span class="string">'incrementby'</span>]),</span><br><span class="line">    ...mapMutations([(add: <span class="string">'increment'</span>)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mutation&quot;&gt;&lt;a href=&quot;#Mutation&quot; class=&quot;headerlink&quot; title=&quot;Mutation&quot;&gt;&lt;/a&gt;Mutation&lt;/h2&gt;&lt;p&gt;更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Getter</title>
    <link href="http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/"/>
    <id>http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/</id>
    <published>2020-03-18T08:30:52.000Z</published>
    <updated>2020-03-18T08:31:06.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个组件需要用到此属性, 我们要复制这个函数, 或者抽取到一个共享函数然后在多处导入它</p><p>Vuex 允许我们在 store 中定义 getter(可以认为是 store 的计算属性). 就像计算属性一样. getter 的返回值会根据他的依赖被缓存起来, 且只有当它的依赖值发生了改变才会被重新计算.</p><p>Getter 接受 state 作为其第一个参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h2><p>getter 会暴露 <code>store.getters</code> 对象, 可以以属性的形式访问这些值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123;id:1, text: '...', done: true&#125;]</span></span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.state.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们可以很容易的在任何组件中使用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的</p><h2 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h2><p>也可以通过让 getter 返回一个函数, 来实现给 getter 传参.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> tido.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// &#123; id: 2, text: '...', done: false&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>getter 在通过方法访问时, 每次都会去进行调用, 不会缓存结果.</p></blockquote><h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p><code>mapgetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapgetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([<span class="string">'doneTodosCount'</span>, <span class="string">'anotherGetter'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想将一个 getter 属性另取一个名字, 使用对象形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapGetters([(doneCount: <span class="string">'doneTodosCount'</span>)])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Getter&quot;&gt;&lt;a href=&quot;#Getter&quot; class=&quot;headerlink&quot; title=&quot;Getter&quot;&gt;&lt;/a&gt;Getter&lt;/h2&gt;&lt;p&gt;有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-State</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/</id>
    <published>2020-03-17T07:30:16.000Z</published>
    <updated>2020-03-17T07:30:29.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用 <strong>单一状态树</strong> 用一个对象就包含了全部的应用层级状态. 至此它便作为一个唯一数据源而存在. 意味着, 每个应用将仅仅包含一个 store 实例. 单一状态树让我们能够直接地定位任一特定的状态片段, 在调试的过程中也能轻易地取得整个当前应用状态的快照.</p><h3 id="在组件中获得-Vuex-状态"><a href="#在组件中获得-Vuex-状态" class="headerlink" title="在组件中获得 Vuex 状态"></a>在组件中获得 Vuex 状态</h3><p>由于 Vuex 的状态储存是响应式的, 从 store 实例中读取状态的最简单的方法就是在计算属性中返回某个状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter - &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性, 并且触发更新相关联的 DOM</p><p>然而, 这种模式导致组件依赖全局状态单例. 在模块化的构建系统中, 在每个需要使用 state 的组件中需要频繁的导入, 并且在测试组件时需要模拟状态</p><p>Vuex 通过 <code>store</code> 选项, 提供了一种机制将状态从根组件注入到每一个子组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class='app'&gt;</span></span><br><span class="line"><span class="string">    &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过在根实例中注册 <code>store</code> 选项, 该 store 实例会注入到根组件下的所有子组件中, 且子组件能通过 <code>this.$store</code> 访问到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>当一个组件需要获取多个状态的时候, 将这些状态都声明为计算属性会有些重复和冗余, 为了解决这个问题, 我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数更简洁</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 count 等同于 state =&gt; state.count</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性名称与 state 的子节点名称相同时, 我们也可以给 <code>mapState</code> 传一个字符串数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">computed: mapState([<span class="string">'count'</span>])</span><br></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p><code>mapState</code> 函数返回的是一个对象, 可以通过展开运算符将它与局部计算属性混合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState([<span class="string">'count'</span>]),</span><br><span class="line">  localComputed() &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件仍保有局部状态"><a href="#组件仍保有局部状态" class="headerlink" title="组件仍保有局部状态"></a>组件仍保有局部状态</h3><p>使用 Vuex 并不意味着需要将所有的状态放入 Vuex. 如果有些状态严格属于单个组件, 最好还是作为组件的局部状态.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;State&quot;&gt;&lt;a href=&quot;#State&quot; class=&quot;headerlink&quot; title=&quot;State&quot;&gt;&lt;/a&gt;State&lt;/h2&gt;&lt;p&gt;Vuex 使用 &lt;strong&gt;单一状态树&lt;/strong&gt; 用一个对象就包含了全部的应用层级状态. 至此它便作为一
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex安装介绍与起步</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/</id>
    <published>2020-03-17T07:02:31.000Z</published>
    <updated>2020-05-09T07:00:28.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>直接下载 || CDN 引用 <a href="https://unpkg.com/vuex" target="_blank" rel="noopener">vuex</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vuex.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>NPM</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><ul><li>Yarn</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure><ul><li>在一个模块化的打包系统中, 必须显示地通过 <code>Vue.use()</code> 来安装 <code>Vuex</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h2 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么?"></a>Vuex 是什么?</h2><p>Vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式. 它采用集中式存储管理应用的所有组件的状态, 并已相应的规则保证状态以一种可预测的方式发生变化. Vuex 也集成到 Vue 的官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</p><h2 id="什么是状态管理模式"><a href="#什么是状态管理模式" class="headerlink" title="什么是状态管理模式?"></a>什么是状态管理模式?</h2><p>已一个简单的 Vue 记数应用开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个状态管理应用包含以下几个部分:</p><ul><li>state: 驱动应用的数据源</li><li>view: 以声明方式将 state 映射到试图</li><li>actions: 响应在 view 上的用户输入导致的状态变化</li></ul><p>以下是一个表示单项数据流理念的简单示意图:</p><p><img data-src="../images/vue/flow.png" alt="flow"></p><p>当我们遇到多个组件共享状态时, 单项数据流的简洁性很容易被破坏:</p><ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul><p>对于问题一, 传参的方法对于多层嵌套的组件将会非常繁琐, 并且对于兄弟组件间的状态传递无能为力<br>对于问题二, 我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝.</p><p>因此, 我们为什么不把组件的共享状态抽取出来, 以一个全局单例模式管理呢? 在这种模式下, 我们组件树构成了一个巨大的试图, 不管树在那个位置, 任何组件都能获取状态或者触发行为.</p><p>通过定义和隔离状态管理中的各种概念并通过强制规则维持试图和状态间的独立性,我们的代码将会变得更结构化且易维护</p><p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新</p><p><img data-src="../images/vue/vuex.png" alt="vuex"></p><h2 id="什么情况下应该使用-Vuex"><a href="#什么情况下应该使用-Vuex" class="headerlink" title="什么情况下应该使用 Vuex?"></a>什么情况下应该使用 Vuex?</h2><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每个 Vuex 应用的核心就是 store. store 基本上就是个容器, 它包含着你的应用中大部分的状态(state). Vuex 和单纯的全局对象有以下两个点不同</p><ol><li><p>Vuex 的状态存储是响应式的. 当 Vue 组件从 store 中读取状态的时候, 若 store 中的状态发生改变, 那么相应的组件也会响应的得到高效更新</p></li><li><p>不能直接修改 store 中的状态. 改变 store 中的状态的唯一途径就是显示的提交(commit)mutation. 这样使得我们可以方便的跟踪没一个状态的变化, 从而让我们能够实现一些工具帮助我们更好的了解我们的应用</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装 Vuex 之后, 我们可以创建一个 store.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在, 可以通过 <code>store.state</code> 来获取状态对象, 以及通过 <code>store.commit</code> 方法触发状态变更</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p><p>由于 store 中的状态是响应式的, 在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可. 触发变化也仅仅是在组件的 methods 中提交 mutation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接下载 || CDN 引用 &lt;a href=&quot;https://unpkg.com/vuex&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
</feed>
