<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ginger</title>
  
  <subtitle>一个前端er~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-25T08:29:59.967Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ginger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery源码-构造函数jQuery源码结构</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-25T07:54:10.000Z</published>
    <updated>2020-03-25T08:29:59.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造-jQuery-对象的总体源码结构"><a href="#构造-jQuery-对象的总体源码结构" class="headerlink" title="构造 jQuery 对象的总体源码结构"></a>构造 jQuery 对象的总体源码结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自调用匿名函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 jQuery</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回 jQuery.fn.init 的实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 定义一堆变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖构造函数 jQuery() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn = jQuery.protottype = &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 覆盖原型对象的属性 constructor</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">      /**</span><br><span class="line">       * 定义原型方法 负责解析 selector 和 context 的类型并执行相应的查找</span><br><span class="line">      */</span><br><span class="line">      init: function(selector, context, rootjQuery) &#123;</span><br><span class="line">        <span class="comment">// ... 一堆原型属性和方法</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 jQuery 构造函数的原型对象 jQuery.fn 覆盖 jQuery.fn.init() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个或多个对象的属性到第一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 jQuery.extend() 在jQuery构造器上定义了一堆静态属性和方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">      <span class="comment">// 一堆静态属性和方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 jQuery 构造函数并赋值给外层变量 jQuery</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把 jQuery 、 $ 暴露给全局作用域 window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h2 id="为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例"><a href="#为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例" class="headerlink" title="为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例"></a>为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例</h2><p>如果构造函数有返回值, 运算符 new 所创建的对象会被丢弃, 返回值将作为 new 表达式的值</p><p>jQuery 利用这一特性, 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例, 省去构造函数 jQuery() 前面的运算符 new</p><h2 id="为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype"></a>为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype</h2><p>jQuery.fn 是 jQuery.prototype 的简写, 方便拼写</p><h2 id="jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性"><a href="#jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性" class="headerlink" title="jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性"></a>jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性</h2><p>用 jQuery()构造函数的原型对象覆盖了构造函数 jQuery.fn.init()的原型对象, 从而使得 jQuery.fn.init() 的实例也可以访问 jQuery()构造函数的原型方法核属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><h2 id="为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中"><a href="#为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中" class="headerlink" title="为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中"></a>为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中</h2><p>在自调用安徽省农户中定义了很多其他局部变量, 这些局部变量只在 jQuery 对象内部使用, 使用自调用匿名函数可以减少与其他模块的耦合度</p><h2 id="为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype"></a>为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype</h2><p>在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，可以有效减少每个 jQuery 对象所需的内存。事实上，jQuery 对象只包含 5 种非继承属性，其余都继承自原型对象 jQuery.prototype；在构造函数 jQuery.fn.init()中设置了整型属性、length、selector、context；在原型方法.pushStack()中设置了 prevObject。因此，也不必因为 jQuery 对象带有太多的属性和方法而担心会占用太多的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造-jQuery-对象的总体源码结构&quot;&gt;&lt;a href=&quot;#构造-jQuery-对象的总体源码结构&quot; class=&quot;headerlink&quot; title=&quot;构造 jQuery 对象的总体源码结构&quot;&gt;&lt;/a&gt;构造 jQuery 对象的总体源码结构&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/</id>
    <published>2020-03-25T07:51:57.000Z</published>
    <updated>2020-03-25T07:52:07.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数-jQuery"><a href="#构造函数-jQuery" class="headerlink" title="构造函数 jQuery"></a>构造函数 jQuery</h1><p>构造函数 jQuery 有七种用法:</p><ul><li>jQuery(select [,context]): 接受一个 CSS 选择器表达式和可选的选择器上下文, 返回一个包含了匹配的 DOM 元素的 jQuery 对象</li><li>jQuery(html,[, ownerDocument])、jQuery(html, props): 用提供的 HTML 代码创建 DOM 元素</li><li>jQuery(element)、jQuery(elementArray): 封装 DOM 元素为 jQuery 对象</li><li>jQuery(object): 封装普通对象为 jQuery 对象</li><li>jQuery(callback): 绑定 ready 事件监听函数, 当 DOM 结构加载完成时执行</li><li>jQuery(jQuery object): 接受一个 jQuery 对象, 返回该 jQuery 对象的拷贝副本</li><li>jQuery(): 创建一个 jQuery 对象</li></ul><h2 id="jQuery-select-context"><a href="#jQuery-select-context" class="headerlink" title="jQuery(select [,context])"></a>jQuery(select [,context])</h2><p>如果传入一个字符串参数, jQuery 会检查这个字符串是选择器表达式还是 HTML 代码. 如果是选择器表达式, 则遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象. 如果没有元素与之匹配, 则创建一个空 jQuery 对象, 其中不包含任何元素, 其属性 length 等于 0.</p><p>默认情况下, 对匹配元素的查找将从根元素 document 对象开始, 即查找范围是整个文档树, 不过也可以传入第二个参数 context 来限定查找范围</p><p>如果选择器表达式 selector 是简单的 <code>#id</code>, 且没有指定上下文 context, 则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素; 如果是比 <code>#id</code> 复杂的选择器表达式或指定了上下文, 则通过 jQuery 方法 <code>.find()</code> 查找, 因此 <code>$(&#39;span&#39;, this)</code> 等价于 <code>$(this).find(&#39;span&#39;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#app'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $('span', this).html(222);</span></span><br><span class="line">  $(<span class="keyword">this</span>)</span><br><span class="line">    .find(<span class="string">'span'</span>)</span><br><span class="line">    .html(<span class="string">'find'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-html-ownerDocument-、jQuery-html-props"><a href="#jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="jQuery(html [,ownerDocument])、jQuery(html, props)"></a>jQuery(html [,ownerDocument])、jQuery(html, props)</h2><h3 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h3><p>如果传入的字符串参数看起来像一段 HTML 代码, jQuery 则尝试用这段 HTML 代码创建新的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;button&gt;CLICK ME&lt;/button&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><p>如果 HTML 代码是一个单独标签, jQuery 会使用浏览器原生方法 document.createElement() 创建 DOM 元素</p><p>如果是多层嵌套 HTML 片段, 则利用浏览器的 innerHTML 机制创建 DOM 元素, 这个过程由 <code>jQuery.buildFragment()</code> 和 <code>jQuery.clean()</code> 实现</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>ownerDocument 用于指定创建新 DOM 元素的文档对象, 如果不传入, 则默认为当前文档对象</p><p>如果 HTML 代码是一个单独标签, 那么第二个参数还可以是 props, props 是一个包含了属性、事件的普通对象; 在调用 document.createElement() 创建 DOM 元素后, 参数 props 会被传给 jQuery 方法 <code>.attr()</code>, 然后由 <code>.attr()</code> 负责把 props 中的属性、事件设置到新穿创建的 DOM 元素上</p><p>参数 props 的属性可以是任意的事件类型（如”click”），此时属性值应该是事件监听函数，它将被绑定到新创建的 DOM 元素上；参数 props 可以含有以下特殊属性：val、css、html、text、data、width、height、offset，相应的 jQuery 方法：<code>.val()</code>、<code>.css()</code>、<code>.html()</code>、<code>.text()</code>、<code>.data()</code>、<code>.width()</code>、<code>.height()</code>、`.offset()将被执行，并且属性值会作为参数传入；其他类型的属性则会被设置到新创建的 DOM 元素上，某些特殊属性还会做跨浏览器兼容（如 type、value、tabindex 等）；可以通过属性名 class 设置类样式，但要用引号把 class 包裹起来，因为 class 是 JavaScript 保留字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;div /&gt;'</span>, &#123;</span><br><span class="line">  text: <span class="string">'哈哈'</span>,</span><br><span class="line">  class: 'active',</span><br><span class="line">  click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="keyword">this</span>.innerHTML = <span class="string">'嘻嘻'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><h2 id="jQuery-element-、jQuery-elementArray"><a href="#jQuery-element-、jQuery-elementArray" class="headerlink" title="jQuery(element)、jQuery(elementArray)"></a>jQuery(element)、jQuery(elementArray)</h2><p>如果传入一个 DOM 元素或 DOM 元素数组, 则把 DOM 元素封装到 jQuery 对象中并返回</p><p>这个功能常见于事件监听函数, 即把关键字 this 因用那个的 DOM 元素封装为 jQuery 对象, 然后在该 jQuery 对象上调用 jQuery 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).slideUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-object"><a href="#jQuery-object" class="headerlink" title="jQuery(object)"></a>jQuery(object)</h2><p>如果传入一个普通 JavaScript 对象, 则把该对象封装到 jQuery 对象中并返回</p><p>这个功能可以方便的在普通 JavaScript 对象上实现自定义事件的绑定和触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $foo = $(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'worldd'</span> &#125;);</span><br><span class="line">$foo.on(<span class="string">'custom'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;);</span><br><span class="line">$foo.trigger(<span class="string">'custom'</span>); <span class="comment">// -&gt; foo</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-callback"><a href="#jQuery-callback" class="headerlink" title="jQuery(callback)"></a>jQuery(callback)</h2><p>如果传入一个函数, 则在 document 上绑定一个 ready 事件监听函数, 当 DOM 结构加载完成时执行. ready 事件的触发要早于 load 事件.</p><p>ready 事件并不是浏览器原生事件, 而是 DOMContentLoaded 事件、onreadystatechange 事件和函数 doScrollCheck() 的统称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM 加载完毕'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-jQuery-object"><a href="#jQuery-jQuery-object" class="headerlink" title="jQuery(jQuery object)"></a>jQuery(jQuery object)</h2><p>如果传入一个 jQuery 对象, 则创建该 jQuery 对象的一个副本并返回, 副本与传入的 jQuery 对象引用完全相同的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $app = $(<span class="string">'#app'</span>);</span><br><span class="line">$app.html(<span class="string">'xuxu'</span>); <span class="comment">// -&gt; $('#app').html('xuxu')</span></span><br></pre></td></tr></table></figure><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery()"></a>jQuery()</h2><p>如果不传入任何参数, 则返回一个空的 jQuery 对象, 属性 length 为 0.</p><p>这个功能可以用来复用 jQuery 对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数-jQuery&quot;&gt;&lt;a href=&quot;#构造函数-jQuery&quot; class=&quot;headerlink&quot; title=&quot;构造函数 jQuery&quot;&gt;&lt;/a&gt;构造函数 jQuery&lt;/h1&gt;&lt;p&gt;构造函数 jQuery 有七种用法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQ
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-总体架构</title>
    <link href="http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-23T06:47:26.000Z</published>
    <updated>2020-03-23T06:47:59.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>jQuery 的模块总体分为三大部分:</p><ul><li>入口模块(构造 jQuery 对象模块)</li><li>功能模块</li><li>底层支持模块</li></ul><p><img data-src="../images/01%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/jQuery.png" alt="模块导图"></p><h2 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h2><p>入口模块主要功能是构造 jQuery 对象, 如果在调用构造函数 <code>jQuery()</code> 创建 jQuery 对象时传入了选择器表达式, 则会调用功能模块中的选择器 <code>Sizzle</code> 遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象</p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>在功能模块中, 事件系统提供了统一的事件绑定、响应、手动触发和移除机制, 它并没有将事件直接绑定到 DOM 元素上, 而是基于数据缓存模块来管理事件</p><h3 id="Ajax-模块"><a href="#Ajax-模块" class="headerlink" title="Ajax 模块"></a>Ajax 模块</h3><p>Ajax 模块允许从服务器上加载数据, 而不用刷新页面, 它基于异步队列模块来管理核触发回调函数</p><h3 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h3><p>动画模块用于向网页中添加动画效果, 它基于队列模块来管理和执行动画函数</p><h3 id="属性操作模块"><a href="#属性操作模块" class="headerlink" title="属性操作模块"></a>属性操作模块</h3><p>属性操作模块时用于对 HTML 属性和 DOM 属性进行读取、设置和移除操作</p><h3 id="DOM-遍历模块"><a href="#DOM-遍历模块" class="headerlink" title="DOM 遍历模块"></a>DOM 遍历模块</h3><p>DOM 遍历模块用于在 DOM 树中遍历父元素、子元素和兄弟元素</p><h3 id="DOM-操作模块"><a href="#DOM-操作模块" class="headerlink" title="DOM 操作模块"></a>DOM 操作模块</h3><p>DOM 操作模块用于插入、移除、复制和替换 DOM 元素</p><h3 id="样式操作模块"><a href="#样式操作模块" class="headerlink" title="样式操作模块"></a>样式操作模块</h3><p>样式操作模块用于获取计算样式或设置内联样式</p><h3 id="坐标模块"><a href="#坐标模块" class="headerlink" title="坐标模块"></a>坐标模块</h3><p>坐标模块用于读取或设置 DOM 元素的文档坐标</p><h3 id="尺寸模块"><a href="#尺寸模块" class="headerlink" title="尺寸模块"></a>尺寸模块</h3><p>尺寸模块用于获取 DOM 元素的高度和宽度</p><h2 id="底层支持模块"><a href="#底层支持模块" class="headerlink" title="底层支持模块"></a>底层支持模块</h2><p>底层支持模块又分为诸多子模块:</p><ul><li>工具方法: Utilities</li><li>回调函数列表: Callbacks Object</li><li>异步队列: Deferred Object</li><li>浏览器功能测试: Support</li><li>数据缓存: Data</li><li>队列: Queue</li><li>选择器: Sizzle</li></ul><h3 id="工具方法模块"><a href="#工具方法模块" class="headerlink" title="工具方法模块"></a>工具方法模块</h3><p>工具方法模块提供了一些编程辅助方法, 用于简化对 jQuery 对象、DOM 元素、数组、对象、字符串等的操作, 其他模块都会用到工具方法模块</p><h3 id="回调函数列表模块"><a href="#回调函数列表模块" class="headerlink" title="回调函数列表模块"></a>回调函数列表模块</h3><p>回调函数列表模块用于增强对回调函数的管理，支持添加、移除、触发、锁定、禁用回调函数等功能；</p><h3 id="异步队列模块"><a href="#异步队列模块" class="headerlink" title="异步队列模块"></a>异步队列模块</h3><p>异步队列模块用于解耦异步任务和回调函数, 他再回调列表的基础上为回调函数增加了状态, 并提供多个回调函数列表, 支持传播任意同步或异步回调函数的成功或失败状态</p><h3 id="浏览器功能测试模块"><a href="#浏览器功能测试模块" class="headerlink" title="浏览器功能测试模块"></a>浏览器功能测试模块</h3><p>浏览器功能测试模块提供了针对不同浏览器功能和 bug 的测试结果, 其他模块基于这些测试结果来解决浏览器之间的兼容性问题</p><h3 id="数据缓存模块"><a href="#数据缓存模块" class="headerlink" title="数据缓存模块"></a>数据缓存模块</h3><p>数据缓存模块用于为 DOM 元素和 JavaScript 对象附加任意类型的数据</p><h3 id="队列模块"><a href="#队列模块" class="headerlink" title="队列模块"></a>队列模块</h3><p>队列模块用于管理一组函数, 支持函数的入队核出队操作, 并确保函数按顺序执行, 它基于数据缓存模块实现</p><h3 id="选择器模块"><a href="#选择器模块" class="headerlink" title="选择器模块"></a>选择器模块</h3><p>选择器 <code>sizzle</code> 是一个纯 JavaScript 实现的 CSS 选择器引擎, 用于查找与选择表达式匹配的元素集合</p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jQuery = (</span><br><span class="line">    <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery)</span><br><span class="line">    &#125;)()</span><br><span class="line">    <span class="keyword">return</span> jQuery</span><br><span class="line">  )()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工具方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调函数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浏览器功能测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件系统</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 样式操作 CSS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坐标</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h1&gt;&lt;p&gt;jQuery 的模块总体分为三大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口模块(构造 jQuery 对象模块)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>vuex-api</title>
    <link href="http://yoursite.com/2020/03/21/vuex-api/"/>
    <id>http://yoursite.com/2020/03/21/vuex-api/</id>
    <published>2020-03-21T01:40:44.000Z</published>
    <updated>2020-03-21T01:41:01.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex-Store"><a href="#Vuex-Store" class="headerlink" title="Vuex.Store"></a>Vuex.Store</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; ...options &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex-Store-构造器选项"><a href="#Vuex-Store-构造器选项" class="headerlink" title="Vuex.Store 构造器选项"></a>Vuex.Store 构造器选项</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>类型: <code>Object | Function</code><br>Vuex store 实例的根 state 对象</p><p>如果传入返回一个对象的函数, 其返回的对象会被用作根 state.</p></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li>类型: <code>{ [type: string ]: Function }</code><br>在 store 上注册 mutation, 处理函数总是接受 <code>state</code> 作为第一个参数(如果定义在模块中, 则为模块的局部状态), <code>payload</code>作为第二个参数</li></ul><h3 id="sctions"><a href="#sctions" class="headerlink" title="sctions"></a>sctions</h3><ul><li><p>类型: <code>{ [type: string]: Function }</code><br>在 store 上注册 action. 处理函数总是接受 <code>context</code> 作为第一个参数, <code>payload</code> 作为第二个参数</p><p><code>context</code> 对象包含以下属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state, <span class="comment">// 等同于 `store.state`，若在模块中则为局部状态</span></span><br><span class="line">    rootState, <span class="comment">// 等同于 `store.state`，只存在于模块中</span></span><br><span class="line">    commit, <span class="comment">// 等同于 `store.commit`</span></span><br><span class="line">    dispatch, <span class="comment">// 等同于 `store.dispatch`</span></span><br><span class="line">    getters, <span class="comment">// 等同于 `store.getters`</span></span><br><span class="line">    rootGetters <span class="comment">// 等同于 `store.getters`，只存在于模块中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ul><li><p>类型: <code>{ [type: string ]: Function}</code></p><p>在 store 上注册 getter, getter 方法接受以下参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state, getters</span><br></pre></td></tr></table></figure><p>当定义在一个模块粒时会特别一些:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state, <span class="comment">// 如果在模块中定义则为模块的局部状态</span></span><br><span class="line">  getters, <span class="comment">// 等同于 store.getters</span></span><br><span class="line">  rootState, <span class="comment">// 等同于 store.state</span></span><br><span class="line">  rootGetters <span class="comment">// 所有 getters</span></span><br></pre></td></tr></table></figure><p>注册的 getter 为暴露为 getters</p></li></ul><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ul><li>类型: <code>Object</code><br>包含了子模块的对象, 会被合并到 store<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    state,</span><br><span class="line">    namespaced?,</span><br><span class="line">    mutations,</span><br><span class="line">    actions?,</span><br><span class="line">    getters?,</span><br><span class="line">    modules?</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>与根模块的选项一样, 每个模块也包含 <code>state</code> 和 <code>mutations</code> 选项. 模块的状态使用 <code>key</code> 关联到 store 的根状态. 模块的 mutation 和 getter 只会接受 module 的局部状态作为第一个参数, 而不是根状态, 并且模块的 action 的 <code>context.state</code> 同样指向局部状态</li></ul><h3 id="pulgins"><a href="#pulgins" class="headerlink" title="pulgins"></a>pulgins</h3><ul><li>类型: <code>Array&lt;Function&gt;</code><br>一个数组, 包含应用在 store 上的插件方法. 这些插件直接接受 store 作为唯一参数, 可以监听 mutation 或者提交 mutation</li></ul><h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><ul><li>类型: <code>Boolean</code></li><li>默认值: <code>false</code><br>使 Vuex store 进入严格模式, 在严格模式下, 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</li></ul><h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul><li>类型: <code>Boolean</code><br>为某个特定的 Vuex 实例打开或关闭 devtools. 对于传入 false 的实例来说 Vuex store 不会订阅到 devtools 插件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  devtools: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vuex-Store-实例属性"><a href="#Vuex-Store-实例属性" class="headerlink" title="Vuex.Store 实例属性"></a>Vuex.Store 实例属性</h2><h3 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h3><ul><li>类型: <code>Object</code><br>根状态, 只读</li></ul><h3 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h3><ul><li>类型: <code>Object</code><br>暴露出注册的 getter, 只读</li></ul><h2 id="Vuex-Store-实例方法"><a href="#Vuex-Store-实例方法" class="headerlink" title="Vuex.Store 实例方法"></a>Vuex.Store 实例方法</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul><li><p><code>commit(type: string, payload?:any, options?: Object)</code></p></li><li><p><code>commit(mutation: Object, options?: Object)</code></p><p>提交 mutation, <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里提交根的 mutation</p></li></ul><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><ul><li><p><code>dispatch(type: string, payload?:any, options?: Pbject)</code></p></li><li><p><code>dispatch(action: Object, options?: Object)</code></p><p>分发 action. <code>options</code> 里可以有 <code>root: true</code>, 它允许在命名空间模块里分发根的 action. 返回一个解析所有被触发的 action 处理器的 Promise</p></li></ul><h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h3><ul><li><p><code>replaceState(state: Object)</code></p><p>替换 store 的根状态, 仅用状态合并或时光旅行调试</p></li></ul><h3 id="wathc"><a href="#wathc" class="headerlink" title="wathc"></a>wathc</h3><ul><li><p><code>watch(fn: Function, callback: Funtion, options?: Object): Function</code></p><p>响应式的侦听 <code>fn</code> 的返回值, 当值改变时调用回调函数. <code>fn</code> 接受 store 的 state 作为第一个参数, 其 getter 作为第二个参数, 最后接受一个可选对象参数表示 Vue 的<code>vm.$watch</code>方法的参数</p><p>要停止侦听, 调用此方法返回的函数即可停止侦听</p></li></ul><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><ul><li><p><code>subscribe(handler: Function):Function</code></p><p>订阅 store 的 mutation. <code>hanlder</code> 会在每个 mutation 完成后调用, 接受 mutation 和经过 mutation 后的状态作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.type)</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.paylaod)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅, 调用此方法返回的函数可停止订阅</p></li></ul><h3 id="subscribeAction"><a href="#subscribeAction" class="headerlink" title="subscribeAction"></a>subscribeAction</h3><ul><li><p><code>subscribeAction(handler: Function): Function</code></p><p>订阅 store 的 action。handler 会在每个 action 分发的时候调用并接收 action 描述和当前的 store 的 state 这两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(action.type)</span><br><span class="line">  <span class="built_in">console</span>.log(action.payload)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要停止订阅，调用此方法返回的函数即可停止订阅。</p><p>从 3.1.0 起，subscribeAction 也可以指定订阅处理函数的被调用时机应该在一个 action 分发之前还是之后 (默认行为是之前)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store.subscribeAction(&#123;</span><br><span class="line">  before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.type&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="registerModule"><a href="#registerModule" class="headerlink" title="registerModule"></a>registerModule</h3><ul><li><p><code>registerModule(path: string | Array&lt;string&gt;, module: Module, options?: Object)</code></p><p>注册一个动态模块</p><p>options 可以包含 <code>preserveState: true</code> 以允许保留之前的 state。用于服务端渲染。</p></li></ul><h3 id="unregisterModule"><a href="#unregisterModule" class="headerlink" title="unregisterModule"></a>unregisterModule</h3><ul><li><p><code>unregisterModule(path: string | Array&lt;string&gt;)</code></p><p>卸载一个动态模块。</p></li></ul><h3 id="hotUpdate"><a href="#hotUpdate" class="headerlink" title="hotUpdate"></a>hotUpdate</h3><ul><li><p><code>hotUpdate(newOptions: Object)</code></p><p>热替换新的 action 和 mutation。详细介绍</p></li></ul><h2 id="组件绑定的辅助函数"><a href="#组件绑定的辅助函数" class="headerlink" title="组件绑定的辅助函数"></a>组件绑定的辅助函数</h2><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><ul><li><p><code>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | Function&gt;): Object</code></p><p>为组件创建计算属性以返回 Vuex store 中的状态</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数</p></li></ul><h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><ul><li><p><code>mapGetters(namespace?: string, map: Array&lt;string&gt; | Object&lt;string&gt;): Object</code></p><p>为组件创建计算属性以返回 getter 的返回值</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p></li></ul><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><ul><li><p><code>mapActions(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法分发 action</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(dispatch: function, ...args: any[])</code></p></li></ul><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><ul><li><p><code>mapMutations(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p><p>创建组件方法提交的 mutation</p><p>第一个参数是可选的, 可以是一个命名空间字符串</p><p>对象形式的第二个参数的成员可以是一个函数 <code>function(commit: function, ...args: any[])</code></p></li></ul><h3 id="createNamespacedHelpers"><a href="#createNamespacedHelpers" class="headerlink" title="createNamespacedHelpers"></a>createNamespacedHelpers</h3><ul><li><p><code>createNamespacedHelpers(namespace: string): Object</code></p><p>创建基于命名空间的组件绑定辅助函数。其返回一个包含 mapState、mapGetters、mapActions 和 mapMutations 的对象。它们都已经绑定在了给定的命名空间上</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex-Store&quot;&gt;&lt;a href=&quot;#Vuex-Store&quot; class=&quot;headerlink&quot; title=&quot;Vuex.Store&quot;&gt;&lt;/a&gt;Vuex.Store&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Module</title>
    <link href="http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/"/>
    <id>http://yoursite.com/2020/03/20/vuex%E6%A0%B8%E5%BF%83-Module/</id>
    <published>2020-03-20T01:48:54.000Z</published>
    <updated>2020-03-20T01:49:10.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有可能变得相当臃肿</p><p>为了解决以上问题, Vuex 允许我们将 store 分割成模块. 每个模块拥有自己的 state、Mutation、Action、Getter、甚至是嵌套子模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutaions: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><h2 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h2><p>对于模块内部的 mutaion 和 getter, 接受的第一个参数是模块的局部状态对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 此处 state 是局部的状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样, 对于模块内部的 action, 局部状态通过 <code>context.state</code> 暴露出来, 根节点状态则为 <code>context.rootState</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum(&#123;state, commit, rootState&#125;)&#123;</span><br><span class="line">      <span class="keyword">if</span>((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于模块内部的 getter, 根节点状态会作为第三个参数暴露出来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount(state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下, 模块内部的 action、mutation 和 getter 是注册在全局命名空间的–这样使得多个模块能够对同一 mutation 或 action 做出反应</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容 (module assets)</span></span><br><span class="line">      state: &#123; ... &#125; <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>, <code>dispatch</code> 和 <code>commit</code>. 换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码</p><h3 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h3><p>如果希望使用全局 state 和 getter, <code>rootState</code> 和 ``rootState<code>会作为第三和第四参数传入 getter, 也会通过</code>context<code>对象的属性传入</code>action`</p><p>若需要在全局命名空间内分发 action 或提交 mutation, 将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中, getters 被局部化了</span></span><br><span class="line">      <span class="comment">// 可以使用 getter 的第四个参数来调用 rootGetters</span></span><br><span class="line">      someGetter( state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; foo/someOtherGetter</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; someOtherGetter</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    acctions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中, dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 root 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction(&#123;dispatch, commit, getters, rootGetters&#125;) &#123;</span><br><span class="line">        getters.somegetter <span class="comment">// -&gt; foo/somegetter</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; somegetter</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; foo/someOtherAction</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someOtherAction</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; foo/someMutation</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; someMutation</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction(ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="headerlink" title="在带命名空间的模块注册全局 action"></a>在带命名空间的模块注册全局 action</h3><p>若要在带命名空间的模块注册全局 action, 可以添加 <code>root: true</code>, 并将这个 action 定义放在函数 <code>handler</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction(&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">'someAction'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler( namespacedContext, patload) &#123; ... &#125; <span class="comment">// -&gt; someAction</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>当使用 <code>mapState</code>、<code>mapgetters</code>、<code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时, 写起来可能比较繁琐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  )]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述情况, 可以将模块的空间名称字符串作为第一个参数传递给上述函数, 这样所有绑定都会自动将该模块作为上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且可以使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数, 它返回一个对象, 对象里有新的绑定在给定命名空间值上的组件绑定辅助函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapAcrions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 some/nested/module 中查找</span></span><br><span class="line">    ...mapActions([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h2><p>如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过插件的参数对象得到空间名称</span></span><br><span class="line"><span class="comment">// 然后返回 Vuex 插件函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPlugin</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把空间名字添加到插件模块的类型（type）中去</span></span><br><span class="line">    <span class="keyword">const</span> namespace = options.namespace || <span class="string">''</span></span><br><span class="line">    store.dispatch(namespace + <span class="string">'pluginAction'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h2><p>在 <code>store</code> 创建之后, 可以使用 <code>store.registerModule</code> 方法注册模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 <code>store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）</p><h3 id="保留-state"><a href="#保留-state" class="headerlink" title="保留 state"></a>保留 state</h3><p>在注册一个新 module 时, 你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <code>preserveState</code> 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</p><p>当你设置 preserveState: true 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</p><h2 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h2><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li>创建多个 store, 他们公用一个模块</li><li>在一个 store 中多次注册同一模块</li></ul><p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p><p>实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Module&quot;&gt;&lt;a href=&quot;#Module&quot; class=&quot;headerlink&quot; title=&quot;Module&quot;&gt;&lt;/a&gt;Module&lt;/h2&gt;&lt;p&gt;由于使用单一状态树, 应用的所有状态会集中到一个比较大的对象. 当应用变得非常复杂时, store 对象就有
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Action</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Action/</id>
    <published>2020-03-19T02:24:14.000Z</published>
    <updated>2020-03-21T01:40:54.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation, 不同在于:</p><ul><li>Action 提交的是 mutation, 而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><p>注册一个简单的 action:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个 store 实例具有相同方法核属性的 context 对象, 因此你可以调用 <code>context.commit</code> 提交一个 mutation, 或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p><p>实践中, 我们经常会用到 ES2015 的参数解构来简化代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h2><p>Action 通过 <code>store.dispatch</code> 方法触发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><p>action 内部可以执行异步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync(&#123;commit&#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  cmount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h2><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action, 或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">    <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">  ]),</span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    add: <span class="string">'increment'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h2><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise, 并且 <code>store.dispatch</code> 仍旧返回 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 可以利用 async/await 组合 action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA(&#123;commit&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB(&#123;dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>)</span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h2&gt;&lt;p&gt;Action 类似于 mutation, 不同在于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action 提交的是 mu
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Mutation</title>
    <link href="http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/"/>
    <id>http://yoursite.com/2020/03/19/vuex%E6%A0%B8%E5%BF%83-Mutation/</id>
    <published>2020-03-19T01:58:02.000Z</published>
    <updated>2020-03-19T01:58:13.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的 mutation 非常类似于事件:每个 mutation 都有一个字符串的事件类型和一个回调函数. 这个回调函数就是我们实际进行状态更改的地方, 并且他会接受 state 作为第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不能直接调用一个 mutation handler. 这个选项更像是事件注册: “当触发一个类型为 <code>increment</code> 的 mutation 时, 调用此函数. “要唤醒一个 mutation handler, 需要已相应的 type 调用 <code>store.commit</code> 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><h2 id="提交载荷-Payload"><a href="#提交载荷-Payload" class="headerlink" title="提交载荷 (Payload)"></a>提交载荷 (Payload)</h2><p>可以向 <code>store.commit</code> 传入额外的参数, 即 mutation 的载荷 (Payload)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: <span class="function">(<span class="params">state, n</span>) =&gt;</span> &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在大多数情况下, 载荷应该是一个对象, 这样可以包含多个字段并且记录的 mutation 会更易读:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123; <span class="attr">amount</span>: <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用对象风格的提交方式, 整个对象都作为载荷传给 mutation 函数, 因此 handler 保持不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment: (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h2><p>既然 Vuex 的 store 中的状态是响应式的, 那么当我们变更状态时, 监视状态的 Vue 组件也会自动更新. 这也意味着 Vuex 中的 mutation 也需要与使用 Vuex 一样遵守一些注意事项</p><ol><li>最好提前在 store 中初始化好所有的所需属性</li><li>当需要在对象上添加新属性时, 应该:</li></ol><ul><li>使用 Vue.set(obj, ‘newProp’, 123)</li><li>以新对象替换老对象. 例如, 利用对象展开运算符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用常亮代替-Mutation-事件类型"><a href="#使用常亮代替-Mutation-事件类型" class="headerlink" title="使用常亮代替 Mutation 事件类型"></a>使用常亮代替 Mutation 事件类型</h2><p>使用常亮替代 mutation 事件类型在各种 Flux 实现中是很常见的模式. 这样可以使 linter 之类的工具发挥作用, 同时把这些常亮放在单独的文件中可以让代码合作者对整个 app 包含的 mutation 一目了然</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION](state) &#123;</span><br><span class="line">      <span class="comment">//  mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h2><p>一条重要的原则就是 mutation 必须是同步函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation(state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h2 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h2><p>可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation, 或者使用 <code>mapMutation</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">'increment'</span>, <span class="string">'incrementby'</span>]),</span><br><span class="line">    ...mapMutations([(add: <span class="string">'increment'</span>)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mutation&quot;&gt;&lt;a href=&quot;#Mutation&quot; class=&quot;headerlink&quot; title=&quot;Mutation&quot;&gt;&lt;/a&gt;Mutation&lt;/h2&gt;&lt;p&gt;更改 Vuex 的 store 中的状态的唯一方法是提交 mutation. Vuex 中的
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-Getter</title>
    <link href="http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/"/>
    <id>http://yoursite.com/2020/03/18/vuex%E6%A0%B8%E5%BF%83-Getter/</id>
    <published>2020-03-18T08:30:52.000Z</published>
    <updated>2020-03-18T08:31:06.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个组件需要用到此属性, 我们要复制这个函数, 或者抽取到一个共享函数然后在多处导入它</p><p>Vuex 允许我们在 store 中定义 getter(可以认为是 store 的计算属性). 就像计算属性一样. getter 的返回值会根据他的依赖被缓存起来, 且只有当它的依赖值发生了改变才会被重新计算.</p><p>Getter 接受 state 作为其第一个参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h2><p>getter 会暴露 <code>store.getters</code> 对象, 可以以属性的形式访问这些值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123;id:1, text: '...', done: true&#125;]</span></span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.state.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们可以很容易的在任何组件中使用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的</p><h2 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h2><p>也可以通过让 getter 返回一个函数, 来实现给 getter 传参.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> tido.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// &#123; id: 2, text: '...', done: false&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>getter 在通过方法访问时, 每次都会去进行调用, 不会缓存结果.</p></blockquote><h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p><code>mapgetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapgetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([<span class="string">'doneTodosCount'</span>, <span class="string">'anotherGetter'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想将一个 getter 属性另取一个名字, 使用对象形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapGetters([(doneCount: <span class="string">'doneTodosCount'</span>)])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Getter&quot;&gt;&lt;a href=&quot;#Getter&quot; class=&quot;headerlink&quot; title=&quot;Getter&quot;&gt;&lt;/a&gt;Getter&lt;/h2&gt;&lt;p&gt;有时候我们需要从 store 中的 state 中派生出一些状态, 比如对列表进行过滤并记数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex核心-State</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E6%A0%B8%E5%BF%83-State/</id>
    <published>2020-03-17T07:30:16.000Z</published>
    <updated>2020-03-17T07:30:29.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用 <strong>单一状态树</strong> 用一个对象就包含了全部的应用层级状态. 至此它便作为一个唯一数据源而存在. 意味着, 每个应用将仅仅包含一个 store 实例. 单一状态树让我们能够直接地定位任一特定的状态片段, 在调试的过程中也能轻易地取得整个当前应用状态的快照.</p><h3 id="在组件中获得-Vuex-状态"><a href="#在组件中获得-Vuex-状态" class="headerlink" title="在组件中获得 Vuex 状态"></a>在组件中获得 Vuex 状态</h3><p>由于 Vuex 的状态储存是响应式的, 从 store 实例中读取状态的最简单的方法就是在计算属性中返回某个状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter - &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性, 并且触发更新相关联的 DOM</p><p>然而, 这种模式导致组件依赖全局状态单例. 在模块化的构建系统中, 在每个需要使用 state 的组件中需要频繁的导入, 并且在测试组件时需要模拟状态</p><p>Vuex 通过 <code>store</code> 选项, 提供了一种机制将状态从根组件注入到每一个子组件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class='app'&gt;</span></span><br><span class="line"><span class="string">    &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过在根实例中注册 <code>store</code> 选项, 该 store 实例会注入到根组件下的所有子组件中, 且子组件能通过 <code>this.$store</code> 访问到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>当一个组件需要获取多个状态的时候, 将这些状态都声明为计算属性会有些重复和冗余, 为了解决这个问题, 我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数更简洁</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 count 等同于 state =&gt; state.count</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性名称与 state 的子节点名称相同时, 我们也可以给 <code>mapState</code> 传一个字符串数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">computed: mapState([<span class="string">'count'</span>])</span><br></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p><code>mapState</code> 函数返回的是一个对象, 可以通过展开运算符将它与局部计算属性混合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState([<span class="string">'count'</span>]),</span><br><span class="line">  localComputed() &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件仍保有局部状态"><a href="#组件仍保有局部状态" class="headerlink" title="组件仍保有局部状态"></a>组件仍保有局部状态</h3><p>使用 Vuex 并不意味着需要将所有的状态放入 Vuex. 如果有些状态严格属于单个组件, 最好还是作为组件的局部状态.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;State&quot;&gt;&lt;a href=&quot;#State&quot; class=&quot;headerlink&quot; title=&quot;State&quot;&gt;&lt;/a&gt;State&lt;/h2&gt;&lt;p&gt;Vuex 使用 &lt;strong&gt;单一状态树&lt;/strong&gt; 用一个对象就包含了全部的应用层级状态. 至此它便作为一
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex安装介绍与起步</title>
    <link href="http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/03/17/vuex%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D%E4%B8%8E%E8%B5%B7%E6%AD%A5/</id>
    <published>2020-03-17T07:02:31.000Z</published>
    <updated>2020-03-17T07:02:47.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>直接下载 || CDN 引用 <a href="https://unpkg.com/vuex" target="_blank" rel="noopener">vuex</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/vuex.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>NPM</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><ul><li>Yarn</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure><ul><li>在一个模块化的打包系统中, 必须显示地通过 <code>Vue.use()</code> 来安装 <code>Vuex</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h2 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么?"></a>Vuex 是什么?</h2><p>Vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式. 它采用集中式存储管理应用的所有组件的状态, 并已相应的规则保证状态以一种可预测的方式发生变化. Vuex 也集成到 Vue 的官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</p><h2 id="什么是状态管理模式"><a href="#什么是状态管理模式" class="headerlink" title="什么是状态管理模式?"></a>什么是状态管理模式?</h2><p>已一个简单的 Vue 记数应用开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// view</span></span><br><span class="line">  template: <span class="string">'&lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt;'</span>,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个状态管理应用包含以下几个部分:</p><ul><li>state: 驱动应用的数据源</li><li>view: 以声明方式将 state 映射到试图</li><li>actions: 响应在 view 上的用户输入导致的状态变化</li></ul><p>以下是一个表示单项数据流理念的简单示意图:</p><p><img data-src="../../image/flow.png" alt="flow"></p><p>当我们遇到多个组件共享状态时, 单项数据流的简洁性很容易被破坏:</p><ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul><p>对于问题一, 传参的方法对于多层嵌套的组件将会非常繁琐, 并且对于兄弟组件间的状态传递无能为力<br>对于问题二, 我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝.</p><p>因此, 我们为什么不把组件的共享状态抽取出来, 以一个全局单例模式管理呢? 在这种模式下, 我们组件树构成了一个巨大的试图, 不管树在那个位置, 任何组件都能获取状态或者触发行为.</p><p>通过定义和隔离状态管理中的各种概念并通过强制规则维持试图和状态间的独立性,我们的代码将会变得更结构化且易维护</p><p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新</p><p><img data-src="../../image/vuex.png" alt="vuex"></p><h2 id="什么情况下应该使用-Vuex"><a href="#什么情况下应该使用-Vuex" class="headerlink" title="什么情况下应该使用 Vuex?"></a>什么情况下应该使用 Vuex?</h2><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每个 Vuex 应用的核心就是 store. store 基本上就是个容器, 它包含着你的应用中大部分的状态(state). Vuex 和单纯的全局对象有以下两个点不同</p><ol><li><p>Vuex 的状态存储是响应式的. 当 Vue 组件从 store 中读取状态的时候, 若 store 中的状态发生改变, 那么相应的组件也会响应的得到高效更新</p></li><li><p>不能直接修改 store 中的状态. 改变 store 中的状态的唯一途径就是显示的提交(commit)mutation. 这样使得我们可以方便的跟踪没一个状态的变化, 从而让我们能够实现一些工具帮助我们更好的了解我们的应用</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装 Vuex 之后, 我们可以创建一个 store.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在, 可以通过 <code>store.state</code> 来获取状态对象, 以及通过 <code>store.commit</code> 方法触发状态变更</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p><p>由于 store 中的状态是响应式的, 在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可. 触发变化也仅仅是在组件的 methods 中提交 mutation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接下载 || CDN 引用 &lt;a href=&quot;https://unpkg.com/vuex&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由对象与组件注入</title>
    <link href="http://yoursite.com/2020/03/16/vue-router%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/16/vue-router%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-16T05:11:19.000Z</published>
    <updated>2020-03-16T05:11:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由对象"><a href="#路由对象" class="headerlink" title="路由对象"></a>路由对象</h2><p>一个路由对象表示当前激活的路由的状态信息, 包含了当前 URL 解析得到的信息, 还有 URL 匹配到的路由记录</p><p>路由对象是不可变的, 每次成功导航后都会产生一个新的对象</p><p>路由对象出现在多个地方:</p><ul><li><p>组件内, <code>this.$route</code></p></li><li><p>在 <code>$route</code> 观察者回调内</p></li><li><p><code>router.match(localtion)</code> 返回值</p></li><li><p>导航守卫的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to 和 from 都是路由对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>scrollBehavior</code> 方法的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VurRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition)=&gt; &#123;</span><br><span class="line">    <span class="comment">// to 和 from 都是路由对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由对象属性"><a href="#路由对象属性" class="headerlink" title="路由对象属性"></a>路由对象属性</h2><ul><li><code>$route.path</code><ul><li>类型: string<br>字符串, 对应当前路由的路径, 总是解析为绝对路径,如: ‘/foo/bar’</li></ul></li><li><code>$route.params</code><ul><li>类型: Object<br>一个 key/value 对象, 包含了动态片段和全匹配片段, 如果没有路由参数, 就是一个空对象</li></ul></li><li><code>$route.query</code><ul><li>类型: Object<br>一个 key/value 对象，表示 URL 查询参数。例如，对于路径 <code>/foo?user=1</code>，则有 <code>$route.query.user == 1</code>，如果没有查询参数，则是个空对象。</li></ul></li><li><code>$route.hash</code><ul><li>类型: string<br>当前路由的 hash 值(带#), 如果没有 hash 值, 则为空字符串</li></ul></li><li><code>$route.fullPath</code><ul><li>类型: string<br>完成解析后的 url, 包含查询参数核 hash 的完整路径</li></ul></li><li><code>$route.matched</code><ul><li>类型: Array<RouteRecord><br>一个数组，包含当前路由的所有嵌套路径片段的路由记录 。路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。</li></ul></li></ul><pre><code>当 URL 为 `/foo/bar`，`$route.matched` 将会是一个包含从上到下的所有对象 (副本)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 下面的对象就是路由记录</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        <span class="comment">// 这也是个路由记录</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'bar'</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>$route.name</code><br>当前路由的名称</p></li><li><p><code>$route.redirectedFrom</code><br>如果存在重定向, 即为重定向来源的路由的名字</p></li></ul><h2 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h2><h3 id="注入的属性"><a href="#注入的属性" class="headerlink" title="注入的属性"></a>注入的属性</h3><p>通过在 Vue 根实例的 router 配置传入 router 实例，下面这些属性成员会被注入到每个子组件。</p><ul><li><p><code>this.$router</code></p></li><li><p>router 实例。</p></li><li><p><code>this.$route</code></p></li></ul><p>当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。</p><h3 id="增加的组件配置选项"><a href="#增加的组件配置选项" class="headerlink" title="增加的组件配置选项"></a>增加的组件配置选项</h3><ul><li><p>beforeRouteEnter</p></li><li><p>beforeRouteUpdate</p></li><li><p>beforeRouteLeave</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由对象&quot;&gt;&lt;a href=&quot;#路由对象&quot; class=&quot;headerlink&quot; title=&quot;路由对象&quot;&gt;&lt;/a&gt;路由对象&lt;/h2&gt;&lt;p&gt;一个路由对象表示当前激活的路由的状态信息, 包含了当前 URL 解析得到的信息, 还有 URL 匹配到的路由记录&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router实例</title>
    <link href="http://yoursite.com/2020/03/12/vue-router%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/12/vue-router%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-03-12T07:15:07.000Z</published>
    <updated>2020-03-12T07:15:17.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Router-实例属性"><a href="#Router-实例属性" class="headerlink" title="Router 实例属性"></a>Router 实例属性</h2><ul><li><p>router.app</p></li><li><p>类型: Vue instance<br>配置了 router 的 Vue 根实例</p></li><li><p>router.mode</p></li><li><p>类型: string<br>路由使用的模式</p></li><li><p>router.currentRoute</p></li><li><p>类型 Route<br>当前路由对应的路由信息对象</p></li></ul><h2 id="Router-实例方法"><a href="#Router-实例方法" class="headerlink" title="Router 实例方法"></a>Router 实例方法</h2><h3 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h3><ul><li><p>router.beforeEach</p></li><li><p>router.beforeResolv</p></li><li><p>router.afterResolve</p></li><li><p>router.afterEach</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都返回一个移除已注册的守卫/钩子的函数。</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 必须调用 `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 必须调用 `next` */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态导航到一个新的-URL"><a href="#动态导航到一个新的-URL" class="headerlink" title="动态导航到一个新的 URL"></a>动态导航到一个新的 URL</h3><ul><li><p>router.push</p></li><li><p>router.replace</p></li><li><p>router.go</p></li><li><p>router.back</p></li><li><p>router.forward</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br><span class="line">router.push(location).then(onComplete).catch(onAbort)</span><br><span class="line">router.replace(location, onComplete?, onAbort?)</span><br><span class="line">router.replace(location).then(onComplete).catch(onAbort)</span><br><span class="line">router.go(n)</span><br><span class="line">router.back()</span><br><span class="line">router.forward()</span><br></pre></td></tr></table></figure></li></ul><h3 id="返回目标位置或当前路由匹配的组件数组"><a href="#返回目标位置或当前路由匹配的组件数组" class="headerlink" title="返回目标位置或当前路由匹配的组件数组"></a>返回目标位置或当前路由匹配的组件数组</h3><ul><li><p>router.getMatchedComponents</p><p>函数签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在服务端渲染的数据预加载时使用。</span></span><br><span class="line"><span class="keyword">const</span> matchedComponents: <span class="built_in">Array</span>&lt;Component&gt; = router.getMatchedComponents(location?)</span><br></pre></td></tr></table></figure></li></ul><h3 id="解析目标位置"><a href="#解析目标位置" class="headerlink" title="解析目标位置"></a>解析目标位置</h3><ul><li><p>router.resolve</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved: &#123;</span><br><span class="line">  location: Location;</span><br><span class="line">  route: Route;</span><br><span class="line">  href: string;</span><br><span class="line">&#125; = router.resolve(location, current?, append?)</span><br></pre></td></tr></table></figure><p>解析目标位置 (格式和 <router-link> 的 to prop 一样)</p></li><li><p>current 是当前默认的路由 (通常你不需要改变它)</p></li><li><p>append 允许你在 current 路由上附加路径 (如同 router-link)</p></li></ul><h3 id="动态添加更多的路由规则"><a href="#动态添加更多的路由规则" class="headerlink" title="动态添加更多的路由规则"></a>动态添加更多的路由规则</h3><ul><li><p>router.addRoutes</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。</span></span><br><span class="line">router.addRoutes((routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;))</span><br></pre></td></tr></table></figure></li></ul><h3 id="router-onReady"><a href="#router-onReady" class="headerlink" title="router.onReady"></a>router.onReady</h3><p>该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。<br>这可以有效确保服务端渲染时服务端和客户端输出的一致。<br>第二个参数 errorCallback 只在 2.4+ 支持。它会在初始化路由解析运行出错 (比如解析一个异步组件失败) 时被调用。</p><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.onReady(callback, [errorCallback])</span><br></pre></td></tr></table></figure><h3 id="router-onError"><a href="#router-onError" class="headerlink" title="router.onError"></a>router.onError</h3><p>注册一个回调，该回调会在路由导航过程中出错时被调用。注意被调用的错误必须是下列情形中的一种：</p><ul><li><p>错误在一个路由守卫函数中被同步抛出；</p></li><li><p>错误在一个路由守卫函数中通过调用 next(err) 的方式异步捕获并处理；</p></li><li><p>渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。</p></li></ul><p>函数签名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.onError(callback)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Router-实例属性&quot;&gt;&lt;a href=&quot;#Router-实例属性&quot; class=&quot;headerlink&quot; title=&quot;Router 实例属性&quot;&gt;&lt;/a&gt;Router 实例属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;router.app&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router构建选项</title>
    <link href="http://yoursite.com/2020/03/11/vue-router%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9/"/>
    <id>http://yoursite.com/2020/03/11/vue-router%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9/</id>
    <published>2020-03-11T06:51:56.000Z</published>
    <updated>2020-03-11T06:52:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h2><ul><li><p>类型: Array<RouteConfig><br>RouteConfig 的类型定义:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RouteConfig = &#123;</span><br><span class="line">  path: <span class="built_in">string</span>,</span><br><span class="line">  component?: Component,</span><br><span class="line">  name?: <span class="built_in">string</span>, <span class="comment">// 命名路由</span></span><br><span class="line">  components?: &#123; [name: <span class="built_in">string</span>]: Component &#125;, <span class="comment">// 命名视图组件</span></span><br><span class="line">  redirect?: <span class="built_in">string</span> | Location | <span class="built_in">Function</span>,</span><br><span class="line">  props?: <span class="built_in">boolean</span> | <span class="built_in">Object</span> | <span class="built_in">Function</span>,</span><br><span class="line">  alias?: <span class="built_in">string</span> | <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  children?: <span class="built_in">Array</span>&lt;RouteConfig&gt;, <span class="comment">// 嵌套路由</span></span><br><span class="line">  beforeEnter?: <span class="function">(<span class="params">to: Route, <span class="keyword">from</span>: Route, next: <span class="built_in">Function</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  meta?: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.6.0+</span></span><br><span class="line">  caseSensitive?: <span class="built_in">boolean</span>, <span class="comment">// 匹配规则是否大小写敏感？(默认值：false)</span></span><br><span class="line">  pathToRegexpOptions?: <span class="built_in">Object</span> <span class="comment">// 编译正则的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><ul><li>类型: string</li><li>默认值: hash | abstract</li><li>可选值: hash | history | abstract<br>配置路由模式:<ul><li>hash: 使用 URL hash 值来作路由. 支持所有浏览器, 包括不支持 HTML5 History Api 的浏览器</li><li>history: 依赖 HTML5 History API 和服务器配置</li><li>abstract: 支持所有 JavaScript 运行环境, 如 Node.js 服务器端, 如果发现没有浏览器的 API, 路由会自动强制进入这个模式</li></ul></li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><ul><li>类型: string</li><li>默认值: ‘/‘<br>应用的基路径, 例如, 如果整个单页应用服务在 <code>/app/</code> 下, 然后 base 就应该设为 <code>/app/</code></li></ul><h2 id="linkActiveClass"><a href="#linkActiveClass" class="headerlink" title="linkActiveClass"></a>linkActiveClass</h2><ul><li>类型: string</li><li>默认值: router-link-active<br>全局配置 <code>&lt;router-link&gt;</code> 默认的激活 class</li></ul><h2 id="linkExactActiveClass"><a href="#linkExactActiveClass" class="headerlink" title="linkExactActiveClass"></a>linkExactActiveClass</h2><ul><li>类型: string</li><li>默认值: router-link-exact-active<br>全局配置 <code>&lt;router-link&gt;</code> 默认的精确激活的 class</li></ul><h2 id="scrollBehavior"><a href="#scrollBehavior" class="headerlink" title="scrollBehavior"></a>scrollBehavior</h2><ul><li><p>类型: Function<br>签名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type PositionDescriptor &#x3D;</span><br><span class="line">&#123; x: number, y: number &#125; |</span><br><span class="line">&#123; selector: string &#125; |</span><br><span class="line">?&#123;&#125;</span><br><span class="line"></span><br><span class="line">type scrollBehaviorHandler &#x3D; (</span><br><span class="line">to: Route,</span><br><span class="line">from: Route,</span><br><span class="line">savedPosition?: &#123; x: number, y: number &#125;</span><br><span class="line">) &#x3D;&gt; PositionDescriptor | Promise&lt;PositionDescriptor&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="parseQuery-stringifyQuery"><a href="#parseQuery-stringifyQuery" class="headerlink" title="parseQuery / stringifyQuery"></a>parseQuery / stringifyQuery</h2><ul><li>类型: Function<br>提供自定义查询字符串的解析/反解析函数</li></ul><h2 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h2><ul><li>类型: boolean<br>当浏览器不支持 <code>history.pushState</code> 控制路由是否应该回退到 hash 模式. 默认为 <code>true</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;routes&quot;&gt;&lt;a href=&quot;#routes&quot; class=&quot;headerlink&quot; title=&quot;routes&quot;&gt;&lt;/a&gt;routes&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型: Array&lt;RouteConfig&gt;&lt;br&gt;RouteConfig 的类型定义:&lt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router-router-link</title>
    <link href="http://yoursite.com/2020/03/10/vue-router-router-link/"/>
    <id>http://yoursite.com/2020/03/10/vue-router-router-link/</id>
    <published>2020-03-10T12:48:51.000Z</published>
    <updated>2020-03-10T12:49:05.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lt-router-link-gt"><a href="#lt-router-link-gt" class="headerlink" title="&lt;router-link&gt;"></a><code>&lt;router-link&gt;</code></h2><p><code>&lt;router-link&gt;</code> 组件支持用户在具有路由功能的应用中导航, 通过 <code>to</code> 属性指定目标地址, 默认渲染程带有正确连接的 <code>&lt;a&gt;</code> 标签, 可以通过配置 <code>tag</code> 属性生成别的标签. 另外, 当目标路由成功激活时, 连接元素自动设置一个表示激活的 CSS 类名</p><p><code>&lt;router-link&gt;</code> 比起写死的 <code>&lt;a href=&quot;...&quot;&gt;</code> 会好一些</p><ul><li>无论是 HTML5 history 模式还是 hash 模式, 它的表现行为一致, 所以, 当要切换路由模式, 或者在 IE9 降级使用 hash 模式, 无需做任何变动</li><li>在 HTML5 history 模式下, <code>router-link</code> 会守卫点击事件, 让浏览器不在重新加载页面</li><li>在 HTML5 history 模式下使用 <code>base</code> 选项之后, 所有的 <code>to</code> 属性都不需要写了</li></ul><h2 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h2><p><code>router-link</code> 通过一个作用域插槽暴露底层的定制能力. 这是一个更高阶的 API, 主要面向库坐着, 但也可以为开发者提供便利, 多数情况用一个类型 NavLInk 这样的组件里</p><p>在使用 <code>v-slot</code> API 时, 需要向 <code>router-link</code> 传入一个单独的子元素. 否则 <code>router-link</code> 将会把子元素包裹在一个 <code>span</code> 元素内</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">to</span>=<span class="string">"/about"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-slot</span>=<span class="string">"&#123; href, route, navigate, isActive, isExactActive&#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">:active</span>=<span class="string">"isActive"</span> <span class="attr">:href</span>=<span class="string">"href"</span> @<span class="attr">click</span>=<span class="string">"navigate"</span>&gt;</span></span><br><span class="line">    &#123;&#123; toute.fullPath &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>href: 解析后的 URL, 将会作为一个 <code>a</code> 元素的 <code>href</code> attribute</li><li>route: 解析后的规范化的地址</li><li>navigate: 触发导航的函数</li><li>isActive: 如果需要应用激活的 class 则为 true 允许应用一个任意的 class</li><li>isExactActive: 如果需要应用精确激活的 class 则为 true, 允许应用一个任意的 class</li></ul><p>示例: 将激活的 class 应用在外层元素<br>有时候我们可能想把激活的 class 应用到一个外部元素而不是 <code>&lt;a&gt;</code> 标签本身, 这时可以在一个 <code>router-link</code> 中包裹该元素并使用 <code>v-slot</code> property 来创建链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">to</span>=<span class="string">"/foo"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-slot</span>=<span class="string">"&#123;href, route, navigate, isActive, isExactActive&#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"[isActive &amp;&amp; 'router-link-active', isExactActive &amp;&amp; 'router-link-exact-active']"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"href"</span> @<span class="attr">click</span>=<span class="string">"navigate"</span>&gt;</span>&#123;&#123;route.fullPath&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果给 a 元素添加了 target=_blank, 则@click=”navigate” 处理器会被忽略</p></blockquote><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="to"><a href="#to" class="headerlink" title="to"></a>to</h3><ul><li>类型: string | Loaction</li><li>required<br>表示目标路由的链接, 当被点击后, 内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code> 所以这个值可以是一个字符串或者是描述目标位置的对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 命名的路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"</span></span></span><br><span class="line"><span class="tag">  &gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><ul><li>类型: boolean</li><li>默认值: false<br>设置 replace 属性的话, 当点击时, 会调用 route.replace() 而不是 route.push(), 于是导航后不会留下 history 记录</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">replace</span> <span class="attr">:to</span>=<span class="string">"&#123;path: '/abc'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><ul><li>类型: boolean</li><li>默认值: false<br>设置 append 属性后, 则在当前路径前添加基路径, 例如, 从 <code>/a</code> 导航到一个相对路径 <code>b</code>, 如果没有配置 append, 则路径为 <code>/b</code> 如果配置了, 则为 <code>/a/b</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path: '/b'&#125;"</span> <span class="attr">append</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><ul><li>类型: string</li><li>默认值: ‘a’<br>有时候想要 <code>&lt;router-link&gt;</code> 渲染成某种标签, 比如 <code>&lt;li&gt;</code>. 于是我们使用 <code>tag</code> prop 类指定何种标签, 同样它还会监听点击, 触发导航</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path: '/a'&#125;"</span> <span class="attr">tag</span>=<span class="string">"li"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h3><ul><li>类型: string</li><li>默认值: “router-link-active”<br>设置链接激活时使用的 CSS 类名. 默认值可以通过路由的构造选项 <code>linkActiveClass</code> 来全局配置</li></ul><h3 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h3><ul><li><p>类型: boolean</p></li><li><p>默认值: false<br>是否激活默认类名的依据是包含匹配. 举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。</p><p>按照这个规则，每个路由都会激活 <router-link to="/">！想要链接使用“精确匹配模式”，则使用 exact 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">exact</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><ul><li>类型: string</li><li>默认值: “router-link-exact-active”<br>配置当链接被精确匹配的时候应该激活的 class. 注意默认值也是可以通过路由构造函数选项 <code>linkExactActiveClass</code> 进行全局配置的</li></ul><h2 id="lt-router-view-gt"><a href="#lt-router-view-gt" class="headerlink" title="&lt;router-view&gt;"></a><code>&lt;router-view&gt;</code></h2><p><code>&lt;router-view&gt;</code> 组件是一个 functional 组件，渲染路径匹配到的视图组件。<code>&lt;router-view&gt;</code> 渲染的组件还可以内嵌自己的 <code>&lt;router-view&gt;</code>，根据嵌套路径，渲染嵌套组件。</p><p>其他属性 (非 router-view 使用的属性) 都直接传给渲染的组件， 很多时候，每个路由的数据都是包含在路由参数中。</p><p>因为它也是个组件，所以可以配合 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 使用。如果两个结合一起用，要确保在内层使用 <code>&lt;keep-alive&gt;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;lt-router-link-gt&quot;&gt;&lt;a href=&quot;#lt-router-link-gt&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;router-link&amp;gt;&quot;&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;&lt;
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由懒加载</title>
    <link href="http://yoursite.com/2020/03/09/vue-router%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2020/03/09/vue-router%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/</id>
    <published>2020-03-09T01:44:54.000Z</published>
    <updated>2020-03-09T01:45:07.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时, JavaScript 包会变得非常大, 影响页面加载. 如果我们能把不同路由对相应的组件分隔成不同的代码块, 然后当路由被访问的时候才加载对应组件, 这就更加高效了</p><p>结合 Vue 的异步组件和 Webpack 的代码分隔功能, 轻松实现路由组建的懒加载</p><p>首先, 可以将异步组件定义为返回一个 Promise 的工厂函数(该函数返回的 Promise 应该 resolve 组件本身)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    <span class="comment">/* 组件定义对象 */</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>第二, 在 Webpack2 中, 我们可以使用动态 import 语法来定义代码分快点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>) <span class="comment">// 返回 Promise</span></span><br></pre></td></tr></table></figure><blockquote><p>如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。</p></blockquote><p>结合这两者, 这就是如果定义一个能够被 Webpack 自动代码分隔的异步组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br></pre></td></tr></table></figure><p>在路由配置中什么都不需要改变, 只需要像往常一样使用 Foo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h2><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Foo.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Bar.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-foo" */</span> <span class="string">'./Baz.vue'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由懒加载&quot;&gt;&lt;a href=&quot;#路由懒加载&quot; class=&quot;headerlink&quot; title=&quot;路由懒加载&quot;&gt;&lt;/a&gt;路由懒加载&lt;/h2&gt;&lt;p&gt;当打包构建应用时, JavaScript 包会变得非常大, 影响页面加载. 如果我们能把不同路由对相应的组件分隔成不
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router滚动行为</title>
    <link href="http://yoursite.com/2020/03/08/vue-router%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/"/>
    <id>http://yoursite.com/2020/03/08/vue-router%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/</id>
    <published>2020-03-08T10:50:28.000Z</published>
    <updated>2020-03-08T10:50:42.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>使用前端路由, 当切换到新路由时, 想要页面滚到顶部, 或者是保持原先的滚动位置, 就像重新加载页面那样. <code>vue-router</code> 能做到, 而且更好, 它让你可以自定义路由切换时页面如何滚动.</p><blockquote><p>注意: 这个功能只在支持 <code>history.pushState</code> 的浏览器中可用</p></blockquote><p>当创建一个 Router 实例, 可以提供一个 <code>scrollBehavior</code> 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>scrollBehavior</code> 方法接受 <code>to</code> 和 <code>from</code> 路由对象, 第三个参数 <code>savedPosition</code> 并且仅当 <code>popstate</code> 导航时才可用.</p><p>这个方法返回滚动位置的对象信息:</p><ul><li><code>{x: number, y: number}</code></li><li><code>{selector: string, offset: {x: number, y: number}}</code></li></ul><p>如果返回一个 falsy 的值, 或者是一个空对象,那么不会发生滚动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior(to, <span class="keyword">from</span>, savePosition) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于所有路由导航, 简单地让页面滚动到顶部</p><p>返回 <code>savedPosition</code>, 在按下 后退/前进 按钮时, 就会像浏览器的原生表现那样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> savedPosition</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要模拟 滚动到锚点 的行为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      selector: to.hash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步滚动"><a href="#异步滚动" class="headerlink" title="异步滚动"></a>异步滚动</h2><p>也可以返回一个 Promise 来得出预期的位置描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其挂载到从页面级别的过渡组件的事件上，令其滚动行为和页面过渡一起良好运行是可能的。但是考虑到用例的多样性和复杂性，我们仅提供这个原始的接口，以支持不同用户场景的具体实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;滚动行为&quot;&gt;&lt;a href=&quot;#滚动行为&quot; class=&quot;headerlink&quot; title=&quot;滚动行为&quot;&gt;&lt;/a&gt;滚动行为&lt;/h2&gt;&lt;p&gt;使用前端路由, 当切换到新路由时, 想要页面滚到顶部, 或者是保持原先的滚动位置, 就像重新加载页面那样. &lt;code&gt;vu
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router获取数据</title>
    <link href="http://yoursite.com/2020/03/07/vue-router%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2020/03/07/vue-router%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2020-03-07T08:33:08.000Z</published>
    <updated>2020-03-07T08:33:20.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>有时候, 进入某个路由后, 需要从服务器获取数据, 例如, 在渲染用户信息时, 需要从服务器获取用户的数据. 我们可以通过两种方式来实现:</p><ul><li>导航完成之后获取: 先完成导航, 然后再接下来的组件生命周期钩子中获取数据. 在数据获取期间显示”加载中”字样</li><li>导航完成之前获取: 导航完成前, 在路由进入的守卫中获取数据, 在数据获取成功后执行导航</li></ul><h2 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h2><p>当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p><p>假设我们有一个 <code>Post</code> 组件，需要基于 $route.params.id 获取文章数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error"</span> <span class="attr">v-if</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 组件创建完后获取数据，</span></span><br><span class="line">    <span class="comment">// 此时 data 已经被 observed 了</span></span><br><span class="line">    <span class="keyword">this</span>.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果路由有变化，会再次执行该方法</span></span><br><span class="line">    <span class="string">'$route'</span>: <span class="string">'fetchData'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData () &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// replace getPost with your data fetching util / API wrapper</span></span><br><span class="line">      getPost(<span class="keyword">this</span>.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = err.toString()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h2><p>通过这种方式, 我们在导航转入新的路由前获取数据. 我们可以在接下来的组件 <code>beforeRouteEnter</code> 守卫中获取数据, 当数据获取成功后只调用 <code>next</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(<span class="function"><span class="params">vm</span> =&gt;</span> vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 路由改变前，组件就已经渲染完了</span></span><br><span class="line">  <span class="comment">// 逻辑稍稍不同</span></span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(err, post)</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData(err, post) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">this</span>.error = err.toString()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.post = post</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据获取&quot;&gt;&lt;a href=&quot;#数据获取&quot; class=&quot;headerlink&quot; title=&quot;数据获取&quot;&gt;&lt;/a&gt;数据获取&lt;/h2&gt;&lt;p&gt;有时候, 进入某个路由后, 需要从服务器获取数据, 例如, 在渲染用户信息时, 需要从服务器获取用户的数据. 我们可以通过两
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router过渡动效</title>
    <link href="http://yoursite.com/2020/03/06/vue-router%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88/"/>
    <id>http://yoursite.com/2020/03/06/vue-router%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88/</id>
    <published>2020-03-06T13:24:24.000Z</published>
    <updated>2020-03-06T13:24:39.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h2><p><code>&lt;router-view&gt;</code> 是基本的动态组件, 所以我们可以用 <code>&lt;transition&gt;</code> 组件给他添加一些过渡效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单个路由的过渡"><a href="#单个路由的过渡" class="headerlink" title="单个路由的过渡"></a>单个路由的过渡</h2><p>上面的用法会给所有的路由设置一样的过渡效果, 如果想让每个路由组件有各自的过渡效果, 可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 name</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;transition&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="foo"&gt; ... &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;/transition&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bar = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;transition&gt;</span></span><br><span class="line"><span class="string">      &lt;div class="bar"&gt; ... &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/transition&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于路由的动态过渡"><a href="#基于路由的动态过渡" class="headerlink" title="基于路由的动态过渡"></a>基于路由的动态过渡</h2><p>还可以基于当前路由与目标路由的变化关系, 动态设置过渡效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"transitionNmae"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wathc: &#123;</span><br><span class="line">  <span class="string">"$route"</span>(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> toDepth = to.path.split(<span class="string">'/'</span>).length</span><br><span class="line">    <span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">'/'</span>).length</span><br><span class="line">    <span class="keyword">this</span>.transitionName = toDepth &lt; fromDepth ? <span class="string">'slide-right'</span> : <span class="string">'slide-left'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过渡动效&quot;&gt;&lt;a href=&quot;#过渡动效&quot; class=&quot;headerlink&quot; title=&quot;过渡动效&quot;&gt;&lt;/a&gt;过渡动效&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 是基本的动态组件, 所以我们可以用 &lt;code&gt;&amp;lt;t
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由元信息</title>
    <link href="http://yoursite.com/2020/03/06/vue-router%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2020/03/06/vue-router%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/</id>
    <published>2020-03-06T13:08:57.000Z</published>
    <updated>2020-03-06T13:09:11.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      chidren: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/bar'</span>,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123;</span><br><span class="line">            <span class="comment">// a meta field</span></span><br><span class="line">            requiresAuth: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们称呼 <code>routes</code> 配置中的每个路由对象为路由记录, 路由记录可以是嵌套的, 因此, 当一个路由匹配成功后, 他可能匹配多个路由记录</p><p>例如上次面的配置, <code>/for/bar</code> 这个 RUL 将会匹配父路由以及子路由记录</p><p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的 <code>$route.matched</code> 数组. 因此, 我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段</p><p>下面的例子展示在全局导航守卫中检查元字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;</span><br><span class="line">    <span class="comment">// this route requires auth, check if logged in</span></span><br><span class="line">    <span class="comment">// if not, redirect to login page.</span></span><br><span class="line">    <span class="keyword">if</span> (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          redirect: to.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next() <span class="comment">// 确保一定要调用 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由元信息&quot;&gt;&lt;a href=&quot;#路由元信息&quot; class=&quot;headerlink&quot; title=&quot;路由元信息&quot;&gt;&lt;/a&gt;路由元信息&lt;/h2&gt;&lt;p&gt;定义路由的时候可以配置 &lt;code&gt;meta&lt;/code&gt; 字段:&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
  <entry>
    <title>vue-router导航守卫</title>
    <link href="http://yoursite.com/2020/03/06/vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"/>
    <id>http://yoursite.com/2020/03/06/vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</id>
    <published>2020-03-06T12:46:26.000Z</published>
    <updated>2020-03-06T12:46:39.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p><code>vue-route</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航, 有多种机会植入路由导航过程中: 全局、单个路由独享、组件级</p><p>参数或查询的改变并不会触发进入/离开的导航守卫, 可以通过观察 <code>$route</code> 对象来应对这些变化, 或使用 <code>beforeRouteUpdate</code> 的组件内守卫</p><h2 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h2><p>可以使用 <code>router.beforeEach</code> 注册一个全局的前置守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;...&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>,  next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个导航触发时, 全局前置守卫按照创建顺序调用. 守卫是异步解析执行, 此时导航在所有守卫 resolve 完之前一直处于等待中</p><p>每个守卫方法接受三个参数:</p><ul><li>to: Route: 即将要进入的目标路由对象</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子. 执行效果依赖 <code>next</code> 方法的调用参数<ul><li>next(): 进行管道中的下一个钩子, 如果全部钩子执行完了, 则导航的状态就是 confirmed(确认的)</li><li>next(false): 中断当前的导航. 如果浏览器的 URL 改变了(可能是用户手动或浏览器后退按钮), 那么 URL 地址会重置到 <code>from</code> 路由对应的地址</li><li>next(‘/‘): 或者 next({path: ‘/‘}): 跳转到一个不同的地址. 当前的导航被终端, 然后进行一个新的导航. 可以向 <code>next</code> 传递任意位置对象, 且允许设置如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <code>router-link</code> 的 <code>to</code> prop 或 <code>router.push</code> 中的选项</li><li>next(error): 如果传入 next 的参数是一个 error 实例, 则导航会被终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调</li></ul></li></ul><blockquote><p>确保要调用 next 方法，否则钩子就不会被 resolved。</p></blockquote><h2 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h2><p>可以用 <code>router.beforeResolve()</code> 注册一个全局守卫, 这个 <code>router.beforeEach</code> 类似, 区别是在导航被确认之前, 同时在所有组件内守卫和异步路由组件被解析之后, 解析守卫就被调用</p><h2 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h2><p>可以通过 <code>afterEach</code> 注册全局后置钩子, 与守卫不同的是, 这些钩子不会接受 <code>next</code> 函数也不会改变导航本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h2><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的</p><h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><p>可以在路由组件内直接定义一下路由导航守卫</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code></li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不能获取组件实例 this</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前, 组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变, 但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeRouteEnter</code> 守卫不能访问 <code>this</code>, 因为守卫在导航确认前被调用, 因此即将登场的新组建还没被创建<br>不过, 可以通过传一个回调给 <code>next</code> 来访问组件实例, 在导航被确认的时候执行回调, 并且把组件实例作为回调方法的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫. 对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说, <code>this</code> 已经可用了, 所以不支持传递回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// just user this</span></span><br><span class="line">  <span class="keyword">this</span>.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开. 该导航可以通过 <code>next(false)</code> 来取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">'Do you really want to leave? you have unsaved changes!'</span>)</span><br><span class="line">  answer ? next() : next(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h2><ol><li>导航被触发</li><li>在失活的组件里调用离开守卫</li><li>调用全局的 <code>beforeEach</code> 守卫</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫</li><li>在路由配置里调用 <code>beforeRouteEnter</code></li><li>解析异步路由组件</li><li>在被激活的组件里调用 <code>beforeResolve</code> 守卫</li><li>调用全局的 <code>beforeResolve</code> 守卫</li><li>导航被确认</li><li>调用全局的 <code>afterEach</code> 守卫</li><li>触发 DOM 更新</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导航守卫&quot;&gt;&lt;a href=&quot;#导航守卫&quot; class=&quot;headerlink&quot; title=&quot;导航守卫&quot;&gt;&lt;/a&gt;导航守卫&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vue-route&lt;/code&gt; 提供的导航守卫主要用来通过跳转或取消的方式守卫导航, 有多种机会植入路由导航过
      
    
    </summary>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/categories/VueRoute/"/>
    
    
      <category term="VueRoute" scheme="http://yoursite.com/tags/VueRoute/"/>
    
  </entry>
  
</feed>
